<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drakichi Typing｜英語学習ドリル</title>
  <meta name="description" content="学校・家庭学習向けの英語タイピング練習（教材）サイトです。広告はありません。授業や家庭での反復練習を目的としています。中学生向けの英語学習ドリル（語彙・例文・タイピング）。学習回数や正答率を記録し、復習（SRS）にも対応します。">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Drakichi Typing｜英語学習ドリル">
  <meta property="og:description" content="学校・家庭学習向けの英語タイピング練習（教材）サイトです。広告はありません。授業や家庭での反復練習を目的としています。中学生向けの英語学習ドリル（語彙・例文・タイピング）。学習回数や正答率を記録し、復習（SRS）にも対応します。">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Drakichi Typing｜英語学習ドリル">
  <meta name="twitter:description" content="学校・家庭学習向けの英語タイピング練習（教材）サイトです。広告はありません。授業や家庭での反復練習を目的としています。中学生向けの英語学習ドリル（語彙・例文・タイピング）。学習回数や正答率を記録し、復習（SRS）にも対応します。">

  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "EducationalApplication",
    "name": "Drakichi Typing",
    "url": "https://drakichityping.shop/",
    "provider": {"@type": "Organization", "name": "Drakichi English"},
    "applicationCategory": "EducationalApplication",
    "description": "学校・家庭学習向けの英語タイピング練習（教材）サイトです。広告はありません。授業や家庭での反復練習を目的としています。中学生向けの英語学習ドリル（語彙・例文・タイピング）。学習回数や正答率を記録し、復習（SRS）にも対応します。",
    "educationalUse": ["practice", "assessment"],
    "audience": {"@type":"EducationalAudience","educationalRole":["student","teacher"]},
    "inLanguage": "ja"
  }
  </script>


  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- FontAwesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
  <!-- PapaParse -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <!-- Encoding.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/2.0.0/encoding.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&family=Noto+Sans+JP:wght@400;700&display=swap');

    body{
      font-family:'Noto Sans JP',sans-serif;
      background:#f1f5f9;
      touch-action:manipulation;
      user-select:none;
    }
    .font-mono{font-family:'Roboto Mono',monospace;}

    @keyframes fade-in{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
    .anim-fade-in{animation:fade-in .25s ease-out}

    @keyframes pop{0%{transform:scale(.97)}50%{transform:scale(1.05)}100%{transform:scale(1)}}
    .anim-pop{animation:pop .12s ease-out}

    @keyframes shake{0%{transform:translateX(0)}20%{transform:translateX(-6px)}40%{transform:translateX(6px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}100%{transform:translateX(0)}}
    .anim-shake{animation:shake .16s ease-out}

    @keyframes gold-flash{
      0%{opacity:0}
      15%{opacity:1}
      100%{opacity:0}
    }
    .anim-gold-flash{animation:gold-flash 2s ease-out forwards; background:radial-gradient(circle, rgba(255,255,200,1) 0%, rgba(255,215,0,0.8) 40%, rgba(255,165,0,0.6) 100%); mix-blend-mode:screen;}

    /* Typing styles */
    .char-base{
      display:inline-block;
      min-width:.6em;
      text-align:center;
      white-space:pre-wrap;
      transition:all .08s;
    }
    
    /* Prevent mid-word wrapping: wrap chars inside a no-wrap word unit */
    .word-unit{
      display:inline-flex;
      flex-wrap:nowrap;
      white-space:nowrap;
      align-items:baseline;
    }
    /* Grammar role coloring via markup tags:
       Use [S]...[/S] [V]...[/V] [O]...[/O] [O1]...[/O1] [O2]...[/O2] [C]...[/C] [M]...[/M]
       (or <S>...</S> etc.). Untagged parts are treated as M when tags exist. */
    .role-S{color:#ef4444;} /* Subject */
    .role-V{color:#f59e0b;} /* Verb/Predicate */
    .role-O{color:#3b82f6;} /* Object */
    .role-O1{color:#3b82f6;} /* Object 1 (Indirect Object) */
    .role-O2{color:#38bdf8;} /* Object 2 (Direct Object) */
    .role-C{color:#22c55e;} /* Complement */
    .role-M{color:#111827;} /* Modifier/Other */

    /* Let prompt characters inherit the role color (char-default is normally gray) */
    .role-S .char-default,
    .role-V .char-default,
    .role-O .char-default,
    .role-O1 .char-default,
    .role-O2 .char-default,
    .role-C .char-default,
    .role-M .char-default{ color: inherit; }

.char-correct{color:#0369a1;font-weight:700;text-shadow:0 0 5px rgba(3,105,161,.18);}
    .char-default{color:#64748b;}
    .char-wrong{background:#fee2e2;color:#dc2626;border-radius:2px;}

    .char-hidden{
      color:transparent;
      border-bottom:2px solid #cbd5e1;
      height:1.2em;
    }
    .char-hidden.char-wrong{border-bottom-color:#dc2626;}

    .cursor-bar{
      display:inline-block;
      width:2px;
      height:1.2em;
      background:#0369a1;
      vertical-align:text-bottom;
      margin:0 1px;
      animation:blink 1s step-end infinite;
    }
    @keyframes blink{50%{opacity:0}}

    /* Scrollbar */
    ::-webkit-scrollbar{width:8px}
    ::-webkit-scrollbar-track{background:#f1f5f9}
    ::-webkit-scrollbar-thumb{background:#cbd5e1;border-radius:4px}
    ::-webkit-scrollbar-thumb:hover{background:#94a3b8}

    /* FULL CLEAR glow */
    @keyframes full-glow{
      0%{box-shadow:0 0 0 rgba(255,215,0,.0)}
      50%{box-shadow:0 0 22px rgba(255,215,0,.35)}
      100%{box-shadow:0 0 0 rgba(255,215,0,.0)}
    }
    .full-clear-glow{animation:full-glow 1.6s ease-in-out infinite;}

    /* ===== iPhone / small-screen layout fixes ===== */
    /* Use stable viewport units on mobile so buttons (like START) don't fall below the screen */
    #app-container{
      height: min(800px, calc(100svh - 2rem));
    }
    @supports not (height: 100svh){
      #app-container{
        height: min(800px, calc(100vh - 2rem));
      }
    }
    /* Allow inner screens to scroll safely (including iPhone safe area) */
    .screen-scroll{
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding-bottom: calc(2rem + env(safe-area-inset-bottom));
    }

    /* iOSでスクロールが効かない対策（成績/セクションなど） */
    .scroll-touch{
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
    }

    /* Sidebar scrollbar (optional) */
    .sidebar-scroll{ scrollbar-width: thin; scrollbar-color: rgba(255,255,255,.18) rgba(255,255,255,.05); }
    .sidebar-scroll::-webkit-scrollbar{ width: 10px; }
    .sidebar-scroll::-webkit-scrollbar-track{ background: rgba(255,255,255,.05); }
    .sidebar-scroll::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.18); border-radius: 999px; border: 2px solid rgba(11,19,32,1); }


    /* iOS: canvas上でスワイプするとスクロールが止まる対策 */
    .chart-canvas{
      pointer-events: none;
      touch-action: pan-y;
    }

    /* Stats screen: use outer container scroll to avoid iOS nested-scroll bugs */
    .stats-root-scroll{
      overflow-y: auto !important;
      overflow-x: hidden !important;
      -webkit-overflow-scrolling: touch;
      touch-action: pan-y;
    }
    .stats-main-visible{
      overflow: visible !important;
    }
    .chart-canvas{ display:block; }

  

    /* === Mobile Portrait UX Patch v6 === */
    @media (max-width: 640px){
      body{ padding: 10px !important; }
      #app-container{
        height: 100dvh !important;
        max-width: 100% !important;
        border-radius: 24px !important;
      }

      /* Top control bar: wrap + compact + hide text labels */
      #data-ctrl-area{
        left: 10px !important;
        right: 10px !important;
        top: 10px !important;
        max-width: calc(100% - 20px) !important;
        flex-wrap: wrap !important;
        gap: 6px 8px !important;
        padding: 8px !important;
        justify-content: space-between !important;
      }
      #data-ctrl-area .ctrl-text{ display: none !important; }
      #data-ctrl-area button,
      #data-ctrl-area label{
        padding: 6px 10px !important;
        font-size: 12px !important;
      }
      #data-ctrl-area .border-r{ border-right: none !important; }
      #data-ctrl-area .bgm-vol-row{
        padding: 6px 10px !important;
        border-right: none !important;
      }
      #data-ctrl-area .bgm-vol-row input[type=range]{ width: 72px !important; }
      #data-ctrl-area .title-bgm-row{
        flex: 1 1 100% !important;
        border-right: none !important;
        padding: 6px 10px !important;
      }
      #title-bgm-select{ width: 100% !important; max-width: 100% !important; }

      /* BGM hint box: keep inside */
      #bgm-hint{
        left: 10px !important;
        right: 10px !important;
        top: 62px !important;
      }

      /* Back button: keep visible below the control bar */
      #back-btn{
        top: 70px !important;
        left: 10px !important;
      }

      /* Practice header badges: smaller + tighter */
      #screen-practice .absolute.top-0.left-0.w-full.p-4{
        padding: 10px !important;
      }
      #practice-mode-badge,#practice-wpm-badge,#practice-judge-badge{
        padding: 4px 10px !important;
        font-size: 11px !important;
      }

      /* Practice word row: avoid speaker overlap */
      #practice-word-row{
        flex-direction: column !important;
        gap: 10px !important;
        align-items: center !important;
      }
      #replay-voice-btn{
        position: static !important;
        transform: none !important;
        padding: 10px !important;
      }
      #word-display{
        padding-left: 6px !important;
        padding-right: 6px !important;
        font-size: clamp(28px, 8vw, 44px) !important;
        letter-spacing: 0.08em !important;
      }

      #practice-input{
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
        width: 1px !important;
        height: 1px !important;
      }
#practice-input:focus{
        outline: none !important;
        box-shadow: 0 0 0 4px rgba(56,189,248,0.18) !important;
        border-color: rgba(14,165,233,0.8) !important;
      }
      #practice-bottom-controls{
        bottom: 80px !important;
      }
      #feedback-msg{
        bottom: 66px !important;
      }

      /* Result & other screens padding */
      #screen-practice{ padding: 12px !important; }
    }

  

    /* === Mobile Portrait UX Patch v7 (coarse pointer / iPad portrait too) === */
    @media (hover: none) and (pointer: coarse) and (orientation: portrait){
      body{ padding: 10px !important; }
      #app-container{
        height: 100dvh !important;
        max-width: 100% !important;
        border-radius: 24px !important;
      }

      /* Top control bar: use GRID so必ず折り返す */
      #data-ctrl-area{
        left: 10px !important;
        right: 10px !important;
        top: 10px !important;
        max-width: calc(100% - 20px) !important;
        display: grid !important;
        grid-template-columns: repeat(4, minmax(0, 1fr)) !important;
        gap: 8px !important;
        padding: 8px !important;
        align-items: center !important;
        justify-items: stretch !important;
      }
      #data-ctrl-area .ctrl-text{ display:none !important; }
      #data-ctrl-area .border-r{ border-right:none !important; }
      #data-ctrl-area button,
      #data-ctrl-area label,
      #data-ctrl-area .bgm-vol-row,
      #data-ctrl-area .title-bgm-row{
        width: 100% !important;
        justify-content: center !important;
        padding: 10px 8px !important;
        font-size: 12px !important;
        border-radius: 14px !important;
      }
      #data-ctrl-area button,
      #data-ctrl-area label{
        background: rgba(255,255,255,0.92) !important;
      }
      /* let certain items span full row */
      #data-ctrl-area .bgm-vol-row{ grid-column: 1 / -1 !important; justify-content: space-between !important; }
      #data-ctrl-area .title-bgm-row{ grid-column: 1 / -1 !important; }
      #data-ctrl-area label[for='csv-file-input']{ grid-column: 1 / 3 !important; }
      #data-ctrl-area button[onclick*="goToScreen('csvroom')"]{ grid-column: 3 / 4 !important; }
      #data-ctrl-area #srs-panel-btn{ grid-column: 4 / 5 !important; }
      #title-bgm-select{ width: 100% !important; max-width: 100% !important; }
      #data-ctrl-area .bgm-vol-row input[type=range]{ width: 52vw !important; max-width: 260px !important; }

      /* Hint box below control bar */
      #bgm-hint{ left: 10px !important; right: 10px !important; top: 118px !important; }
      #back-btn{ top: 128px !important; left: 10px !important; }

      /* Practice word row: avoid speaker overlap */
      #practice-word-row{ flex-direction: column !important; gap: 10px !important; align-items: center !important; }
      #replay-voice-btn{ position: static !important; transform:none !important; padding: 12px !important; }
      #word-display{ padding-left: 6px !important; padding-right: 6px !important; font-size: clamp(28px, 8vw, 44px) !important; letter-spacing: 0.08em !important; }

      /* Mobile: keep the real input hidden (no flick/IME UI bar) */
      #practice-input{
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
        width: 1px !important;
        height: 1px !important;
        background: transparent !important;
        border: 0 !important;
        padding: 0 !important;
        z-index: 0 !important;
      }
/* Keep bottom controls above keyboard input */
      #practice-bottom-controls{ bottom: 86px !important; }
      #feedback-msg{ bottom: 72px !important; }
    }

  
/* === Mobile portrait: collapsible top control bar (prevents blocking taps) === */
@media (hover:none) and (pointer:coarse) and (orientation:portrait){
  /* show a compact toggle button */
  #ctrl-toggle-btn{
    display:flex !important;
    position: fixed !important;
    top: 14px !important;
    right: 14px !important;
    z-index: 70 !important;
  }
  /* control overlay */
  #ctrl-overlay{ display:none; }
  body.ctrl-expanded #ctrl-overlay{ display:block !important; }

  /* data controls become a modal-like panel */
  #data-ctrl-area{
    position: fixed !important;
    top: 14px !important;
    left: 14px !important;
    right: 14px !important;
    width: auto !important;
    max-width: none !important;
    flex-wrap: wrap !important;
    gap: 10px !important;
    padding: 12px !important;
    border-radius: 18px !important;
    z-index: 75 !important;
    transition: transform .22s ease, opacity .22s ease !important;
  }
  /* collapsed by default */
  body.ctrl-collapsed #data-ctrl-area{
    transform: translateY(-130%) !important;
    opacity: 0 !important;
    pointer-events: none !important;
  }
  body.ctrl-expanded #data-ctrl-area{
    transform: translateY(0) !important;
    opacity: 1 !important;
    pointer-events: auto !important;
  }
  /* close button appears inside panel; hide toggle when open */
  #ctrl-close-btn{ display:flex !important; }
  body.ctrl-expanded #ctrl-toggle-btn{ display:none !important; }

  /* shrink text labels to avoid wrapping too tall; icons still visible */
  #data-ctrl-area .ctrl-text{ display:none !important; }
  #data-ctrl-area .bgm-vol-row{ flex: 1 1 100% !important; border-right: none !important; padding-right: 0 !important; }
  #data-ctrl-area .title-bgm-row{ flex: 1 1 100% !important; border-right: none !important; padding-right: 0 !important; }
  #data-ctrl-area #bgm-vol{ width: 100% !important; max-width: 320px !important; }
  #data-ctrl-area #title-bgm-select{ width: 100% !important; max-width: 520px !important; }

  /* give back button its own lane */
  #back-btn{ top: 14px !important; left: 14px !important; z-index: 76 !important; }
}


    /* === Mobile keyboard & toast visibility patch v9 === */
    :root{ --kb-offset: 0px; }

    /* feedback (Good/Hard/etc) should be visible even when iOS keyboard is open */
    #feedback-msg{
      position: fixed !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      bottom: auto !important;
      top: calc(env(safe-area-inset-top, 0px) + 92px) !important;
      z-index: 95 !important;
      pointer-events: none !important;
      background: rgba(255,255,255,0.92) !important;
      border: 1px solid rgba(226,232,240,0.9) !important;
      padding: 10px 14px !important;
      border-radius: 9999px !important;
      box-shadow: 0 10px 30px rgba(15,23,42,0.12) !important;
      max-width: calc(100vw - 24px) !important;
      text-align: center !important;
      white-space: nowrap !important;
      overflow: hidden !important;
      text-overflow: ellipsis !important;
    }
      /* Hide native input visuals on mobile when keyboard is open (avoid iOS flick bar covering the typed text).
         Keep the input focused, but show typed text via #typed-preview. */
      body.kb-open #practice-input{
        opacity: 0 !important;
        height: 1px !important;
        padding: 0 !important;
        border: 0 !important;
        background: transparent !important;
        box-shadow: none !important;
      }
    /* Ensure toast is always visible above keyboard/UI */
    #feedback-msg{
      position: fixed !important;
      z-index: 999 !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      max-width: min(92vw, 520px) !important;
      pointer-events: none !important;
    }

</style>
</head>

<body class="min-h-screen flex flex-col items-center justify-center p-4 text-gray-800">

  <!-- Start Overlay -->
  <div id="start-overlay" class="fixed inset-0 z-[1000001] flex items-center justify-center bg-slate-900/95 transition-opacity duration-500 cursor-pointer" style="touch-action: manipulation;">
    <div class="text-center text-white animate-pulse">
      <div class="text-6xl mb-4"><i class="fas fa-graduation-cap"></i></div>
      <h1 class="text-3xl font-black tracking-widest">これは勉強のためのサイトです。</h1>
      <p class="mt-2 text-sm text-slate-400 font-bold">画面をクリックして学習開始（音が出ます）</p>
    </div>
  </div>

  <div id="app-container"
       class="bg-white w-full max-w-6xl rounded-3xl shadow-xl overflow-hidden relative border border-slate-200 flex flex-col h-[800px] transition-all duration-300">

    <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-sky-500 via-blue-500 to-indigo-500"></div>

    <!-- Confetti Canvas -->
    <canvas id="confetti-canvas" class="pointer-events-none absolute inset-0 w-full h-full z-40 hidden"></canvas>

    <!-- Data Controls -->

<!-- Mobile portrait: Control overlay + toggle -->
<div id="ctrl-overlay" class="fixed inset-0 z-[55] hidden bg-black/30"></div>
<button id="ctrl-toggle-btn" type="button"
        class="hidden items-center justify-center w-11 h-11 rounded-full bg-white/90 border border-slate-200 shadow-md text-slate-700 active:scale-95 transition"
        title="メニュー">
  <i class="fas fa-sliders"></i>
</button>

    <div id="data-ctrl-area"
         class="absolute top-4 right-6 z-50 flex items-center gap-2 bg-white/90 p-1.5 rounded-xl backdrop-blur-sm shadow-sm border border-gray-100">

<button id="ctrl-close-btn" type="button"
        class="hidden items-center gap-2 px-3 py-2 text-xs font-black text-slate-700 bg-white border border-slate-200 rounded-xl shadow-sm"
        title="閉じる">
  <i class="fas fa-xmark"></i> 閉じる
</button>


      <button onclick="goToScreen('stats')"
              class="text-slate-500 hover:text-blue-600 px-3 py-1 text-xs font-bold transition flex items-center gap-2 border-r border-gray-200">
        <i class="fas fa-chart-pie"></i> <span class="ctrl-text">成績</span>
      </button>



      <button id="manual-btn" onclick="openManual()"
              class="text-slate-500 hover:text-blue-600 px-3 py-1 text-xs font-bold transition flex items-center gap-2 border-r border-gray-200">
        <i class="fas fa-book"></i> <span class="ctrl-text">説明書</span>
      </button>

            <!-- BGM Volume -->
            <div class="bgm-vol-row flex items-center gap-2 px-3 py-1 text-xs font-bold text-slate-500 border-r border-gray-200">
                <i class="fas fa-music"></i>
                <input id="bgm-vol" type="range" min="0" max="100" value="25"
                       class="w-24 accent-sky-600 cursor-pointer">
                <button id="bgm-mute-btn" class="text-slate-400 hover:text-sky-600 transition" title="BGM ミュート">
                    <i class="fas fa-volume-xmark"></i>
                </button>
            </div>


<!-- Title BGM Select -->
<div class="title-bgm-row flex items-center gap-2 px-3 py-1 text-xs font-bold text-slate-500 border-r border-gray-200" title="タイトル画面BGM">
  <i class="fas fa-compact-disc"></i>
  <select id="title-bgm-select"
          class="text-xs border border-slate-200 rounded-lg px-2 py-1 bg-white hover:border-sky-300 focus:outline-none focus:ring-2 focus:ring-sky-200">
  </select>
</div>

      <button onclick="goToScreen('csvroom')"
              class="text-slate-500 hover:text-blue-600 px-3 py-1 text-xs font-bold transition flex items-center gap-2 border-r border-gray-200" title="CSV置き場（配布用）">
        <i class="fas fa-box-archive"></i> <span class="ctrl-text">CSV置き場</span>
      </button>

      <label for="csv-file-input"
             class="cursor-pointer bg-sky-50 border border-sky-200 text-sky-700 hover:bg-sky-100 px-3 py-1.5 rounded-lg text-xs font-bold transition flex items-center gap-2 shadow-sm">
        <i class="fas fa-file-upload"></i> <span class="ctrl-text">CSV Import</span>
      </label>
      <input type="file" id="csv-file-input" accept=".csv" class="hidden">

      <button onclick="openPasteModal()"
              class="text-slate-500 hover:text-blue-600 px-3 py-1 text-xs font-bold transition flex items-center gap-2 border-r border-gray-200" title="コピペから Custom に追加（例文/単語）">
        <i class="fas fa-paste"></i> <span class="ctrl-text">コピペ追加</span>
      </button>

      <button onclick="clearAllData()"
              class="text-gray-300 hover:text-red-400 px-2 transition text-xs" title="データ全削除">
        <i class="fas fa-trash-alt"></i>
      </button>
      <button onclick="openDataManager()"
              class="text-slate-500 hover:text-sky-600 px-2 transition text-xs" title="データ管理（選択削除）">
        <i class="fas fa-database"></i>
      </button>
      <button id="srs-panel-btn" onclick="openSrsPanel()"
              class="text-slate-500 hover:text-blue-600 px-3 py-1 text-xs font-bold transition flex items-center gap-2" title="SRS 管理">
        <i class="fas fa-brain"></i> <span class="ctrl-text">SRS</span>
      </button>
    </div>

    <!-- BGM blocked hint (shows only when autoplay is blocked) -->
    <div id="bgm-hint" style="display:none"
         class="absolute top-16 right-6 z-50 flex items-center gap-2 bg-yellow-50/95 border border-yellow-200 text-yellow-900 px-3 py-2 rounded-xl shadow-md backdrop-blur-sm">
      <i class="fas fa-volume-high"></i>
      <div class="text-xs font-bold">音がブロック中。ここを押して音ON</div>
      <button id="bgm-hint-btn" class="ml-1 bg-yellow-200 hover:bg-yellow-300 px-2 py-1 rounded-lg text-xs font-bold">ON</button>
    </div>


    <!-- Back -->
    <button id="back-btn"
            class="absolute top-4 left-6 z-50 text-slate-500 hover:text-blue-600 transition hidden font-bold flex items-center gap-2 bg-white/80 px-4 py-2 rounded-full shadow-sm backdrop-blur-sm border border-gray-100 hover:bg-white">
      <i class="fas fa-arrow-left"></i> <span id="back-label">Back</span>
    </button>

    <main id="main-content" class="flex-1 w-full h-full relative overflow-hidden min-h-0">

      <!-- 1) Grade / Title -->
      <div id="screen-grade" class="screen w-full h-full relative anim-fade-in overflow-hidden">

        <!-- Two-panel layout (like the sample image) -->
        <div class="absolute inset-0 flex flex-col md:flex-row">

          <!-- LEFT: Sidebar -->
          <aside class="relative w-full md:w-[440px] bg-[#0b1320] text-white px-7 sm:px-10 py-9 sm:py-12 flex flex-col gap-7 sm:gap-8 h-full overflow-y-auto scroll-touch sidebar-scroll">

            <!-- Header -->
            <div>
              <div class="flex items-center gap-3 text-[11px] tracking-[0.35em] text-sky-300/90">
                <span class="inline-block w-8 h-[2px] bg-sky-400/70"></span>
                <span class="font-bold">ENGLISH DRILL</span>
              </div>

              <div class="mt-3 text-xs font-bold text-white/60 tracking-wide">学習サイトです。フィルターかけるのやめてください。一生懸命作りました。もうDrakichiのHPはゼロです。</div>
              <div class="mt-2 text-xs font-bold text-white/60 tracking-wide">学校・家庭学習向けの英語タイピング練習（教材）サイトです。広告はありません。授業や家庭での反復練習を目的としています。</div>

              <div class="mt-6">
                <div class="text-[52px] sm:text-[56px] leading-[0.95] font-extrabold italic tracking-tight">
                  <div class="text-white">DRAKICHI</div>
                  <div class="bg-gradient-to-r from-sky-400 via-blue-500 to-indigo-500 text-transparent bg-clip-text">TYPING</div>
                </div>
              </div>
            </div>

            <!-- No data alert -->
            <div id="no-data-alert"
                 class="hidden flex-col items-start justify-center bg-orange-500/10 border border-orange-400/20 text-orange-100 px-5 py-4 rounded-2xl shadow-sm">
              <p class="font-extrabold text-base mb-1"><i class="fas fa-exclamation-triangle mr-2"></i>データがありません</p>
              <p class="text-xs opacity-90">右上の「CSV Import」から学習データ(CSV)を読み込んでください。</p>
            </div>

            <!-- Select grade -->
            <div>
              <div class="flex items-center gap-3 text-[11px] tracking-[0.25em] text-white/60 font-bold">
                <i class="fas fa-layer-group text-white/35"></i>
                <span>SELECT GRADE</span>
                <span class="flex-1 h-px bg-white/10"></span>
              </div>

              <div id="grade-buttons" class="mt-4 grid grid-cols-2 md:grid-cols-4 gap-3">
                <button onclick="selectGrade('1')"
                        class="h-24 rounded-2xl bg-white/5 hover:bg-white/10 active:scale-[0.99] transition border border-white/10 shadow-sm flex flex-col items-center justify-center gap-1">
                  <div class="text-3xl font-extrabold">1</div>
                  <div class="text-[10px] tracking-[0.25em] text-white/60 font-bold">GRADE</div>
                </button>

                <button onclick="selectGrade('2')"
                        class="h-24 rounded-2xl bg-white/5 hover:bg-white/10 active:scale-[0.99] transition border border-white/10 shadow-sm flex flex-col items-center justify-center gap-1">
                  <div class="text-3xl font-extrabold">2</div>
                  <div class="text-[10px] tracking-[0.25em] text-white/60 font-bold">GRADE</div>
                </button>

                <button onclick="selectGrade('3')"
                        class="h-24 rounded-2xl bg-white/5 hover:bg-white/10 active:scale-[0.99] transition border border-white/10 shadow-sm flex flex-col items-center justify-center gap-1">
                  <div class="text-3xl font-extrabold">3</div>
                  <div class="text-[10px] tracking-[0.25em] text-white/60 font-bold">GRADE</div>
                </button>

                <button onclick="selectGrade('custom')"
                        class="h-24 rounded-2xl bg-white/5 hover:bg-white/10 active:scale-[0.99] transition border border-white/10 shadow-sm flex flex-col items-center justify-center gap-1">
                  <div class="text-2xl font-extrabold"><i class="fas fa-star"></i></div>
                  <div class="text-[10px] tracking-[0.25em] text-white/60 font-bold">CUSTOM</div>
                </button>
              </div>

              <div class="mt-4 text-left select-none">
                <p class="text-[11px] text-white/70 font-mono">
                  Total Words Loaded: <span id="total-words-count" class="font-extrabold text-white text-base">0</span>
                </p>
              </div>
            </div>

            <!-- Grammar Legend (keep the wording as-is) -->
            <div class="bg-white/5 border border-white/10 rounded-2xl p-4 shadow-sm text-xs text-white/80 leading-relaxed">
              <div class="font-extrabold mb-2 flex items-center gap-2 text-white text-sm">
                <i class="fas fa-palette text-sky-300"></i> 文の構成要素の色分けについて
              </div>
              <p class="mb-3">この英語タイピング練習では、英文の文の構成要素に合わせて色分け表示できます。</p>
              <div class="flex flex-col gap-1.5 font-bold text-[10px] items-start">
                <span class="text-red-300 bg-red-500/10 px-2 py-1 rounded border border-red-500/15">S主語 赤</span>
                <span class="text-amber-200 bg-amber-500/10 px-2 py-1 rounded border border-amber-500/15">V 述語 黄色</span>
                <span class="text-blue-200 bg-blue-500/10 px-2 py-1 rounded border border-blue-500/15">O又は第4文型のO1（誰に） 目的語 青</span>
                <span class="text-sky-200 bg-sky-500/10 px-2 py-1 rounded border border-sky-500/15">第4文型のO2(何を） 水色</span>
                <span class="text-green-200 bg-green-500/10 px-2 py-1 rounded border border-green-500/15">C 補語 緑</span>
                <span class="text-white/85 bg-white/10 px-2 py-1 rounded border border-white/10">M 修飾語 黒</span>
                <span class="self-center text-white/60 font-normal">です。</span>
              </div>
            </div>

            <!-- Latest Update -->
            <div class="bg-white/5 border border-white/10 rounded-2xl p-4 text-xs text-white/70 leading-relaxed">
              <div class="font-extrabold mb-1 flex items-center gap-2 text-white/90">
                <i class="fas fa-bullhorn text-sky-300"></i> Latest Update
              </div>
              <p>2026.2.4: 音読モードというのを作ってみました。マイクを使って音読をすると、文字が入力されます。ちゃんと言えてるはずなのに変な入力になってしまうことも多かったので、入力される文字は参考にしてください。音声で文字を表示した後、自分で判断して（できた）（わからない）　を決定するシステムにしました。</p>
              <p>2026.2.4: コピペで作成機能を作りました。文はピリオド、クエスチョン、エクスクラメーションマークで区切って1問作ります。単語は単語を貼ると品詞を指定すれば、その品詞の意味で入ります。品詞を指定しなければその単語がもつ適当な品詞と意味で登録されます。</p>
              <p>2026.1.24: ①タイトルのBGMが選べるようになりました。②やさしいのでタイピングが遅すぎる人が全然進まなくならないようにやさしめ判定を導入しました。それに甘えず速くなるようにがんばりましょう。③スマホの縦画面でも操作しやすいように調整しました（外付けキーボードが無い場合は内蔵キーボードが自動で出ます）。</p>
              <p>2026.1.22: 出題順を「ランダム / 登録順」から選べるようにしました（暗唱文・ストーリーを順番に練習できます）。</p>
              <p>2026.1.15 1年生英単語＆本文ガチマスターの修正をしました。もう一度ダウンロードしてそのままインポートしてください。</p>
            </div>

            <!-- Extra Modes Container -->
            <div class="flex flex-wrap justify-center gap-3 w-full">
              <!-- Touch Typing -->
              <a href="https://drakichityping.shop/sub/index2.html" target="_blank" rel="noopener"
                 class="flex-1 min-w-[200px] bg-indigo-600/90 hover:bg-indigo-500 text-white font-bold py-3 px-5 rounded-xl shadow-lg transition transform hover:scale-105 flex items-center justify-center gap-3 border border-white/30 backdrop-blur-sm group">
                <div class="bg-white/20 p-1.5 rounded-lg group-hover:bg-white/30 transition"><i class="fas fa-keyboard text-lg"></i></div>
                <div class="flex flex-col items-start">
                  <span class="text-[10px] opacity-80 uppercase tracking-widest">Training</span>
                  <span class="text-sm">タッチタイピング特訓</span>
                </div>
                <i class="fas fa-chevron-right text-[10px] opacity-50 ml-auto"></i>
              </a>

              <!-- Grammar -->
              <a href="https://drakichityping.shop/Grammar_Typng_menu/index.html" target="_blank" rel="noopener"
                 class="flex-1 min-w-[200px] bg-fuchsia-600/90 hover:bg-fuchsia-500 text-white font-bold py-3 px-5 rounded-xl shadow-lg transition transform hover:scale-105 flex items-center justify-center gap-3 border border-white/30 backdrop-blur-sm group">
                <div class="bg-white/20 p-1.5 rounded-lg group-hover:bg-white/30 transition"><i class="fas fa-spell-check text-lg"></i></div>
                <div class="flex flex-col items-start">
                  <span class="text-[10px] opacity-80 uppercase tracking-widest">Grammar</span>
                  <span class="text-sm">Grammar Typing</span>
                </div>
                <i class="fas fa-chevron-right text-[10px] opacity-50 ml-auto"></i>
              </a>

              <!-- Phonics -->
              <a href="https://drakichityping.shop/DrakichiPhonics/DrakichiPhonicsGamesMenu.html" target="_blank" rel="noopener"
                 class="flex-1 min-w-[200px] bg-emerald-600/90 hover:bg-emerald-500 text-white font-bold py-3 px-5 rounded-xl shadow-lg transition transform hover:scale-105 flex items-center justify-center gap-3 border border-white/30 backdrop-blur-sm group">
                <div class="bg-white/20 p-1.5 rounded-lg group-hover:bg-white/30 transition"><i class="fas fa-ear-listen text-lg"></i></div>
                <div class="flex flex-col items-start">
                  <span class="text-[10px] opacity-80 uppercase tracking-widest">Phonics</span>
                  <span class="text-sm">Phonics Games</span>
                </div>
                <i class="fas fa-chevron-right text-[10px] opacity-50 ml-auto"></i>
              </a>
            </div>
          </aside>

          <!-- Divider -->
          <div class="hidden md:block w-[2px] bg-white/10"></div>

          <!-- RIGHT: Hero image -->
          <section class="relative flex-1 min-h-[280px] md:min-h-0">
            <div class="absolute inset-0"
                 style="background-image:url('title_bg.jpg'); background-size:cover; background-position:center; background-repeat:no-repeat;"></div>
            <!-- vignette + left fade -->
            <div class="absolute inset-0 bg-gradient-to-r from-[#0b1320] via-[#0b1320]/35 to-transparent"></div>
            <div class="absolute inset-0 bg-gradient-to-t from-black/25 via-black/0 to-black/0"></div>
          </section>
        </div>
      </div>

      <!-- 1.5) CSV Room -->
      <div id="screen-csvroom" class="screen w-full h-full hidden anim-fade-in relative overflow-hidden">
        <!-- Background (reuse title image) -->
        <div class="absolute inset-0"
             style="background-image:url('title_bg.jpg'); background-size:cover; background-position:center; background-repeat:no-repeat; filter:blur(0px);"></div>
        <div class="absolute inset-0 bg-black/45"></div>

        <div class="relative z-10 w-full h-full flex flex-col items-center p-6 min-h-0">
          <div class="w-full max-w-5xl mb-5 flex items-end justify-between border-b-2 border-white/30 pb-4 px-2">
            <div>
              <span class="text-xs text-white/80 font-bold uppercase block mb-1 tracking-wider">CSV Library</span>
              <h2 class="text-3xl font-extrabold text-white drop-shadow">
                <i class="fas fa-box-archive mr-2 text-sky-200"></i>CSV置き場
              </h2>
              <p class="mt-2 text-sm text-white/80 leading-relaxed">
                配布用のCSVをここに並べられます（※ブラウザの仕様で<strong>サーバー上のフォルダを自動で一覧取得はできない</strong>ので、<span class="font-bold">csv_library.json</span>（一覧ファイル）を用意して読み込みます）。
              </p>
            </div>

            <div class="flex flex-wrap items-center gap-2">
              <button onclick="exportAllWordsCsv()"
                      class="bg-white/90 hover:bg-white text-slate-700 px-4 py-2 rounded-xl text-sm font-extrabold shadow-sm border border-white/40 active:scale-[0.99]">
                <i class="fas fa-download mr-1"></i> いまのデータを書き出し
              </button>
            </div>
          </div>

          <div class="w-full max-w-5xl flex-1 min-h-0 overflow-y-auto scroll-touch pb-24 px-2">
            <div class="mb-3 text-xs text-white/80">
              <span id="csv-room-status" class="font-bold">—</span>
              <span class="ml-2">（※ csv_library.json が無い場合は、このHTML内のサンプル一覧を表示します）</span>
            </div>

            <div id="csv-room-list" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>

            <div class="mt-6 bg-white/10 border border-white/20 rounded-2xl p-4 text-white/80 text-xs leading-relaxed">
              <div class="font-extrabold text-white mb-2"><i class="fas fa-wrench mr-1"></i>一覧ファイルの作り方（例）</div>
              <pre class="whitespace-pre-wrap bg-black/30 rounded-xl p-3 overflow-x-auto text-[11px]">{
  "items": [
    {"name":"Grade2 Unit5","url":"csv/grade2_u5.csv","desc":"2年 Unit5（Universal Design）"},
    {"name":"Grade3 Unit1","url":"csv/grade3_u1.csv","desc":"3年 Unit1"}
  ]
}</pre>
              <div class="mt-2">CSVファイルと <span class="font-bold">csv_library.json</span> を、このHTMLと同じ場所（または同一サイト内）に置けばOKです。</div>
            </div>
          </div>
        </div>
      </div>


            <!-- 2) Section -->
      <div id="screen-section"
           class="screen w-full h-full hidden anim-fade-in relative overflow-hidden">

        <!-- Background image -->
        <div class="absolute inset-0"
             style="background-image:url('Sectionchoice_bg.jpg'); background-size:cover; background-position:center; background-repeat:no-repeat;">
        </div>

        <!-- Subtle overlay for readability -->
        <div class="absolute inset-0 bg-black/35"></div>

        <!-- Content -->
        <div class="relative z-10 w-full h-full flex flex-col items-center p-6 min-h-0">
          <div class="w-full max-w-5xl mb-6 flex items-end justify-between border-b-2 border-white/30 pb-4 px-2">
            <div>
              <span class="text-xs text-white/80 font-bold uppercase block mb-1 tracking-wider">Select Section</span>
              <h2 class="text-3xl font-bold text-white drop-shadow">
                <i class="fas fa-folder-open mr-2 text-sky-300"></i><span id="selected-grade-label">Grade 1</span>
              </h2>
            </div>
          </div>

          <div id="section-list-container"
               class="w-full max-w-5xl grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 flex-1 min-h-0 overflow-y-auto scroll-touch pb-20 px-2 content-start pr-2">
          </div>
        </div>
      </div>

<!-- 3) Settings -->
      <div id="screen-settings" class="screen w-full h-full relative overflow-x-hidden flex flex-col items-center justify-start p-6 hidden anim-fade-in screen-scroll">
          <!-- Background -->
        <div class="absolute inset-0" style="background-image:url('Background3.jpg'),url('Backgroud3.jpg'); background-size:cover; background-position:center; background-repeat:no-repeat;"></div>
        <div class="absolute inset-0 bg-white/35"></div>

        <div class="relative z-10 bg-white p-10 rounded-[2rem] shadow-xl border border-slate-100 w-full max-w-3xl text-center relative">

          <span class="text-xs font-bold text-gray-400 uppercase tracking-widest mb-2 block">Target Section</span>
          <h2 id="selected-section-label"
              class="text-3xl font-bold text-slate-700 mb-8 border-b-4 border-sky-100 inline-block px-8 pb-2">Unit 1-1</h2>

          <div class="space-y-8 text-left max-w-2xl mx-auto">

            <!-- Mode -->
            <div>
              <label class="block text-xs font-bold text-gray-400 mb-3 uppercase tracking-wider">
                <i class="fas fa-graduation-cap mr-1"></i> 学習モード
              </label>

              <!-- ここ：枠に収まるように高さと文字サイズを調整 -->
              <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                <button onclick="selectMode('normal')" id="btn-mode-normal"
                        class="mode-btn p-4 rounded-xl border-2 border-sky-500 bg-sky-50 text-sky-700 font-bold text-center transition ring-2 ring-sky-500 ring-offset-2 hover:shadow-md">
                  <div class="text-lg sm:text-xl mb-1 whitespace-nowrap"><i class="fas fa-book"></i> Normal</div>
                  <div class="text-[10px] font-normal opacity-80 whitespace-nowrap">英語・意味・音声</div>
                </button>

                <button onclick="selectMode('hard')" id="btn-mode-hard"
                        class="mode-btn p-4 rounded-xl border-2 border-orange-400 hover:bg-orange-50 text-gray-600 hover:text-orange-600 font-bold text-center transition hover:shadow-md">
                  <div class="text-lg sm:text-xl mb-1 whitespace-nowrap"><i class="fas fa-headphones"></i> Hard</div>
                  <div class="text-[10px] font-normal opacity-80 whitespace-nowrap">英語隠し・音声あり</div>
                </button>

                <button onclick="selectMode('extra')" id="btn-mode-extra"
                        class="mode-btn p-4 rounded-xl border-2 border-rose-500 hover:bg-rose-50 text-gray-600 hover:text-rose-600 font-bold text-center transition hover:shadow-md">
                  <div class="text-lg sm:text-xl mb-1 whitespace-nowrap"><i class="fas fa-bullseye"></i> Ex-Hard</div>
                  <div class="text-[10px] font-normal opacity-80 whitespace-nowrap">意味のみ・音声なし</div>
                </button>
              </div>
            </div>

            <!-- Question Order -->
            <div class="bg-white p-6 rounded-2xl border border-slate-100">
              <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">
                <i class="fas fa-random mr-1"></i> 出題順
              </label>
              <div class="flex flex-col gap-2">
                <div class="flex flex-wrap items-center gap-3">
                  <select id="question-order"
                          class="text-sm px-3 py-2 rounded-xl border border-slate-200 bg-white focus:outline-none focus:ring-2 focus:ring-sky-300">
                    <option value="random">ランダム</option>
                    <option value="registered">登録順</option>
                  </select>
                  <div class="text-xs text-slate-500">暗唱文・ストーリーを順番に練習したいときは「登録順」</div>
                </div>
                <div class="text-[11px] text-slate-400 leading-relaxed">
                  ※途中経過（続きから再開）がある場合は、前回の順番が優先されます。順番を変えたい場合は「途中経過の削除」をしてください。
                </div>
              </div>
            </div>

            <!-- Time -->
            <div class="bg-slate-50 p-6 rounded-2xl border border-slate-100">
              <div class="flex justify-between items-center mb-4">
                <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">
                  <i class="fas fa-stopwatch mr-1"></i> Time Limit
                </label>
                <span id="time-val-display" class="text-3xl font-bold text-sky-600 font-mono">1 <span class="text-sm">min</span></span>
              </div>
              <input type="range" id="time-slider" min="1" max="10" value="1"
                     class="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-sky-600 hover:accent-sky-500">
              <div class="flex justify-between text-xs text-gray-400 mt-2 font-mono">
                <span>1 min</span><span>5 min</span><span>10 min</span>
              </div>
            </div>

            <!-- Sound -->
            <div class="bg-white p-6 rounded-2xl border border-slate-100">
              <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">
                <i class="fas fa-volume-high mr-1"></i> Sound
              </label>

              <div class="flex flex-col gap-2 mb-2">
                <div class="flex flex-wrap gap-4">
                  <label class="flex items-center gap-2 text-sm font-bold text-slate-600">
                    <input id="sfx-type-toggle" type="checkbox" class="accent-sky-600" checked>
                    タイプ音
                  </label>
                  <label class="flex items-center gap-2 text-sm font-bold text-slate-600">
                    <input id="sfx-coin-toggle" type="checkbox" class="accent-sky-600" checked>
                    正解/不正解音
                  </label>
                  <label class="flex items-center gap-2 text-sm font-bold text-slate-600">
                    <input id="sfx-clear-toggle" type="checkbox" class="accent-sky-600" checked>
                    クリア音
                  </label>
                </div>
                <div class="mt-2 p-3 bg-blue-50 border border-blue-200 text-blue-800 rounded-lg text-xs font-bold leading-relaxed">
                  <i class="fas fa-info-circle mr-1"></i>
                  タイプ音や正解/不正解音を流すと処理がもたつくためWPMを伸ばしたいなと思うときは、切って取り組むことをおすすめします。
                </div>
                <div class="text-xs text-slate-400">
                  ※英語音声は常にON（Extraは仕様上OFF）
                </div>
              </div>
              <div class="mt-5 flex flex-col gap-2">
                <div class="flex flex-wrap items-center gap-3">
                  <span class="text-sm font-bold text-slate-600">
                    <i class="fas fa-microphone mr-1 text-slate-400"></i> 英語音声
                  </span>
                  <select id="voice-profile"
                          class="text-sm px-3 py-2 rounded-xl border border-slate-200 bg-white focus:outline-none focus:ring-2 focus:ring-sky-300">
                    <option value="us_male">US（男性）</option>
                    <option value="us_female">US（女性）</option>
                    <option value="uk_male">UK（男性）</option>
                    <option value="uk_female">UK（女性）</option>
                  </select>

                  <button id="voice-test-btn" type="button"
                          class="text-sm px-4 py-2 rounded-xl bg-sky-600 text-white font-bold hover:bg-sky-500 active:scale-[0.99]">
                    TEST
                  </button>
                </div>

                <div id="voice-status" class="text-xs text-slate-500"></div>
                <div class="text-xs text-slate-400 leading-relaxed">
                  ※iPhone/iPad は iOS の英語音声（例：Samantha / Daniel）を優先して選びます。<br>
                  端末に英語音声が入っていない場合は、iOS設定でEnglish音声の追加が必要です。
                </div>
              </div>

            </div>

            
            <!-- Reading Mode -->
            <div class="bg-white p-6 rounded-2xl border border-slate-100">
              <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">
                <i class="fas fa-microphone mr-2"></i>音読モード（試験）
              </label>

              <label class="flex items-start gap-3 text-sm font-bold text-slate-600">
                <input id="reading-mode-toggle" type="checkbox" class="mt-1 accent-emerald-600" />
                <span>
                  音読モードをON（タイピングの代わりにマイクで答える）
                  <span id="reading-mode-note" class="hidden block mt-1 text-[11px] font-bold text-emerald-700">※音読モードも Normal / Hard / Ex-Hard 対応</span>
                </span>
              </label>

              <div class="mt-3 text-xs text-slate-400 leading-relaxed">
                Web Speech API（ブラウザの音声認識）で<strong>話した内容</strong>を文字起こしし、正解文と照合して判定します。<br>
                ※発音を厳密に採点する機能ではありません（将来的に外部APIで拡張可能）。<br>
                ※Chrome推奨／Safari・iPadは非対応・不安定な場合があります。<br>
                ※HTTPS(SSL) または localhost でのみ動作します。
              </div>
            </div>

<!-- Resume note -->
            <div id="resume-hint" class="hidden bg-amber-50 border border-amber-200 text-amber-800 p-4 rounded-xl text-sm">
              <i class="fas fa-rotate-right mr-2"></i>
              前回の続きがあります。「学習開始」で続きから再開します。
            </div>

            <!-- SRS -->
            <div class="bg-white p-6 rounded-2xl border border-slate-100">
              <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">
                <i class="fas fa-brain mr-1"></i> SRS（Anki風）
              </label>
              <div class="flex flex-col gap-2">
                <label class="flex items-center gap-2 text-sm font-bold text-slate-600">
                  <input id="srs-review-toggle" type="checkbox" class="accent-sky-600">
                  復習モード（期限の問題だけ）
                </label>
                <div id="srs-info" class="text-xs text-slate-500 leading-relaxed">
                  期限の復習カード：<span id="srs-due-count" class="font-mono font-bold text-sky-600">0</span>　
                  /　このセクションの登録数：<span id="srs-total-count" class="font-mono font-bold text-slate-700">0</span><br>
                  自動採点：ミス=Again／詰まり(1.2s停止)または遅い=Hard（HardはGoodの<strong>0.6倍</strong>の間隔で復習）
                </div>
              </div>
            </div>
          </div>
          <div class="sticky bottom-0 left-0 w-full pt-4 pb-4 bg-white/85 backdrop-blur border-t border-slate-100 flex justify-center">
            <button onclick="startSession()"
                    class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-4 px-16 rounded-full shadow-xl transform transition hover:scale-105 active:scale-95 text-xl tracking-wider flex items-center gap-3">
              <i class="fas fa-pen-to-square"></i> 学習開始
            </button>
          </div>
        </div>
      </div>

      <!-- 4) Practice -->
      <div id="screen-practice" class="screen w-full h-full flex flex-col items-center justify-center p-6 hidden relative cursor-text">
        <div class="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-20">
          <div class="flex flex-col bg-white/90 backdrop-blur px-5 py-3 rounded-2xl shadow-sm border border-slate-100">
            <span class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Mastered</span>
            <span id="practice-score" class="text-4xl font-bold text-sky-600 font-mono leading-none">0</span>
          </div>

          <div class="flex flex-row flex-wrap items-center justify-center mt-2 gap-2">
            <span id="practice-mode-badge"
                  class="px-4 py-1 bg-white border border-slate-200 text-gray-500 rounded-full text-xs font-bold shadow-sm whitespace-nowrap">
              NORMAL
            </span>
            <span id="practice-wpm-badge"
                  class="px-4 py-1 bg-white border border-slate-200 text-slate-600 rounded-full text-xs font-bold shadow-sm whitespace-nowrap">
              WPM: 0
            </span>
            <span id="practice-reading-badge"
                  class="px-4 py-1 bg-emerald-50 border border-emerald-200 text-emerald-700 rounded-full text-xs font-bold shadow-sm whitespace-nowrap hidden">
              READ: 0
            </span>
            <span id="practice-judge-badge"
                  class="px-4 py-1 bg-white border border-slate-200 text-slate-600 rounded-full text-xs font-bold shadow-sm whitespace-nowrap"
                  title="判定の基準：基本は『5文字につき4秒』。端末ごとの過去データにより、必要な場合は自動で少しゆるめます。">
              判定: 標準
            </span>
          </div>

          <div class="flex flex-col items-end bg-white/90 backdrop-blur px-5 py-3 rounded-2xl shadow-sm border border-slate-100">
            <span class="text-[10px] text-gray-400 font-bold uppercase tracking-wider">Time Left</span>
            <span id="practice-timer" class="text-4xl font-bold text-slate-700 font-mono leading-none">1:00</span>
          </div>
        </div>

        <div id="practice-main" class="w-full max-w-5xl text-center mt-8 px-4 pb-44">
          <div class="min-h-[5rem] flex items-center justify-center mb-8">
            <div class="relative bg-white border-b-4 border-slate-200 px-12 py-8 rounded-3xl shadow-sm inline-block max-w-full">
              <span id="pos-display"
                    class="absolute -top-3 left-6 text-xs font-bold bg-sky-100 text-sky-600 px-3 py-1 rounded-full border border-sky-200 shadow-sm hidden">
                [名]
              </span>
              <span id="meaning-display" class="text-lg sm:text-xl md:text-2xl font-bold text-slate-700 leading-snug break-words">Ready?</span>
            </div>
          </div>

          <div id="practice-word-row" class="relative min-h-[8rem] flex items-center justify-center mb-4 px-4">
            <button id="replay-voice-btn"
                    class="absolute left-0 top-1/2 -translate-y-1/2 text-slate-300 hover:text-sky-500 p-4 transition bg-white rounded-full shadow-sm border border-slate-100 hover:border-sky-100 group z-30">
              <i class="fas fa-volume-up text-2xl group-hover:scale-110 transition"></i>
            </button>

            <div id="word-display"
                 class="font-mono text-5xl sm:text-6xl tracking-widest flex flex-wrap justify-center items-end px-12 leading-normal text-slate-800 break-words w-full">
            </div>
          </div>

          <!-- Speech / Reading Mode panel -->
          <div id="speech-panel" class="hidden w-full max-w-3xl mx-auto mt-6">
            <div class="bg-white/90 backdrop-blur border border-slate-100 rounded-2xl shadow-sm p-4">
              <div class="flex items-center justify-between gap-3 flex-wrap">
                <div class="flex items-center gap-2">
                  <span class="text-[10px] font-extrabold tracking-widest text-emerald-600 bg-emerald-50 border border-emerald-100 px-2 py-1 rounded-full">SPEECH</span>
                  <span id="speech-status" class="text-sm font-bold text-slate-700">「音読」→ できた / わからない</span>
                </div>
                <div id="speech-score" class="text-xs font-bold text-slate-500"></div>
              </div>
              <div id="speech-transcript" class="mt-3 text-sm text-slate-700 break-words"></div>
              <div id="answer-peek-wrap" class="hidden mt-3">
                <div class="flex items-center justify-between gap-2">
                  <div class="text-[11px] font-bold text-slate-500">答え（確認用）</div>
                  <button id="answer-peek-toggle" class="text-xs font-extrabold text-sky-700 hover:text-sky-800 px-3 py-1 rounded-full bg-sky-50 border border-sky-100">答え表示</button>
                </div>
                <div id="answer-peek-text" class="mt-2 text-sm font-mono text-slate-700 bg-slate-50 border border-slate-100 rounded-xl p-3 break-words hidden"></div>
              </div>
              <div class="mt-2 text-[11px] text-slate-400 leading-relaxed">
                ※文字起こしは「参考表示」です。判定は「できた / わからない」の自己申告（スピード不問）です。
              </div>
            </div>
          </div>

          <div id="next-hint"
               class="absolute left-1/2 -translate-x-1/2 bottom-44 z-40 h-8 text-sky-400 text-sm font-mono transition-opacity opacity-0 font-bold flex items-center justify-center gap-2 pointer-events-none">
            <span class="text-[10px] uppercase bg-sky-50 px-2 py-0.5 rounded text-sky-300">Next</span>
            <span id="next-word-text" class="text-slate-400 font-normal max-w-[80vw] truncate">...</span>
          </div>
        </div>

        
        <!-- Bottom controls -->
        <div id="practice-bottom-controls" class="absolute bottom-24 left-1/2 -translate-x-1/2 z-30 flex items-center justify-center gap-3 flex-wrap">
          
          <button id="speech-mic-btn" class="hidden bg-emerald-600 hover:bg-emerald-700 text-white font-bold px-6 py-4 rounded-2xl shadow-lg flex items-center gap-3" aria-label="reading mode mic">
            <i id="speech-mic-icon" class="fas fa-microphone text-2xl"></i>
            <span id="speech-mic-label" class="text-base sm:text-lg">音読</span>
          </button>

          <button id="reading-ok-btn"
                  class="hidden bg-emerald-600 hover:bg-emerald-700 text-white font-extrabold px-8 py-4 rounded-full shadow-xl transition active:scale-95 flex items-center gap-3"
                  title="できた（OK扱い・次へ）">
            <i class="fas fa-circle-check text-2xl"></i>
            <span class="text-base sm:text-lg">できた</span>
          </button>

          <button id="dont-know-btn"
                  class="bg-rose-600 hover:bg-rose-700 text-white font-extrabold px-8 py-4 rounded-full shadow-xl transition active:scale-95 flex items-center gap-3"
                  title="わからない（MISS扱い・答え表示）">
            <i class="fas fa-circle-question text-2xl"></i>
            <span class="text-base sm:text-lg">わからない</span>
          </button>
        </div>

<input type="text" id="practice-input" class="absolute inset-0 w-full h-full opacity-0 cursor-text z-0 pointer-events-none" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" inputmode="latin" enterkeyhint="done" aria-label="typing input" placeholder="">

        <div id="feedback-msg" class="absolute bottom-12 text-rose-500 font-bold h-6 text-lg animate-bounce"></div>
      </div>

      <!-- 5) Result -->
      <div id="screen-result" class="screen w-full h-full flex flex-col items-center justify-center p-8 hidden anim-fade-in">
        <div id="result-card"
             class="bg-white p-12 rounded-[3rem] shadow-2xl border border-slate-100 w-full max-w-2xl text-center relative">
          <div id="result-topbar" class="absolute top-0 left-0 w-full h-3 bg-gradient-to-r from-sky-400 to-indigo-400"></div>

          <h2 id="result-title" class="text-6xl font-bold text-slate-800 mb-2 mt-4">FINISH!</h2>
          <p id="result-msg" class="text-sky-600 font-bold mb-10 text-xl">Good Job!</p>

          <div class="grid grid-cols-2 gap-6 w-full mb-12">
            <div class="bg-sky-50 p-6 rounded-3xl text-center border border-sky-100">
              <div class="text-xs text-sky-400 uppercase font-bold mb-2 tracking-widest">Mastered</div>
              <div id="res-score" class="text-6xl font-mono font-bold text-sky-600">0</div>
            </div>
            <div class="bg-slate-50 p-6 rounded-3xl text-center border border-slate-200">
              <div class="text-xs text-slate-400 uppercase font-bold mb-2 tracking-widest">WPM</div>
              <div id="res-wpm" class="text-6xl font-mono font-bold text-slate-600">0</div>
              <div id="res-wpm-note" class="text-xs text-slate-400 mt-2">（正味WPM：正解キーのみ / 5文字=1語 / 実測時間）</div>
            </div>
            <div id="res-reading-card" class="bg-emerald-50 p-6 rounded-3xl text-center border border-emerald-100 col-span-2 hidden">
              <div class="text-xs text-emerald-500 uppercase font-bold mb-2 tracking-widest">Reading</div>
              <div id="res-reading" class="text-4xl sm:text-5xl font-mono font-bold text-emerald-700">—</div>
              <div id="res-reading-note" class="text-xs text-emerald-700/70 mt-2">Avg: —</div>
            </div>
          </div>

          <div class="flex gap-4 justify-center">
            <button onclick="goToScreen('settings')"
                    class="bg-slate-100 hover:bg-slate-200 text-slate-600 font-bold py-4 px-8 rounded-2xl transition flex-1 max-w-[200px]">
              Retry
            </button>
            <button onclick="goToScreen('section')"
                    class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-4 px-8 rounded-2xl shadow-lg transition flex-1 max-w-[200px]">
              Next Section
            </button>
          </div>
        </div>
      </div>

      <!-- 6) Stats -->
      <div id="screen-stats" class="screen w-full h-full flex flex-col hidden anim-fade-in bg-slate-50 min-h-0">
        <div id="stats-scroll" class="w-full h-auto scroll-touch flex flex-col items-center p-8" style="touch-action: pan-y;">
        <h2 class="text-3xl font-bold text-slate-700 mb-4 flex items-center gap-3">
          <div class="bg-white p-2 rounded-lg shadow-sm text-sky-500"><i class="fas fa-chart-line"></i></div>
          Learning Statistics
        </h2>


        <!-- View Toggle -->
        <div class="w-full max-w-6xl flex items-center justify-center mb-5">
          <div class="bg-white border border-slate-200 rounded-2xl p-1 shadow-sm flex gap-1">
            <button id="stats-tab-wpm" class="px-5 py-2 rounded-xl text-sm font-extrabold transition">WPM</button>
            <button id="stats-tab-srs" class="px-5 py-2 rounded-xl text-sm font-extrabold transition">SRS</button>
          </div>
        </div>

        
        <!-- SRS Mode Toggle (Normal / Hard / Ex-Hard) -->
        <div data-stats-group="srs" class="w-full max-w-6xl flex items-center justify-center mb-4 hidden">
          <div class="bg-white border border-slate-200 rounded-2xl p-1 shadow-sm flex gap-1">
            <button id="srs-mode-normal" class="px-4 py-2 rounded-xl text-sm font-extrabold transition">Normal</button>
            <button id="srs-mode-hard" class="px-4 py-2 rounded-xl text-sm font-extrabold transition">Hard</button>
            <button id="srs-mode-extra" class="px-4 py-2 rounded-xl text-sm font-extrabold transition">Ex-Hard</button>
          </div>
        
        <!-- SRS Deck Toggle (Typing SRS / Reading SRS) -->
        <div data-stats-group="srs" class="w-full max-w-6xl flex items-center justify-center mb-4 hidden">
          <div class="bg-white border border-slate-200 rounded-2xl p-1 shadow-sm flex gap-1">
            <button id="srs-deck-typing" class="px-4 py-2 rounded-xl text-sm font-extrabold transition">Typing SRS</button>
            <button id="srs-deck-reading" class="px-4 py-2 rounded-xl text-sm font-extrabold transition">Reading SRS</button>
          </div>
        </div>

</div>

<!-- Summary Cards -->
        <div data-stats-group="wpm" class="w-full max-w-6xl grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
          <div class="bg-white rounded-2xl border border-slate-200 shadow-sm p-4">
            <div class="text-xs uppercase tracking-wider text-slate-400 font-bold">今週の平均 WPM</div>
            <div id="sum-week-avg" class="text-3xl font-mono font-bold text-sky-600 mt-1">-</div>
            <div class="text-xs text-slate-400 mt-1">直近7日</div>
          </div>

          <div class="bg-white rounded-2xl border border-slate-200 shadow-sm p-4">
            <div class="text-xs uppercase tracking-wider text-slate-400 font-bold">最高 WPM</div>
            <div id="sum-best" class="text-3xl font-mono font-bold text-emerald-600 mt-1">-</div>
            <div id="sum-best-note" class="text-xs text-slate-400 mt-1">—</div>
          </div>

          <div class="bg-white rounded-2xl border border-slate-200 shadow-sm p-4">
            <div class="text-xs uppercase tracking-wider text-slate-400 font-bold">伸び率</div>
            <div id="sum-growth" class="text-3xl font-mono font-bold text-rose-600 mt-1">-</div>
            <div class="text-xs text-slate-400 mt-1">直近10回 vs その前10回</div>
          </div>
          <div class="bg-white rounded-2xl border border-slate-200 shadow-sm p-4 text-center">
            <div class="text-xs uppercase tracking-wider text-slate-400 font-bold mb-2">
              現在のスピード職
            </div>
            <img id="speed-job-img" class="mx-auto w-24 h-24" />
            <div id="speed-job-name" class="mt-2 text-sm font-semibold text-slate-700"></div>
            <div id="speed-job-next" class="mt-2 text-[10px] text-slate-400 bg-slate-50 rounded p-1 leading-tight whitespace-pre-wrap"></div>
          </div>
          <!-- SRS Job Card -->
          <div class="bg-white rounded-2xl border border-slate-200 shadow-sm p-4 text-center">
            <div class="text-xs uppercase tracking-wider text-slate-400 font-bold mb-2">
              語彙ジョブ（SRS）
            </div>
            <img id="srs-job-img" class="mx-auto w-24 h-24" alt="SRS Job">
            <div id="srs-job-name" class="mt-2 text-sm font-semibold text-slate-700"></div>
            <div id="srs-job-next" class="mt-2 text-[10px] text-slate-400 bg-slate-50 rounded p-1 leading-tight whitespace-pre-wrap"></div>
          </div>
          <!-- GodMaster Card -->
          <div id="godmaster-card" class="hidden bg-gradient-to-br from-yellow-200 to-yellow-400 rounded-2xl border border-yellow-300 shadow p-4 text-center">
            <div class="text-xs uppercase tracking-wider font-bold mb-2">特別称号</div>
            <img src="special_godmaster.png" class="mx-auto w-24 h-24">
            <div class="mt-2 text-sm font-extrabold">GOD MASTER</div>
          </div>
        </div>
        <!-- Answer Count (Anki-like) -->
        <div data-stats-group="srs" class="w-full max-w-6xl bg-white rounded-3xl shadow-sm border border-slate-200 overflow-hidden mb-5">
          <div class="p-4 bg-slate-50 border-b border-slate-200 flex flex-wrap items-center gap-3">
            <div class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i class="fas fa-layer-group text-emerald-500"></i> 回答カウント（Anki風） <span id="srs-deck-note" class="ml-2 text-[10px] font-extrabold text-slate-500">Typing SRS</span>
            </div>

            <select id="review-range" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="12">直近12か月</option>
              <option value="24" selected>直近24か月</option>
              <option value="36">直近36か月</option>
            </select>

            <label class="text-sm text-slate-600 flex items-center gap-2 ml-auto">
              <input id="review-lines-toggle" type="checkbox" class="accent-emerald-600" checked>
              累計線
            </label>
          </div>

          <div class="p-4">
            <canvas id="review-count-chart" class="w-full chart-canvas" style="height:260px;"></canvas>
            <div id="review-count-note" class="text-xs text-slate-400 mt-2"></div>
            <div id="review-count-summary" class="mt-3 text-sm text-slate-700"></div>
          </div>
        </div>


        <!-- Due Forecast (Anki-like) -->
        <div data-stats-group="srs" class="w-full max-w-6xl bg-white rounded-3xl shadow-sm border border-slate-200 overflow-hidden mb-5">
          <div class="p-4 bg-slate-50 border-b border-slate-200 flex flex-wrap items-center gap-3">
            <div class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i class="fas fa-calendar-day text-indigo-500"></i> 今後の期日（Due Forecast）
            </div>

            <select id="due-grade" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="all" selected>All grades</option>
            </select>

            <select id="due-days" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="14">14日</option>
              <option value="30" selected>30日</option>
              <option value="60">60日</option>
            </select>

            <label class="text-sm text-slate-600 flex items-center gap-2 ml-auto">
              <input id="due-overdue-toggle" type="checkbox" class="accent-indigo-600" checked>
              期限切れを「今日」に含める
            </label>
          </div>

          <div class="p-4">
            <canvas id="due-forecast-chart" class="w-full chart-canvas" style="height:220px;"></canvas>
            <div id="due-forecast-note" class="text-xs text-slate-400 mt-2"></div>
            <div id="due-forecast-summary" class="mt-3 text-sm text-slate-700"></div>
          </div>
        </div>

<div data-stats-group="srs" class="w-full max-w-6xl bg-white rounded-3xl shadow-sm border border-slate-200 overflow-hidden mb-5">
          <div class="p-4 bg-slate-50 border-b border-slate-200 flex flex-wrap items-center gap-3">
            <div class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i class="fas fa-chart-bar text-indigo-500"></i> FSRS Stats
            </div>
            <select id="fsrs-dist-grade" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white ml-auto"><option value="all">All Grades</option></select>
            <select id="fsrs-dist-mode" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="all">All Modes</option><option value="normal">Normal</option><option value="hard">Hard</option><option value="extra">Ex-Hard</option>
            </select>
          </div>
          <div class="p-6 grid grid-cols-1 md:grid-cols-3 gap-8">
            <div><div class="text-xs font-bold text-center text-slate-500 mb-2">Retrievability</div><canvas id="chart-retrievability" class="w-full h-32"></canvas></div>
            <div><div class="text-xs font-bold text-center text-slate-500 mb-2">Difficulty</div><canvas id="chart-difficulty" class="w-full h-32"></canvas></div>
            <div><div class="text-xs font-bold text-center text-slate-500 mb-2">Stability</div><canvas id="chart-stability" class="w-full h-32"></canvas></div>
          </div>
          <div id="fsrs-stats-summary" class="px-6 pb-4 text-xs text-slate-400 text-center"></div>
        </div>

        <div data-stats-group="srs" class="w-full max-w-6xl bg-white rounded-3xl shadow-sm border border-slate-200 overflow-hidden mb-5">
          <div class="p-4 bg-slate-50 border-b border-slate-200 flex flex-wrap items-center gap-3">
            <div class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2"><i class="fas fa-th text-emerald-500"></i> Review Heatmap</div>
            <div class="ml-auto flex gap-2">
                <select id="heatmap-grade" class="text-sm border border-slate-200 rounded-lg px-2 py-1 bg-white"><option value="all">All Grades</option></select>
                <select id="heatmap-mode" class="text-sm border border-slate-200 rounded-lg px-2 py-1 bg-white">
                    <option value="all">All Modes</option><option value="normal">Normal</option><option value="hard">Hard</option><option value="extra">Ex-Hard</option>
                </select>
            </div>
          </div>
          <div class="p-4 sm:p-6 overflow-x-auto">
            <div class="flex items-center gap-6 mb-4 px-2">
                <div><div class="text-[10px] text-slate-400 uppercase font-bold tracking-wider">Total</div><div id="hm-total" class="text-2xl font-mono font-bold text-slate-700">0</div></div>
                <div><div class="text-[10px] text-slate-400 uppercase font-bold tracking-wider">Streak</div><div id="hm-current-streak" class="text-2xl font-mono font-bold text-emerald-600">0</div></div>
                <div><div class="text-[10px] text-slate-400 uppercase font-bold tracking-wider">Longest</div><div id="hm-longest-streak" class="text-2xl font-mono font-bold text-slate-600">0</div></div>
            </div>
            <div class="min-w-[700px]">
                <div id="hm-months" class="flex text-[10px] text-slate-400 mb-1 pl-8"></div>
                <div class="flex gap-2">
                    <div class="flex flex-col justify-between text-[9px] text-slate-300 font-bold py-1 h-[100px] leading-none"><span>Mon</span><span></span><span>Wed</span><span></span><span>Fri</span><span></span><span></span></div>
                    <div id="hm-grid" class="grid grid-rows-7 grid-flow-col gap-[3px] h-[100px]"></div>
                </div>
            </div>
          </div>
        </div>

        <!-- WPM Chart -->
        <div data-stats-group="wpm" class="w-full max-w-6xl bg-white rounded-3xl shadow-sm border border-slate-200 overflow-hidden mb-5">
          <div class="p-4 bg-slate-50 border-b border-slate-200 flex flex-wrap items-center gap-3">
            <div class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i class="fas fa-chart-area text-sky-500"></i> WPM 推移（3モード同時）
            </div>

            <select id="chart-grade" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="">Grade</option>
            </select>

            <select id="chart-section" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="">Section</option>
            </select>

            <select id="chart-range" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="14">直近14日</option>
              <option value="30" selected>直近30日</option>
              <option value="90">直近90日</option>
              <option value="365">直近1年</option>
            </select>

            <label class="text-sm text-slate-600 flex items-center gap-2 ml-auto">
              <input id="chart-ma-toggle" type="checkbox" class="accent-sky-600" checked>
              移動平均
            </label>

            <select id="chart-ma-window" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
              <option value="3">MA 3</option>
              <option value="5" selected>MA 5</option>
              <option value="10">MA 10</option>
            </select>
          </div>

          <div class="p-4">
            <canvas id="wpm-chart" class="w-full chart-canvas" style="height:220px;"></canvas>
            <div id="wpm-chart-note" class="text-xs text-slate-400 mt-2"></div>
            <div id="wpm-best-by-mode" class="mt-3 text-sm text-slate-700"></div>
          </div>
        </div>

        <!-- WPM History -->
        <div data-stats-group="wpm" class="w-full max-w-6xl bg-white rounded-3xl shadow-sm border border-slate-200 overflow-hidden mb-5 flex flex-col">
          <div class="p-4 bg-slate-50 border-b border-slate-200 flex items-center gap-3">
            <div class="text-xs font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2">
              <i class="fas fa-list text-sky-500"></i> WPM 履歴（直近）
            </div>
            <div class="ml-auto flex items-center gap-2">
              <select id="wpm-hist-limit" class="text-sm border border-slate-200 rounded-lg px-3 py-2 bg-white">
                <option value="20">20件</option>
                <option value="50" selected>50件</option>
                <option value="100">100件</option>
              </select>
            </div>
          </div>

          <div class="overflow-y-auto max-h-[260px] scroll-touch">
            <table class="w-full text-sm">
              <thead class="sticky top-0 bg-white border-b border-slate-100">
                <tr class="text-xs font-bold text-slate-400 uppercase tracking-wider">
                  <th class="text-left p-3 pl-5 w-[7rem]">日付</th>
                  <th class="text-left p-3">セクション</th>
                  <th class="text-center p-3 w-[6rem]">モード</th>
                  <th class="text-right p-3 pr-5 w-[6rem]">WPM</th>
                </tr>
              </thead>
              <tbody id="wpm-history-body"></tbody>
            </table>
          </div>
        </div>


        <!-- Stats Table -->
        <div data-stats-group="wpm" class="w-full max-w-6xl bg-white rounded-3xl shadow-sm border border-slate-200 overflow-hidden flex flex-col flex-1 min-h-0">
          <div class="p-4 bg-slate-50 border-b border-slate-200 grid grid-cols-12 gap-2 text-xs font-bold text-slate-400 uppercase tracking-wider text-center">
            <div class="col-span-1 text-left pl-4">Grade</div>
            <div class="col-span-3 text-left">Section</div>
            <div class="col-span-8 grid grid-cols-3 gap-2">
              <div>Normal</div>
              <div>Hard</div>
              <div>Ex-Hard</div>
            </div>
          </div>

          <div id="stats-list-container" class="overflow-y-auto flex-1 min-h-0 p-0 bg-white scroll-touch"></div>
        </div>
        </div>
      </div>

    </main>
  </div>


  <!-- Manual / Help (PDF) Modal -->
  <div id="manual-modal" class="fixed inset-0 z-[9999] hidden items-center justify-center p-4">
    <div class="absolute inset-0 bg-black/60" onclick="closeManual()"></div>

    <div class="relative bg-white w-full max-w-5xl h-[88svh] rounded-3xl shadow-2xl overflow-hidden border border-slate-200 flex flex-col">
      <div class="flex items-center justify-between p-4 bg-slate-50 border-b border-slate-200">
        <div class="font-bold text-slate-700 flex items-center gap-2">
          <i class="fas fa-book"></i> <span class="ctrl-text">説明書</span>
        </div>
        <button onclick="closeManual()"
                class="px-3 py-2 rounded-xl bg-white border border-slate-200 text-slate-500 hover:text-slate-700 hover:bg-slate-50 font-bold transition">
          <i class="fas fa-xmark"></i>
        </button>
      </div>

      <div class="flex-1 min-h-0 bg-white">
        <iframe id="manual-frame" title="Manual" class="w-full h-full" style="border:0" src="about:blank"></iframe>
      </div>

      <div class="p-3 text-xs bg-white border-t border-slate-200 flex flex-wrap gap-3 items-center justify-between">
        <div class="flex flex-wrap gap-3 items-center">
          <a id="manual-open-new" href="#" target="_blank" rel="noopener"
             class="text-sky-700 font-bold hover:underline">
            <i class="fas fa-arrow-up-right-from-square mr-1"></i> 別タブで開く
          </a>
          <span class="text-slate-400">|</span>
          <span class="text-slate-500">PDFが表示されない端末は「別タブで開く」を押してください。</span>
        </div>
        <button onclick="closeManual()"
                class="text-slate-500 hover:text-slate-700 font-bold">
          閉じる
        </button>
      </div>
    </div>
  </div>
  <!-- Paste Add Modal -->
  <div id="paste-modal" class="fixed inset-0 z-[9998] hidden items-center justify-center p-4">
    <div class="absolute inset-0 bg-black/60" onclick="closePasteModal()"></div>

    <div class="relative bg-white w-full max-w-3xl h-[92svh] max-h-[92svh] rounded-3xl shadow-2xl border border-slate-200 overflow-hidden flex flex-col">
      <div class="flex items-center justify-between p-4 bg-slate-50 border-b border-slate-200">
        <div class="font-bold text-slate-700 flex items-center gap-2">
          <i class="fas fa-paste"></i> <span class="ctrl-text">コピペでカスタム追加</span>
        </div>
        <button onclick="closePasteModal()"
                class="px-3 py-2 rounded-xl bg-white border border-slate-200 text-slate-500 hover:text-slate-700 hover:bg-slate-50 font-bold transition">
          <i class="fas fa-xmark"></i>
        </button>
      </div>

      <div id="paste-body" class="flex-1 min-h-0 overflow-auto p-4 flex flex-col gap-3">
        <div class="flex flex-wrap gap-2 items-center">
          <button id="paste-tab-sent" type="button" onclick="switchPasteTab('sent')"
                  class="px-3 py-2 rounded-xl text-sm font-extrabold bg-sky-600 text-white">
            例文（.?!で1問）
          </button>
          <button id="paste-tab-word" type="button" onclick="switchPasteTab('word')"
                  class="px-3 py-2 rounded-xl text-sm font-extrabold bg-slate-100 text-slate-700 hover:bg-slate-200">
            単語（1行=1語）
          </button>
          <span class="text-xs text-slate-500 ml-auto">追加先：Custom</span>
        </div>

        <div class="grid grid-cols-12 gap-2 items-center">
          <label class="col-span-12 sm:col-span-3 text-xs font-bold text-slate-500">セクション名</label>
          <input id="paste-section"
                 class="col-span-12 sm:col-span-9 px-3 py-2 rounded-xl border border-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-200"
                 placeholder="例：My Essays / Vocabulary" />
        </div>

        <div class="flex flex-wrap gap-4 items-center text-sm">
          <label class="inline-flex items-center gap-2">
            <input id="paste-auto-ja" type="checkbox" class="accent-sky-600" checked>
            日本語訳を自動生成（外部API）
          </label>
          <label id="paste-auto-pos-wrap" class="inline-flex items-center gap-2">
            <input id="paste-auto-pos" type="checkbox" class="accent-sky-600" checked>
            品詞も自動入力（単語のみ）
          </label>
        </div>

        <div id="paste-help" class="text-xs text-slate-500 leading-relaxed bg-slate-50 border border-slate-200 rounded-2xl p-3">
          <div class="font-bold text-slate-600 mb-1">貼り付けの書式</div>
          <div id="paste-help-sent">
            例文は「. ? !」ごとに自動で1問に分割します。<br>
            さらに <b>1行に「英語[TAB]日本語」</b> で貼ると、日本語訳はそれを優先します。
          </div>
          <div id="paste-help-word" class="hidden">
            単語は <b>表（3列）</b> に入力します。<br>
            Excelから <b>語[TAB]品詞[TAB]意味</b> をそのまま貼り付けOK。品詞や意味が空なら自動で補完できます。
          </div>
        </div>

        <textarea id="paste-text" rows="8"
          class="w-full px-3 py-2 rounded-2xl border border-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-200 font-mono text-sm"
          placeholder="ここにコピペ…"></textarea>
        <div id="word-grid-wrap" class="hidden">
          <div class="flex flex-wrap gap-2 items-center mb-2">
            <button type="button" onclick="wordGridAddRow()"
                    class="px-3 py-2 rounded-xl bg-white border border-slate-200 text-slate-700 font-extrabold hover:bg-slate-50 text-sm">
              <i class="fas fa-plus"></i> 行追加
            </button>
            <button id="word-grid-autofill-btn" type="button" onclick="wordGridAutoFill()"
                    class="px-3 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 text-white font-extrabold shadow-sm text-sm">
              <i class="fas fa-wand-magic-sparkles"></i> 未入力を自動入力
            </button>
            <button type="button" onclick="wordGridClearEmpty()"
                    class="px-3 py-2 rounded-xl bg-white border border-slate-200 text-slate-700 font-extrabold hover:bg-slate-50 text-sm">
              <i class="fas fa-broom"></i> 空行削除
            </button>
            <button type="button" onclick="wordGridClearAll()"
                    class="px-3 py-2 rounded-xl bg-white border border-slate-200 text-red-600 font-extrabold hover:bg-red-50 text-sm">
              <i class="fas fa-trash"></i> 表をクリア
            </button>
            <span class="text-xs text-slate-500 ml-auto">Excel貼り付けOK（TAB区切り / 複数行OK）</span>
          </div>

          <div class="border border-slate-200 rounded-2xl overflow-hidden">
            <div class="max-h-[320px] overflow-auto">
              <table class="min-w-full text-sm">
                <thead class="sticky top-0 bg-slate-50 border-b border-slate-200">
                  <tr class="text-xs text-slate-500 font-extrabold">
                    <th class="px-3 py-2 w-2/6 text-left">語</th>
                    <th class="px-3 py-2 w-1/6 text-left">品詞</th>
                    <th class="px-3 py-2 w-3/6 text-left">意味</th>
                  </tr>
                </thead>
                <tbody id="word-grid-body" class="bg-white"></tbody>
              </table>
            </div>
          </div>

          <div class="text-[11px] text-slate-500 mt-2 leading-relaxed">
            ヒント：Excelの3列（語 / 品詞 / 意味）をそのまま貼り付けできます。品詞や意味が空なら「未入力を自動入力」または「追加」で自動補完します。
          </div>
        </div>


        
      </div>
      <div id="paste-footer" class="p-4 bg-white border-t border-slate-200 flex items-center gap-3 justify-between">
        <div id="paste-status" class="text-xs text-slate-500"></div>
        <div class="flex items-center gap-2">
<button onclick="closePasteModal()"
                    class="px-4 py-2 rounded-xl bg-white border border-slate-200 text-slate-600 font-extrabold hover:bg-slate-50">
              キャンセル
            </button>
            <button id="paste-commit-btn" onclick="pasteCommit()"
                    class="px-4 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 text-white font-extrabold shadow-sm">
              追加
            </button>
        </div>
      </div>
    </div>
  </div>




<script>
/* =========================================================
   Storage Keys
========================================================= */
const STORAGE_KEY_DATA     = 'typing_drill_final_data';
const STORAGE_KEY_STATS    = 'typing_drill_final_stats';
const STORAGE_KEY_HISTORY  = 'typing_drill_final_history';
const STORAGE_KEY_PROGRESS = 'typing_drill_final_progress'; // map object
const STORAGE_KEY_SRS      = 'typing_drill_srs_v1';

const STORAGE_KEY_SRS_LOG  = 'typing_drill_srs_log_v1';
const STORAGE_KEY_READ_SRS      = 'typing_drill_read_srs_v1';
const STORAGE_KEY_READ_SRS_LOG  = 'typing_drill_read_srs_log_v1';


const STORAGE_KEY_STATS_VIEW = 'typing_drill_stats_view_v1';
const STORAGE_KEY_STATS_SRS_DECK = 'typing_drill_stats_srs_deck_v1';
const STORAGE_KEY_SRS_MODE  = 'typing_drill_srs_mode_v1';
const STORAGE_KEY_BGM_VOL  = 'typing_drill_full_bgm_vol';
const STORAGE_KEY_BGM_MUTE = 'typing_drill_full_bgm_mute';
const STORAGE_KEY_TITLE_BGM = 'typing_drill_title_bgm_v2';

const STORAGE_KEY_WEEKLY_STUDY = 'typing_drill_weekly_study_v1';
const STORAGE_KEY_WPM_SANITIZED = 'typing_drill_wpm_sanitized_v1';
const STORAGE_KEY_QUESTION_ORDER = 'typing_drill_question_order_v1';
const STORAGE_KEY_READING_MODE = 'typing_drill_reading_mode_v1';
const STORAGE_KEY_PERSONAL_BASELINE = 'typing_drill_personal_baseline_v1';

// Try to reduce data eviction risk (does NOT survive manual "site data" deletion)
try{
  if(navigator.storage && navigator.storage.persist){
    navigator.storage.persist().catch(()=>{});
  }
}catch(e){}


/* --- 音量制限の定数 --- */
const BGM_MAX_LIMIT = 1.0; // 端末音量に対する上限（1.0=100%）
const BGM_VOL_CURVE = 1.0; // 0〜1のつまみを“聞こえ方”寄りに補正（小さい所が動きやすい）

/* =========================================================
   Manual (PDF)
========================================================= */
// Put your manual PDF in the same folder as index.html.
// If you rename the PDF, update MANUAL_PDF below.
const MANUAL_PDF = 'DrakichiTyping説明書.pdf';

function openManual(){
  const modal = document.getElementById('manual-modal');
  const frame = document.getElementById('manual-frame');
  const openNew = document.getElementById('manual-open-new');

  // Load PDF in the modal (works on most browsers). If it doesn't show on iOS, use "open in new tab".
  frame.src = MANUAL_PDF;
  openNew.href = MANUAL_PDF;

  modal.classList.remove('hidden');
  modal.classList.add('flex');
}

function closeManual(){
  const modal = document.getElementById('manual-modal');
  const frame = document.getElementById('manual-frame');

  // Stop PDF rendering to reduce memory usage on mobile
  frame.src = 'about:blank';

  modal.classList.add('hidden');
  modal.classList.remove('flex');
}

// ESC to close
window.addEventListener('keydown', (e) => {
  if(e.key === 'Escape'){
    const modal = document.getElementById('manual-modal');
    if(modal && !modal.classList.contains('hidden')) closeManual();
  }
});


/* =========================================================
   Data
========================================================= */
let allWords = [];
let gradeMap = {};   // grade -> Set(sections)
let statsData = {};  // key: grade_section -> { normal:{score,wpm}, hard..., extra..., date }
let historyData = []; // [{ts, grade, section, mode, wpm, score}]
let progressData = {}; // key: grade_section_mode -> {order:[idx...], pos, correctChars, mastered:[idx...]}
let srsData = {};      // key: srsKey -> {state,ease,intervalDays,dueTs,lapses}

let srsLog = [];      // [{ts, grade, sectionKey, mode, result, category}]
let readSrsData = {};  // 音読専用SRSデッキ（typingとは別）
let readSrsLog  = [];  // 音読SRSログ（統計用）
let readSrsKeyIndex = null;
/* =========================================================
   App State
========================================================= */
let currentSettings = {
  grade: null,
  section: null,
  mode: 'normal',
  timeLimitMin: 1,
  sfxType: true,
  sfxCoin: true,
  sfxClear: true,
  srsReviewOnly: false,
  readingMode: false,
  questionOrder: 'random'
};

let statsView = 'wpm';
let currentSrsMode = 'normal';
let currentSrsDeck = 'typing'; // 'typing' | 'reading'

const screens = ['grade','section','settings','csvroom','practice','result','stats'];
const backBtn = document.getElementById('back-btn');
const backLabel = document.getElementById('back-label');
const ctrlArea = document.getElementById('data-ctrl-area');

/* =========================================================
   Utility
========================================================= */
function keyFor(grade, section){ return `${grade}_${section}`; }
function keyForMode(grade, section, mode){ return `${grade}_${section}_${mode}`; }

function normalizeSectionName(sectionStr){
  if(!sectionStr) return 'Other';
  let s = String(sectionStr).trim();
  s = s.replace(/^\d+年\s*/, '').trim();
  return s || 'Other';
}

function rebuildGradeMap(){
  gradeMap = {};
  allWords.forEach(item=>{
    const g = item.grade;
    if(!g) return;
    if(!gradeMap[g]) gradeMap[g] = new Set();
    let cleanSection = item.section || "Other";
    cleanSection = cleanSection.replace(/^\d+年\s*/, '').trim();
    gradeMap[g].add(cleanSection);
  });
}

function loadAll(){
  // Data
  const storedData = localStorage.getItem(STORAGE_KEY_DATA);
  if(storedData){
    try{
      allWords = JSON.parse(storedData);
      document.getElementById('total-words-count').textContent = allWords.length;
      rebuildGradeMap();
      document.getElementById('no-data-alert').classList.add('hidden');
      document.getElementById('grade-buttons').classList.remove('opacity-50','pointer-events-none');
    }catch(e){ console.error(e); }
  }else{
    document.getElementById('no-data-alert').classList.remove('hidden');
    document.getElementById('grade-buttons').classList.add('opacity-50','pointer-events-none');
  }

  // Stats
  const storedStats = localStorage.getItem(STORAGE_KEY_STATS);
  if(storedStats){
    try{ statsData = JSON.parse(storedStats) || {}; }catch(e){ statsData = {}; }
  }

  // History
  try{
    const h = localStorage.getItem(STORAGE_KEY_HISTORY);
    historyData = h ? JSON.parse(h) : [];
  }catch{ historyData = []; }

  // Progress
  try{
    const p = localStorage.getItem(STORAGE_KEY_PROGRESS);
    progressData = p ? JSON.parse(p) : {};
  }catch{ progressData = {}; }

  // SRS
  try{
    const s = localStorage.getItem(STORAGE_KEY_SRS);
    srsData = s ? JSON.parse(s) : {};
  }catch{ srsData = {}; }
  srsKeyIndex = null; // SRS index will be rebuilt lazily



  // Read SRS (音読専用)
  try{
    const rs = localStorage.getItem(STORAGE_KEY_READ_SRS);
    readSrsData = rs ? JSON.parse(rs) : {};
  }catch{ readSrsData = {}; }
  readSrsKeyIndex = null;

  // SRS Log (for Anki-like charts)
  try{
    const l = localStorage.getItem(STORAGE_KEY_SRS_LOG);
    srsLog = l ? JSON.parse(l) : [];
    if(!Array.isArray(srsLog)) srsLog = [];  }catch{ srsLog = []; }

  // Read SRS Log (音読専用)
  try{
    const rl = localStorage.getItem(STORAGE_KEY_READ_SRS_LOG);
    readSrsLog = rl ? JSON.parse(rl) : [];
    if(!Array.isArray(readSrsLog)) readSrsLog = [];
  }catch{ readSrsLog = []; }

  // WPMチート対策：1語セクションWPMを無効化（過去データも補正）
  sanitizeWpmDataOnce();
  // 称号が上がりすぎていたら妥当な範囲に戻す
  sanitizeSpeedJobAgainstStats();

  // 出題順（ランダム / 登録順）
  try{
    const qo = localStorage.getItem(STORAGE_KEY_QUESTION_ORDER);
    if(qo==='registered' || qo==='random') currentSettings.questionOrder = qo;
  }catch(e){}
  // 音読モード（Web Speech API）
  // iPadでの誤ON/引き継ぎを防ぐため、起動時は常にOFF（必要な時だけON）
  currentSettings.readingMode = false;
  try{ localStorage.setItem(STORAGE_KEY_READING_MODE,'0'); }catch(e){}


}

function saveAll(){
  localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(statsData));
  localStorage.setItem(STORAGE_KEY_HISTORY, JSON.stringify(historyData));
  localStorage.setItem(STORAGE_KEY_PROGRESS, JSON.stringify(progressData));

  localStorage.setItem(STORAGE_KEY_SRS, JSON.stringify(srsData));
  localStorage.setItem(STORAGE_KEY_SRS_LOG, JSON.stringify(srsLog));

  // 音読SRS（別デッキ）
  localStorage.setItem(STORAGE_KEY_READ_SRS, JSON.stringify(readSrsData));
  localStorage.setItem(STORAGE_KEY_READ_SRS_LOG, JSON.stringify(readSrsLog));
}



/* =========================================================
   Data Manager (select & delete)
========================================================= */
let dm = {
  tab: 'sections',
  sectionsSearch: '',
  gradeFilter: '',
  sectionFilter: '',
  wordsSearch: '',
  cap: 500,
  wordsRenderedIdx: [] // indices in allWords currently shown (for checkboxes)
};

function initDataManager(){
  // Tabs
  const tabSec = document.getElementById('dm-tab-sections');
  const tabWords = document.getElementById('dm-tab-words');

  tabSec.addEventListener('click', ()=>dmSetTab('sections'));
  tabWords.addEventListener('click', ()=>dmSetTab('words'));

  // Section events
  document.getElementById('dm-sections-search').addEventListener('input', (e)=>{
    dm.sectionsSearch = e.target.value || '';
    dmRenderSections();
  });
  document.getElementById('dm-sections-selectall').addEventListener('click', ()=>dmSelectAll('sections', true));
  document.getElementById('dm-sections-clear').addEventListener('click', ()=>dmSelectAll('sections', false));
  document.getElementById('dm-sections-delete').addEventListener('click', dmDeleteSelectedSections);

  // Word events
  document.getElementById('dm-grade-filter').addEventListener('change', (e)=>{
    dm.gradeFilter = e.target.value || '';
    dmSyncSectionFilterOptions();
    dmRenderWords();
  });
  document.getElementById('dm-section-filter').addEventListener('change', (e)=>{
    dm.sectionFilter = e.target.value || '';
    dmRenderWords();
  });
  document.getElementById('dm-words-search').addEventListener('input', (e)=>{
    dm.wordsSearch = e.target.value || '';
    dmRenderWords();
  });
  document.getElementById('dm-words-selectall').addEventListener('click', ()=>dmSelectAll('words', true));
  document.getElementById('dm-words-clear').addEventListener('click', ()=>dmSelectAll('words', false));
  document.getElementById('dm-words-delete').addEventListener('click', dmDeleteSelectedWords);
  // Backup / Restore (JSON)
  const backupBtn = document.getElementById('dm-backup-json');
  if(backupBtn){
    backupBtn.addEventListener('click', exportAppBackupJson);
  }
  const restoreInput = document.getElementById('dm-restore-json');
  if(restoreInput){
    restoreInput.addEventListener('change', handleRestoreBackupJson);
  }

}


/* =========================================================
   App Backup / Restore (JSON)
========================================================= */
function exportAppBackupJson(){
  try{
    // ensure latest in storage
    try{ localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(allWords||[])); }catch(e){}
    try{ if(typeof saveAll === 'function') saveAll(); }catch(e){}

    const keys = [
      STORAGE_KEY_DATA,
      STORAGE_KEY_STATS,
      STORAGE_KEY_HISTORY,
      STORAGE_KEY_PROGRESS,
      STORAGE_KEY_SRS,
      STORAGE_KEY_SRS_LOG,
      STORAGE_KEY_STATS_VIEW,
      STORAGE_KEY_SRS_MODE,
      STORAGE_KEY_BGM_VOL,
      STORAGE_KEY_BGM_MUTE,
      STORAGE_KEY_QUESTION_ORDER,
    STORAGE_KEY_PERSONAL_BASELINE,
      STORAGE_KEY_PERSONAL_BASELINE,
      (typeof STORAGE_KEY_SPEED!=='undefined') ? STORAGE_KEY_SPEED : null,
      (typeof STORAGE_KEY_SRS_JOB!=='undefined') ? STORAGE_KEY_SRS_JOB : null,
      (typeof STORAGE_KEY_GODMASTER!=='undefined') ? STORAGE_KEY_GODMASTER : null,
      (typeof STORAGE_KEY_PENALTY!=='undefined') ? STORAGE_KEY_PENALTY : null,
      'srs_data'
    ].filter(Boolean);

    const storage = {};
    keys.forEach(k=>{
      const v = localStorage.getItem(k);
      if(v !== null && v !== undefined) storage[k] = v;
    });

    const payload = {
      schema: 1,
      app: 'Drakichi Typing',
      build: (typeof BUILD_ID !== 'undefined') ? BUILD_ID : '',
      exportedAt: new Date().toISOString(),
      storage
    };

    const blob = new Blob([JSON.stringify(payload)], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ymd = new Date().toISOString().slice(0,10).replace(/-/g,'');
    a.href = url;
    a.download = `DrakichiTyping_backup_${ymd}.txt`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);

    alert('バックアップを保存しました（.txt）。\n（※「Cookie / サイトデータ」を消す前に必ず保存してください）');
  }catch(e){
    console.error(e);
    alert('バックアップに失敗しました。');
  }
}

function applyBackupObject(obj){
  if(!obj) throw new Error('Empty backup');

  // schema v1
  if(obj.schema === 1 && obj.storage && typeof obj.storage === 'object'){
    Object.keys(obj.storage).forEach(k=>{
      const v = obj.storage[k];
      if(v === null || v === undefined) return;
      localStorage.setItem(k, (typeof v === 'string') ? v : JSON.stringify(v));
    });
    return true;
  }

  // legacy: allow raw keys at root
  const candidateKeys = [
    STORAGE_KEY_DATA,
    STORAGE_KEY_STATS,
    STORAGE_KEY_HISTORY,
    STORAGE_KEY_PROGRESS,
    STORAGE_KEY_SRS,
    STORAGE_KEY_SRS_LOG,
    STORAGE_KEY_STATS_VIEW,
    STORAGE_KEY_SRS_MODE,
    STORAGE_KEY_BGM_VOL,
    STORAGE_KEY_BGM_MUTE,
    STORAGE_KEY_QUESTION_ORDER,
    STORAGE_KEY_PERSONAL_BASELINE,
    (typeof STORAGE_KEY_SPEED!=='undefined') ? STORAGE_KEY_SPEED : null,
    (typeof STORAGE_KEY_SRS_JOB!=='undefined') ? STORAGE_KEY_SRS_JOB : null,
    (typeof STORAGE_KEY_GODMASTER!=='undefined') ? STORAGE_KEY_GODMASTER : null,
    (typeof STORAGE_KEY_PENALTY!=='undefined') ? STORAGE_KEY_PENALTY : null,
    'srs_data'
  ].filter(Boolean);

  let found = false;
  candidateKeys.forEach(k=>{
    if(Object.prototype.hasOwnProperty.call(obj, k)){
      found = true;
      const v = obj[k];
      if(v === null || v === undefined) return;
      localStorage.setItem(k, (typeof v === 'string') ? v : JSON.stringify(v));
    }
  });

  if(!found) throw new Error('Unknown backup format');
  return true;
}

async function handleRestoreBackupJson(ev){
  try{
    const file = ev.target.files && ev.target.files[0];
    ev.target.value = '';
    if(!file) return;

    const ok = confirm('このJSONでデータを復元します。\n現在の学習データは上書きされます。よろしいですか？');
    if(!ok) return;

    const text = await file.text();
    const obj = JSON.parse(text);
    applyBackupObject(obj);

    alert('復元しました。ページを再読み込みします。');
    location.reload();
  }catch(e){
    console.error(e);
    alert('復元に失敗しました。JSONが壊れている/形式が違う可能性があります。');
  }
}

function openDataManager(){
  const ov = document.getElementById('data-manager-overlay');
  ov.classList.remove('hidden');
  dmSetTab(dm.tab || 'sections');
  dmPopulateGradeFilter();
  dmSyncSectionFilterOptions();
  dmRenderSections();
  dmRenderWords();
}

function closeDataManager(){
  document.getElementById('data-manager-overlay').classList.add('hidden');
}

function dmSetTab(tab){
  dm.tab = tab;
  const isSections = tab === 'sections';
  document.getElementById('dm-sections-view').classList.toggle('hidden', !isSections);
  document.getElementById('dm-words-view').classList.toggle('hidden', isSections);

  const tabSec = document.getElementById('dm-tab-sections');
  const tabWords = document.getElementById('dm-tab-words');
  if(isSections){
    tabSec.className = "px-3 py-1 text-xs font-black rounded-full bg-sky-600 text-white";
    tabWords.className = "px-3 py-1 text-xs font-black rounded-full bg-slate-100 text-slate-600 hover:bg-slate-200";
  }else{
    tabWords.className = "px-3 py-1 text-xs font-black rounded-full bg-sky-600 text-white";
    tabSec.className = "px-3 py-1 text-xs font-black rounded-full bg-slate-100 text-slate-600 hover:bg-slate-200";
  }
}

function dmSelectAll(kind, on){
  if(kind==='sections'){
    document.querySelectorAll('input.dm-sec-cb').forEach(cb=>cb.checked = on);
  }else{
    document.querySelectorAll('input.dm-word-cb').forEach(cb=>cb.checked = on);
  }
}

function dmGetSectionGroups(){
  const groups = {};
  allWords.forEach((it)=>{
    const g = String(it.grade||'').trim();
    const sec = normalizeSectionName(it.section);
    const key = `${g}||${sec}`;
    if(!groups[key]) groups[key] = { grade:g, section:sec, count:0 };
    groups[key].count++;
  });
  return Object.values(groups).sort((a,b)=>{
    const ag = a.grade==='custom' ? 99 : parseInt(a.grade,10) || 98;
    const bg = b.grade==='custom' ? 99 : parseInt(b.grade,10) || 98;
    if(ag!==bg) return ag-bg;
    return String(a.section).localeCompare(String(b.section), 'ja');
  });
}

function dmRenderSections(){
  const tbody = document.getElementById('dm-sections-tbody');
  const empty = document.getElementById('dm-sections-empty');
  tbody.innerHTML = "";

  const q = (dm.sectionsSearch||'').trim().toLowerCase();
  const groups = dmGetSectionGroups().filter(g=>{
    if(!q) return true;
    return (`${g.grade} ${g.section}`.toLowerCase().includes(q));
  });

  if(groups.length===0){
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  groups.forEach((g, i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="p-2"><input type="checkbox" class="dm-sec-cb w-4 h-4" data-grade="${escapeHtmlAttr(g.grade)}" data-section="${escapeHtmlAttr(g.section)}"></td>
      <td class="p-2 font-bold">${escapeHtml(g.grade)}</td>
      <td class="p-2 font-bold">${escapeHtml(g.section)}</td>
      <td class="p-2">${g.count}</td>
      <td class="p-2">
        <button class="px-2 py-1 text-xs font-black rounded-lg bg-red-600 text-white hover:bg-red-700" data-action="del">削除</button>
        <button class="ml-2 px-2 py-1 text-xs font-black rounded-lg bg-slate-100 hover:bg-slate-200" data-action="detail">詳細</button>
      </td>
    `;
    // Row actions
    tr.querySelector('button[data-action="del"]').addEventListener('click', ()=>{
      if(confirm(`このセクションを削除しますか？
Grade: ${g.grade}
Section: ${g.section}
（学習進捗/成績/履歴/SRSも整理します）`)){
        dmDeleteSections([{grade:g.grade, section:g.section}]);
      }
    });
    tr.querySelector('button[data-action="detail"]').addEventListener('click', ()=>{
      dm.gradeFilter = g.grade;
      dm.sectionFilter = g.section;
      document.getElementById('dm-grade-filter').value = dm.gradeFilter;
      dmSyncSectionFilterOptions();
      document.getElementById('dm-section-filter').value = dm.sectionFilter;
      dmSetTab('words');
      dmRenderWords();
    });

    tbody.appendChild(tr);
  });
}

function dmPopulateGradeFilter(){
  const sel = document.getElementById('dm-grade-filter');
  const grades = Array.from(new Set(allWords.map(w=>String(w.grade||'').trim()).filter(Boolean)));
  grades.sort((a,b)=>{
    const ag = a==='custom' ? 99 : parseInt(a,10) || 98;
    const bg = b==='custom' ? 99 : parseInt(b,10) || 98;
    return ag-bg;
  });

  const keep = dm.gradeFilter;
  sel.innerHTML = `<option value="">全Grade</option>` + grades.map(g=>`<option value="${escapeHtmlAttr(g)}">${escapeHtml(g)}</option>`).join('');
  if(keep) sel.value = keep;
}

function dmSyncSectionFilterOptions(){
  const sel = document.getElementById('dm-section-filter');
  const grade = dm.gradeFilter;
  const secs = new Set();
  allWords.forEach(w=>{
    const g = String(w.grade||'').trim();
    if(grade && g!==grade) return;
    secs.add(normalizeSectionName(w.section));
  });
  const arr = Array.from(secs).sort((a,b)=>String(a).localeCompare(String(b),'ja'));
  const keep = dm.sectionFilter;
  sel.innerHTML = `<option value="">全Section</option>` + arr.map(s=>`<option value="${escapeHtmlAttr(s)}">${escapeHtml(s)}</option>`).join('');
  if(keep && arr.includes(keep)) sel.value = keep;
  else if(keep && !arr.includes(keep)) dm.sectionFilter = '';
}

function dmRenderWords(){
  const tbody = document.getElementById('dm-words-tbody');
  const empty = document.getElementById('dm-words-empty');
  tbody.innerHTML = "";
  dm.wordsRenderedIdx = [];

  const grade = dm.gradeFilter;
  const sec = dm.sectionFilter;
  const q = (dm.wordsSearch||'').trim().toLowerCase();

  // Filter
  let idxs = [];
  for(let i=0;i<allWords.length;i++){
    const it = allWords[i];
    if(grade && String(it.grade||'').trim()!==grade) continue;
    const secN = normalizeSectionName(it.section);
    if(sec && secN!==sec) continue;

    if(q){
      const hay = `${it.en||''} ${it.ja||''}`.toLowerCase();
      if(!hay.includes(q)) continue;
    }
    idxs.push(i);
    if(idxs.length>=dm.cap) break;
  }

  document.getElementById('dm-words-cap').textContent = dm.cap;
  document.getElementById('dm-words-shown').textContent = idxs.length;

  if(idxs.length===0){
    empty.classList.remove('hidden');
    return;
  }
  empty.classList.add('hidden');

  idxs.forEach(i=>{
    const it = allWords[i];
    const secN = normalizeSectionName(it.section);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="p-2"><input type="checkbox" class="dm-word-cb w-4 h-4" data-idx="${i}"></td>
      <td class="p-2 font-bold">${escapeHtml(String(it.grade||''))}</td>
      <td class="p-2">${escapeHtml(secN)}</td>
      <td class="p-2 font-bold">${escapeHtml(it.en||'')}</td>
      <td class="p-2">${escapeHtml(it.ja||'')}</td>
    `;
    tbody.appendChild(tr);
    dm.wordsRenderedIdx.push(i);
  });
}

function dmDeleteSelectedSections(){
  const picked = Array.from(document.querySelectorAll('input.dm-sec-cb:checked')).map(cb=>({
    grade: cb.getAttribute('data-grade'),
    section: cb.getAttribute('data-section')
  }));

  if(picked.length===0){
    alert("削除したいセクションを選んでください。");
    return;
  }
  if(!confirm(`選択した ${picked.length} セクションを削除しますか？
（学習進捗/成績/履歴/SRSも整理します）`)) return;
  dmDeleteSections(picked);
}

function dmDeleteSections(picked){
  const pickSet = new Set(picked.map(p=>`${p.grade}||${p.section}`));

  // Remove words
  const before = allWords.length;
  allWords = allWords.filter(it=>{
    const g = String(it.grade||'').trim();
    const sec = normalizeSectionName(it.section);
    return !pickSet.has(`${g}||${sec}`);
  });

  // Clean related data (stats/history/progress/srs/srsLog)
  picked.forEach(p=>{
    const g = String(p.grade||'').trim();
    const sec = String(p.section||'').trim();

    // Stats
    const sk = keyFor(g, sec);
    if(statsData && statsData[sk]) delete statsData[sk];

    // History
    if(Array.isArray(historyData)){
      historyData = historyData.filter(h=>!(String(h.grade||'').trim()===g && String(h.section||'').trim()===sec));
    }

    // Progress (any mode)
    Object.keys(progressData||{}).forEach(k=>{
      if(k.startsWith(`${g}_${sec}_`)) delete progressData[k];
    });

    // SRS cards
    Object.keys(srsData||{}).forEach(k=>{
      if(k.startsWith(`${g}||${sec}||`)) delete srsData[k];
    });

    // SRS log
    if(Array.isArray(srsLog)){
      srsLog = srsLog.filter(r=>!(String(r.grade||'').trim()===g && String(r.sectionKey||'').trim()===sec));
    }
  });

  // Persist
  localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(allWords));
  saveAll();

  alert(`削除しました。
削除: ${before - allWords.length}件
残り: ${allWords.length}件`);
  location.reload();
}

function dmDeleteSelectedWords(){
  const picked = Array.from(document.querySelectorAll('input.dm-word-cb:checked')).map(cb=>parseInt(cb.getAttribute('data-idx'),10)).filter(n=>Number.isFinite(n));
  if(picked.length===0){
    alert("削除したい単語を選んでください。");
    return;
  }
  if(!confirm(`選択した ${picked.length} 件の単語を削除しますか？
（そのセクションの途中経過はリセットします / SRSカードも削除します）`)) return;

  // Sort descending for safe splicing
  picked.sort((a,b)=>b-a);

  const affected = new Set();
  const removedItems = [];

  picked.forEach(i=>{
    const it = allWords[i];
    if(!it) return;
    removedItems.push(it);
    affected.add(`${String(it.grade||'').trim()}||${normalizeSectionName(it.section)}`);
    allWords.splice(i,1);
  });

  // Remove SRS cards for removed items (all modes)
  const modes = ['normal','hard','extra'];
  removedItems.forEach(it=>{
    const g = String(it.grade||'').trim();
    const sec = normalizeSectionName(it.section);
    modes.forEach(mode=>{
      const k = srsKey(g, sec, mode, it.en);
      if(srsData && srsData[k]) delete srsData[k];
    });
  });

  // Reset progress for affected sections (any mode)
  affected.forEach(k=>{
    const [g, sec] = k.split('||');
    Object.keys(progressData||{}).forEach(pk=>{
      if(pk.startsWith(`${g}_${sec}_`)) delete progressData[pk];
    });
  });

  // Persist
  localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(allWords));
  saveAll();

  alert(`削除しました。
残り: ${allWords.length}件`);
  location.reload();
}

// small helpers (safe HTML)
function escapeHtml(str){
  return String(str||'').replace(/[&<>"']/g, s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[s]));
}
function escapeHtmlAttr(str){ return escapeHtml(str).replace(/`/g,'&#96;'); }



// Normalize full-width / Japanese punctuation to half-width ASCII for typing.
// This makes '.' ';' ':' '?' etc usable even when the CSV or IME outputs full-width chars.
function normalizeTypingText(str){
  let s = String(str ?? '');

  // Full-width space -> half-width
  s = s.replace(/\u3000/g, ' ');

  // Full-width ASCII (！ to ～) -> ASCII (! to ~)
  s = s.replace(/[\uFF01-\uFF5E]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0));

  // Common Japanese punctuation produced by IME / Excel -> ASCII
  const map = {
    '。':'.','、':',',
    '「':'"','」':'"','『':'"','』':'"',
    '（':'(', '）':')',
    '［':'[','］':']','【':'[','】':']',
    '｛':'{','｝':'}',
    '’':"'",'‘':"'",'“':'"','”':'"',
    '〜':'~','～':'~'
  };
  s = s.replace(/[。、「」『』（）［］【】｛｝’‘“”〜～]/g, ch => map[ch] || ch);

  return s;
}
/* =========================================================
   Paste Add (Sentences / Words) to Custom
   - Sentences: split by . ? !
   - Words: 1 line = 1 word (TAB supported)
   Notes:
   - Auto Japanese translation uses a public endpoint; may be blocked on some networks.
   - POS auto tries dictionaryapi.dev, then heuristic fallback.
========================================================= */
const STORAGE_KEY_PASTE_TRANSLATE = 'typing_drill_paste_translate_v1';
const STORAGE_KEY_PASTE_POS = 'typing_drill_paste_pos_v1';
const STORAGE_KEY_PASTE_SECTION = 'typing_drill_paste_section_v1';
let pasteMode = 'sent';

function openPasteModal(){
  const modal = document.getElementById('paste-modal');
  if(!modal) return;
  modal.classList.remove('hidden');
  modal.classList.add('flex');

  // restore
  try{
    const sec = localStorage.getItem(STORAGE_KEY_PASTE_SECTION) || '';
    document.getElementById('paste-section').value = sec;
  }catch(e){}
  try{
    const t = localStorage.getItem(STORAGE_KEY_PASTE_TRANSLATE);
    if(t==='0') document.getElementById('paste-auto-ja').checked = false;
  }catch(e){}
  try{
    const p = localStorage.getItem(STORAGE_KEY_PASTE_POS);
    if(p==='0') document.getElementById('paste-auto-pos').checked = false;
  }catch(e){}

  switchPasteTab(pasteMode);
  document.getElementById('paste-status').textContent = '';
  setTimeout(()=>{ focusPasteArea(); }, 30);
}

function closePasteModal(){
  const modal = document.getElementById('paste-modal');
  if(!modal) return;
  modal.classList.add('hidden');
  modal.classList.remove('flex');
  document.getElementById('paste-status').textContent = '';
}

window.addEventListener('keydown', (e)=>{
  if(e.key !== 'Escape') return;
  const modal = document.getElementById('paste-modal');
  if(modal && !modal.classList.contains('hidden')) closePasteModal();
});



function focusPasteArea(){
  if(pasteMode==='word'){
    initWordGrid();
    const first = document.querySelector('#word-grid-body input[data-col="en"]');
    if(first) first.focus();
  }else{
    const ta = document.getElementById('paste-text');
    if(ta) ta.focus();
  }
}

function switchPasteTab(tab){
  pasteMode = (tab==='word') ? 'word' : 'sent';
  const btnSent = document.getElementById('paste-tab-sent');
  const btnWord = document.getElementById('paste-tab-word');
  const helpSent = document.getElementById('paste-help-sent');
  const helpWord = document.getElementById('paste-help-word');
  const posWrap = document.getElementById('paste-auto-pos-wrap');
  const ta = document.getElementById('paste-text');
  const gridWrap = document.getElementById('word-grid-wrap');

  if(pasteMode==='sent'){
    btnSent.className = 'px-3 py-2 rounded-xl text-sm font-extrabold bg-sky-600 text-white';
    btnWord.className = 'px-3 py-2 rounded-xl text-sm font-extrabold bg-slate-100 text-slate-700 hover:bg-slate-200';
    helpSent.classList.remove('hidden');
    helpWord.classList.add('hidden');
    if(posWrap) posWrap.classList.add('opacity-50');

    if(ta){
      ta.classList.remove('hidden');
      ta.placeholder = "例：I like cats. Do you like cats? Let's go!\n（TABで 英語[TAB]日本語 もOK）";
    }
    if(gridWrap) gridWrap.classList.add('hidden');
  }else{
    btnSent.className = 'px-3 py-2 rounded-xl text-sm font-extrabold bg-slate-100 text-slate-700 hover:bg-slate-200';
    btnWord.className = 'px-3 py-2 rounded-xl text-sm font-extrabold bg-sky-600 text-white';
    helpSent.classList.add('hidden');
    helpWord.classList.remove('hidden');
    if(posWrap) posWrap.classList.remove('opacity-50');

    if(ta) ta.classList.add('hidden');
    if(gridWrap) gridWrap.classList.remove('hidden');
    initWordGrid();
  }

  // Focus the main input after switching
  setTimeout(()=>{ focusPasteArea(); }, 0);
}

function _cleanLine(s){
  return String(s ?? '').replace(/\r/g,'').trim();
}

function _splitSentencesByPunct(block){
  const t = normalizeTypingText(String(block ?? '')).replace(/\s+/g,' ').trim();
  if(!t) return [];
  // Match: ...[.!?]+ or tail without punctuation
  const parts = t.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [];
  return parts.map(x=>x.trim()).filter(Boolean);
}

function _parsePastedSentences(rawText){
  const lines = String(rawText ?? '').split('\n').map(_cleanLine).filter(Boolean);

  const out = [];
  const plainBlocks = [];

  for(const line of lines){
    // If user provides EN[TAB]JA, prioritize
    if(line.includes('\t')){
      const parts = line.split('\t').map(p=>p.trim()).filter(p=>p.length>0);
      if(parts.length>=2){
        const en = normalizeTypingText(parts[0]).trim();
        const ja = parts.slice(1).join(' ').trim();
        if(en) out.push({en, ja, pos:''});
        continue;
      }
    }
    plainBlocks.push(line);
  }

  const block = plainBlocks.join(' ');
  const sents = _splitSentencesByPunct(block);
  for(const s of sents){
    out.push({en: s, ja:'', pos:''});
  }
  return out;
}

function _parsePastedWords(rawText){
  const lines = String(rawText ?? '').split('\n').map(_cleanLine).filter(Boolean);
  const out = [];
  for(const line of lines){
    if(line.includes('\t')){
      const parts = line.split('\t').map(p=>p.trim());
      const en = normalizeTypingText(parts[0]).trim();
      if(!en) continue;
      if(parts.length>=3){
        const pos = (parts[1]||'').trim();
        const ja = parts.slice(2).join(' ').trim();
        out.push({en, ja, pos});
      }else if(parts.length===2){
        const ja = (parts[1]||'').trim();
        out.push({en, ja, pos:''});
      }else{
        out.push({en, ja:'', pos:''});
      }
      continue;
    }
    // Comma form: word,meaning
    if(line.includes(',') && line.split(',').length===2){
      const [a,b] = line.split(',');
      const en = normalizeTypingText(a).trim();
      const ja = (b||'').trim();
      if(en) out.push({en, ja, pos:''});
      continue;
    }
    const en = normalizeTypingText(line).trim();
    if(en) out.push({en, ja:'', pos:''});
  }
  return out;
}

const _translateCache = new Map();

function _cleanJaText(out){
  let s = String(out ?? '').replace(/\u200b/g,'').trim();
  if(!s) return '';
  if(/MYMEMORY/i.test(s)) return '';
  // normalize spaces
  s = s.replace(/\s+/g,' ').trim();
  return s;
}

async function _translateViaGoogle(s){
  const url = 'https://translate.googleapis.com/translate_a/single?client=gtx&sl=en&tl=ja&dt=t&q=' + encodeURIComponent(s);
  const res = await fetch(url, { cache:'no-store' });
  if(!res.ok) throw new Error('google translate http ' + res.status);
  const j = await res.json();
  const segs = (j && j[0]) ? j[0] : [];
  const out = Array.isArray(segs) ? segs.map(x=> (x && x[0]) ? String(x[0]) : '').join('') : '';
  return _cleanJaText(out);
}

async function _translateViaMyMemory(s){
  const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(s) + '&langpair=en|ja';
  const res = await fetch(url, { cache:'no-store' });
  if(!res.ok) throw new Error('mymemory translate http ' + res.status);
  const j = await res.json();
  const out = (j && j.responseData && j.responseData.translatedText) ? String(j.responseData.translatedText) : '';
  return _cleanJaText(out);
}

async function translateEnToJa(text){
  const s = String(text ?? '').trim();
  if(!s) return '';
  if(_translateCache.has(s)) return _translateCache.get(s);

  // Google優先（自然になりやすい）→ ダメならMyMemory
  let out = '';
  try{ out = await _translateViaGoogle(s); }catch(e){}
  if(!out){
    try{ out = await _translateViaMyMemory(s); }catch(e){}
  }

  _translateCache.set(s, out);
  return out;
}

function _isSimpleWordToken(w){
  const s = String(w||'').trim();
  return /^[A-Za-z][A-Za-z'-]*$/.test(s);
}

// 品詞をヒントに「より自然な訳」を取りに行くための変換
function _hintForWordTranslation(word, posJa){
  const w = String(word||'').trim();
  if(!_isSimpleWordToken(w)) return w;

  // 動詞は "to run" の形にすると「走る」になりやすい
  if(posJa === '動') return 'to ' + w;

  // 形容詞は "be happy" の形にすると自然になりやすい
  if(posJa === '形') return 'be ' + w;

  // 名詞・副詞などはそのまま
  return w;
}

async function translateWordToJa(word, posJa){
  const w = String(word||'').trim();
  if(!w) return '';
  const hint = _hintForWordTranslation(w, posJa);

  // ヒント付き → ダメなら素の単語でもう一回
  let t = await translateEnToJa(hint);
  if(!t && hint !== w){
    t = await translateEnToJa(w);
  }
  return t;
}



function posEnToJa(posEn){
  const p = String(posEn||'').toLowerCase();
  if(!p) return '';
  if(p.includes('noun')) return '名';
  if(p.includes('verb')) return '動';
  if(p.includes('adjective')) return '形';
  if(p.includes('adverb')) return '副';
  if(p.includes('pronoun')) return '代';
  if(p.includes('preposition')) return '前';
  if(p.includes('conjunction')) return '接';
  if(p.includes('interjection')) return '間';
  if(p.includes('determiner') || p.includes('article')) return '限';
  if(p.includes('numeral') || p.includes('number')) return '数';
  return '';
}

function guessPosJa(word){
  const w0 = String(word||'').trim();
  if(!w0) return '';
  const w = w0.toLowerCase();

  // multiword phrases
  if(/\s/.test(w)) return '熟';

  // function-word quick lists
  const preps = new Set(['in','on','at','to','for','from','by','with','about','as','into','like','through','after','over','between','out','against','during','without','before','under','around','among','of']);
  const conjs = new Set(['and','but','or','so','because','if','when','while','though','although','since','until']);
  const prons = new Set(['i','you','he','she','it','we','they','me','him','her','us','them','my','your','his','its','our','their','mine','yours','hers','ours','theirs','this','that','these','those']);
  const dets  = new Set(['a','an','the','some','any','each','every','no','many','much','few','little','all','both','either','neither']);
  if(preps.has(w)) return '前';
  if(conjs.has(w)) return '接';
  if(prons.has(w)) return '代';
  if(dets.has(w)) return '限';

  // suffix heuristics
  if(/ly$/.test(w)) return '副';
  if(/(tion|sion|ment|ness|ship|hood|ism|ist|ance|ence)$/.test(w)) return '名';
  if(/(able|ible|ous|ful|less|ive|al|ic|ish|ary|y)$/.test(w)) return '形';
  if(/(ing|ed|en)$/.test(w)) return '動';

  // default guess: noun (more common for standalone word lists)
  return '名';
}

const _posCache = new Map();
async function detectPosJa(word){
  const key = String(word||'').trim().toLowerCase();
  if(!key) return '';
  if(_posCache.has(key)) return _posCache.get(key);

  // If not a simple alphabetic token, fallback
  if(/\s/.test(key) || !/^[a-z][a-z'-]*$/i.test(key)){
    const g = guessPosJa(word);
    _posCache.set(key, g);
    return g;
  }

  // dictionaryapi.dev: https://dictionaryapi.dev/
  const url = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + encodeURIComponent(key);
  try{
    const res = await fetch(url, { cache:'no-store' });
    if(res.ok){
      const j = await res.json();
      const pos = j?.[0]?.meanings?.[0]?.partOfSpeech || '';
      const ja = posEnToJa(pos) || guessPosJa(word);
      _posCache.set(key, ja);
      return ja;
    }
  }catch(e){}
  const g = guessPosJa(word);
  _posCache.set(key, g);
  return g;
}


/* =========================================================
   Word Grid (Excel-like)
   - 3 columns: en / pos / ja
   - Paste supports Excel-like tab+newline blocks
   - Auto fill uses the same translation & POS detectors
========================================================= */
const WORD_GRID_MIN_ROWS = 12;
const WORD_GRID_MAX_ROWS = 300;
let _wordGridInited = false;

function initWordGrid(){
  if(_wordGridInited) return;
  const tbody = document.getElementById('word-grid-body');
  if(!tbody) return;
  tbody.innerHTML = '';
  for(let i=0;i<WORD_GRID_MIN_ROWS;i++) _appendWordGridRow({en:'', pos:'', ja:''});
  _wordGridInited = true;
  _wordGridEnsureTrailing();
}

function _mkGridInput(col, placeholder){
  const input = document.createElement('input');
  input.type = 'text';
  input.setAttribute('data-col', col);
  input.placeholder = placeholder || '';
  input.className = 'w-full px-2 py-2 rounded-xl border border-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-200 text-sm';
  input.autocomplete = 'off';
  input.spellcheck = false;
  return input;
}

function _appendWordGridRow(data){
  const tbody = document.getElementById('word-grid-body');
  if(!tbody) return;
  if(tbody.children.length >= WORD_GRID_MAX_ROWS) return;

  const tr = document.createElement('tr');
  tr.className = 'border-b border-slate-100 last:border-b-0';

  const tdEn = document.createElement('td');
  tdEn.className = 'px-2 py-1.5 align-top';
  const inpEn = _mkGridInput('en','例：run');
  inpEn.value = String(data?.en ?? '');
  tdEn.appendChild(inpEn);

  const tdPos = document.createElement('td');
  tdPos.className = 'px-2 py-1.5 align-top';
  const inpPos = _mkGridInput('pos','名/動/形…');
  inpPos.value = String(data?.pos ?? '');
  tdPos.appendChild(inpPos);

  const tdJa = document.createElement('td');
  tdJa.className = 'px-2 py-1.5 align-top';
  const inpJa = _mkGridInput('ja','例：走る');
  inpJa.value = String(data?.ja ?? '');
  tdJa.appendChild(inpJa);

  tr.appendChild(tdEn);
  tr.appendChild(tdPos);
  tr.appendChild(tdJa);
  tbody.appendChild(tr);

  [inpEn, inpPos, inpJa].forEach(inp=>{
    inp.addEventListener('input', ()=>{ _wordGridEnsureTrailing(); });
    inp.addEventListener('keydown', (e)=>{ _wordGridNavKeys(e, inp); });
    inp.addEventListener('paste', (e)=>{ _wordGridHandlePaste(e, inp); });
  });
}

function _wordGridRowIndex(inp){
  const tr = inp?.closest('tr');
  const tbody = document.getElementById('word-grid-body');
  if(!tr || !tbody) return -1;
  return Array.from(tbody.children).indexOf(tr);
}

function _wordGridGetCell(row, col){
  const tbody = document.getElementById('word-grid-body');
  const tr = tbody?.children?.[row];
  if(!tr) return null;
  return tr.querySelector(`input[data-col="${col}"]`);
}

function _colIndex(col){
  if(col==='en') return 0;
  if(col==='pos') return 1;
  return 2; // ja
}
function _colName(i){
  if(i===0) return 'en';
  if(i===1) return 'pos';
  return 'ja';
}

function _wordGridEnsureTrailing(){
  const tbody = document.getElementById('word-grid-body');
  if(!tbody) return;
  if(tbody.children.length === 0){
    _appendWordGridRow({en:'', pos:'', ja:''});
    return;
  }
  const last = tbody.lastElementChild;
  const en = last.querySelector('input[data-col="en"]')?.value.trim() || '';
  const pos = last.querySelector('input[data-col="pos"]')?.value.trim() || '';
  const ja = last.querySelector('input[data-col="ja"]')?.value.trim() || '';
  if(en || pos || ja){
    _appendWordGridRow({en:'', pos:'', ja:''});
  }
}

function _wordGridNavKeys(e, inp){
  const row = _wordGridRowIndex(inp);
  if(row < 0) return;
  const col = inp.dataset.col || 'en';

  // Enter -> next row same column (Excel-like)
  if(e.key === 'Enter'){
    e.preventDefault();
    _wordGridEnsureTrailing();
    const next = _wordGridGetCell(row+1, col);
    if(next) next.focus();
    return;
  }

  // Ctrl+Backspace -> clear cell
  if(e.ctrlKey && e.key === 'Backspace'){
    e.preventDefault();
    inp.value = '';
    _wordGridEnsureTrailing();
    return;
  }
}

function _wordGridHandlePaste(e, inp){
  const text = (e.clipboardData || window.clipboardData)?.getData('text/plain') || '';
  if(!text) return;

  // Always treat as block paste (Excel-like)
  e.preventDefault();

  initWordGrid();
  const tbody = document.getElementById('word-grid-body');
  const startRow = Math.max(0, _wordGridRowIndex(inp));
  const startCol = _colIndex(inp.dataset.col);

  const lines = String(text).replace(/\r/g,'').split('\n');

  let r = 0;
  for(const line0 of lines){
    // ignore trailing empty line
    if(r === lines.length-1 && String(line0).trim()==='') continue;

    const cols = String(line0).split('\t');
    const targetRow = startRow + r;

    while(tbody.children.length <= targetRow){
      _appendWordGridRow({en:'', pos:'', ja:''});
    }

    for(let c=0; c<cols.length; c++){
      const targetCol = startCol + c;
      if(targetCol > 2) break;

      const val = normalizeTypingText(cols[c]).trim();
      const cell = _wordGridGetCell(targetRow, _colName(targetCol));
      if(cell) cell.value = val;
    }
    r++;
  }
  _wordGridEnsureTrailing();
}

function wordGridAddRow(){
  initWordGrid();
  _appendWordGridRow({en:'', pos:'', ja:''});
  const tbody = document.getElementById('word-grid-body');
  const last = tbody?.lastElementChild?.querySelector('input[data-col="en"]');
  if(last) last.focus();
}

function wordGridClearAll(){
  const tbody = document.getElementById('word-grid-body');
  if(!tbody) return;
  tbody.innerHTML = '';
  _wordGridInited = false;
  initWordGrid();
  const statusEl = document.getElementById('paste-status');
  if(statusEl) statusEl.textContent = '';
}

function wordGridClearEmpty(){
  const tbody = document.getElementById('word-grid-body');
  if(!tbody) return;

  Array.from(tbody.children).forEach(tr=>{
    const en = tr.querySelector('input[data-col="en"]')?.value.trim() || '';
    const pos = tr.querySelector('input[data-col="pos"]')?.value.trim() || '';
    const ja = tr.querySelector('input[data-col="ja"]')?.value.trim() || '';
    if(!en && !pos && !ja) tr.remove();
  });

  // Keep minimum rows
  while(tbody.children.length < WORD_GRID_MIN_ROWS) _appendWordGridRow({en:'', pos:'', ja:''});
  _wordGridEnsureTrailing();
}

function _readWordsFromGrid(){
  initWordGrid();
  const tbody = document.getElementById('word-grid-body');
  if(!tbody) return [];
  const out = [];

  Array.from(tbody.children).forEach((tr)=>{
    const enRaw = tr.querySelector('input[data-col="en"]')?.value ?? '';
    const posRaw = tr.querySelector('input[data-col="pos"]')?.value ?? '';
    const jaRaw = tr.querySelector('input[data-col="ja"]')?.value ?? '';

    const en = normalizeTypingText(String(enRaw)).trim().replace(/\s+/g,' ');
    const pos = String(posRaw).trim();
    const ja = String(jaRaw).trim();

    if(!en && !pos && !ja) return;
    if(!en) return; // require word
    out.push({en, pos, ja});
  });

  return out;
}

async function wordGridAutoFill(){
  initWordGrid();

  const statusEl = document.getElementById('paste-status');
  const btn = document.getElementById('word-grid-autofill-btn');
  const autoJa = !!document.getElementById('paste-auto-ja')?.checked;
  const autoPos = !!document.getElementById('paste-auto-pos')?.checked;

  const tbody = document.getElementById('word-grid-body');
  if(!tbody) return;

  const rows = Array.from(tbody.children).filter(tr=>{
    const en = tr.querySelector('input[data-col="en"]')?.value.trim() || '';
    return !!en;
  });

  if(rows.length === 0){
    alert('単語がありません（1列目に語を入れてください）。');
    return;
  }

  if(btn){
    btn.disabled = true;
    btn.classList.add('opacity-60','pointer-events-none');
  }

  let filledPos = 0;
  let filledJa = 0;
  let failedJa = 0;

  for(let i=0;i<rows.length;i++){
    const tr = rows[i];
    const enEl = tr.querySelector('input[data-col="en"]');
    const posEl = tr.querySelector('input[data-col="pos"]');
    const jaEl = tr.querySelector('input[data-col="ja"]');

    let en = normalizeTypingText(enEl?.value ?? '').trim().replace(/\s+/g,' ');
    if(!en) continue;
    enEl.value = en;

    const needsJa = !!(autoJa && jaEl && !jaEl.value.trim());
    const needsPos = !!(posEl && !posEl.value.trim());

    // 品詞が空なら、(autoPosがON) もしくは (意味を自動入力したい=needsJa) のときに品詞も埋める
    if(needsPos && (autoPos || needsJa)){
      if(statusEl) statusEl.textContent = `品詞を自動入力中… (${i+1}/${rows.length})`;
      const pos = await detectPosJa(en);
      if(pos){
        posEl.value = pos;
        filledPos++;
      }
    }

    // 意味（日本語）を自動入力（品詞をヒントに訳を自然にする）
    if(needsJa){
      let posJa = posEl ? String(posEl.value||'').trim() : '';

      // まだ品詞が空なら、訳のためにもう一度だけ推定（ここで埋める）
      if(!posJa){
        if(statusEl) statusEl.textContent = `品詞を自動入力中… (${i+1}/${rows.length})`;
        const pos = await detectPosJa(en);
        if(pos){
          posJa = pos;
          if(posEl && !posEl.value.trim()){
            posEl.value = pos;
            filledPos++;
          }
        }
      }

      if(statusEl) statusEl.textContent = `意味を自動入力中… (${i+1}/${rows.length})`;
      const src = en.length > 220 ? en.slice(0,220) : en;
      const t = await translateWordToJa(src, posJa);
      if(t){
        jaEl.value = t;
        filledJa++;
      }else{
        // ネットワーク制限などで取得できない場合
        jaEl.value = '（要確認）';
        failedJa++;
      }
    }
  }

  _wordGridEnsureTrailing();

  if(btn){
    btn.disabled = false;
    btn.classList.remove('opacity-60','pointer-events-none');
  }

  if(statusEl){
    statusEl.textContent = `自動入力完了：品詞 ${filledPos} / 意味 ${filledJa}` + (failedJa ? `（取得失敗 ${failedJa}）` : '');
  }
}


async function pasteCommit(){
  const btn = document.getElementById('paste-commit-btn');
  const statusEl = document.getElementById('paste-status');
  const secEl = document.getElementById('paste-section');
  const txtEl = document.getElementById('paste-text');
  const autoJaEl = document.getElementById('paste-auto-ja');
  const autoPosEl = document.getElementById('paste-auto-pos');

  const section = String(secEl?.value || '').trim();
  if(!section){
    alert('セクション名を入れてください。');
    return;
  }

  const autoJa = !!autoJaEl?.checked;
  const autoPos = !!autoPosEl?.checked;

  // persist prefs
  try{ localStorage.setItem(STORAGE_KEY_PASTE_SECTION, section); }catch(e){}
  try{ localStorage.setItem(STORAGE_KEY_PASTE_TRANSLATE, (autoJa ? '1' : '0')); }catch(e){}
  try{ localStorage.setItem(STORAGE_KEY_PASTE_POS, (autoPos ? '1' : '0')); }catch(e){}

  // Collect input
  let parsed = [];
  if(pasteMode === 'word'){
    parsed = _readWordsFromGrid().map(x=>({en:x.en, ja:x.ja || '', pos:x.pos || ''}));
    if(!parsed.length){
      alert('単語がありません（表の1列目に語を入れてください）。');
      return;
    }
  }else{
    const rawText = String(txtEl?.value || '').trim();
    if(!rawText){
      alert('貼り付け内容が空です。');
      return;
    }
    parsed = _parsePastedSentences(rawText);
    if(!parsed.length){
      alert('有効なデータが見つかりませんでした。');
      return;
    }
  }

  // Disable UI during processing
  if(btn){ btn.disabled = true; btn.classList.add('opacity-60','pointer-events-none'); }

  const grade = 'custom';
  const items = [];
  let translated = 0;
  let posFilled = 0;
  let failedJa = 0;

  for(let i=0;i<parsed.length;i++){
    const base = parsed[i];
    let en = normalizeTypingText(base.en).trim();
    if(!en) continue;

    en = en.replace(/\s+/g,' ').trim();

    let ja = String(base.ja || '').trim();
    let pos = String(base.pos || '').trim();

    const needsJa = !!(autoJa && !ja);

    // Word mode: 品詞が空なら、(autoPosがON) もしくは (意味を自動生成したい=needsJa) のときに品詞も埋める
    if(pasteMode==='word' && !pos && (autoPos || needsJa)){
      if(statusEl) statusEl.textContent = `品詞判定中… (${i+1}/${parsed.length})`;
      pos = await detectPosJa(en);
      if(pos) posFilled++;
    }

    // Translation
    if(needsJa){
      const src = en.length > 220 ? en.slice(0,220) : en;
      if(statusEl) statusEl.textContent = `日本語訳生成中… (${i+1}/${parsed.length})`;

      let t = '';
      if(pasteMode==='word'){
        t = await translateWordToJa(src, pos);
      }else{
        t = await translateEnToJa(src);
      }

      if(t){
        ja = t;
        translated++;
      }else{
        ja = '（要確認）';
        failedJa++;
      }
    }

    items.push({ grade, section, en, ja, pos });
  }

  if(!items.length){
    alert('有効なデータが見つかりませんでした。');
    if(btn){ btn.disabled = false; btn.classList.remove('opacity-60','pointer-events-none'); }
    if(statusEl) statusEl.textContent = '';
    return;
  }

  // Merge into allWords (update if same grade+section+en)
  const keyOf = (it)=>{
    const g = String(it.grade||'').trim();
    const sec = normalizeSectionName(it.section);
    const enKey = String(it.en||'').trim().toLowerCase();
    return `${g}||${sec}||${enKey}`;
  };

  const map = new Map();
  allWords.forEach((it, idx)=>{ map.set(keyOf(it), idx); });

  let added = 0, updated = 0;
  items.forEach((it)=>{
    const k = keyOf(it);
    if(map.has(k)){
      const idx = map.get(k);
      allWords[idx] = { ...allWords[idx], ...it };
      updated++;
    }else{
      map.set(k, allWords.length);
      allWords.push(it);
      added++;
    }
  });

  try{ localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(allWords)); }catch(e){}
  rebuildGradeMap();

  if(statusEl) statusEl.textContent = '';
  if(btn){ btn.disabled = false; btn.classList.remove('opacity-60','pointer-events-none'); }

  alert(`追加完了！
モード: ${pasteMode==='word' ? '単語' : '例文'}
追加: ${added}件 / 更新: ${updated}件
（自動訳: ${translated}件、品詞自動: ${posFilled}件` + (failedJa ? `、訳取得失敗: ${failedJa}件` : '') + `）
合計: ${allWords.length}件`);

  closePasteModal();
  location.reload();
}




/* =========================================================
   CSV Import
========================================================= */
const fileInput = document.getElementById('csv-file-input');
fileInput.addEventListener('change', (e)=>{
  const file = e.target.files[0];
  if(!file) return;

  const reader = new FileReader();
  reader.readAsArrayBuffer(file);

  reader.onload = (event)=>{
    const buffer = new Uint8Array(event.target.result);
    const detected = Encoding.detect(buffer);
    const unicodeString = Encoding.convert(buffer, {to:'UNICODE', from:detected});
    const text = Encoding.codeToString(unicodeString);

    Papa.parse(text, {
      header:false,
      skipEmptyLines:true,
      complete:(results)=>{
        const raw = results.data;
        const processed = [];
        const IDX_GRADE=1, IDX_SECTION=3, IDX_EN=4, IDX_POS=5, IDX_JA=6;

        raw.forEach((row,index)=>{
          if(index===0 && (String(row[IDX_GRADE]).includes('学年'))) return;
          if(row.length < 7) return;

          let g = String(row[IDX_GRADE]).replace('年','').trim();
          const s = String(row[IDX_SECTION]).trim();
          const en = normalizeTypingText(String(row[IDX_EN] ?? '')).trim();
          const pos = String(row[IDX_POS]).trim();
          const ja = String(row[IDX_JA]).trim();

          if(g==='カスタム' || g==='Custom' || g==='custom') g='custom';
          if(g && s && en && ja){
            processed.push({grade:g, section:s, en, ja, pos});
          }
        });

        if(processed.length>0){
          // 追記（蓄積）読み込み：既存データに追加し、同一データは更新します（重複しません）
          const keyOf = (it)=>{
            const g = String(it.grade||'').trim();
            const sec = normalizeSectionName(it.section);
            const enKey = String(it.en||'').trim().toLowerCase();
            return `${g}||${sec}||${enKey}`;
          };

          const map = new Map();
          allWords.forEach((it, idx)=>{ map.set(keyOf(it), idx); });

          let added = 0;
          let updated = 0;

          processed.forEach((it)=>{
            const k = keyOf(it);
            if(map.has(k)){
              const idx = map.get(k);
              allWords[idx] = { ...allWords[idx], ...it };
              updated++;
            }else{
              map.set(k, allWords.length);
              allWords.push(it);
              added++;
            }
          });

          localStorage.setItem(STORAGE_KEY_DATA, JSON.stringify(allWords));
          rebuildGradeMap();

          alert(`読み込み成功！
追加: ${added}件 / 更新: ${updated}件
合計: ${allWords.length}件`);
          location.reload();
        }else{
          alert("有効なデータが見つかりませんでした。");
        }
      }
    });
  };

  fileInput.value='';
});

function clearAllData(){
  if(confirm("全データを削除しますか？\n（学習データ・成績・履歴・途中経過が全部消えます）")){
    localStorage.removeItem(STORAGE_KEY_DATA);
    localStorage.removeItem(STORAGE_KEY_STATS);
    localStorage.removeItem(STORAGE_KEY_HISTORY);
    localStorage.removeItem(STORAGE_KEY_PROGRESS);
    localStorage.removeItem(STORAGE_KEY_SRS);
    localStorage.removeItem(STORAGE_KEY_SRS_LOG);
    localStorage.removeItem(STORAGE_KEY_READ_SRS);
    localStorage.removeItem(STORAGE_KEY_READ_SRS_LOG);
    localStorage.removeItem(STORAGE_KEY_QUESTION_ORDER);
    localStorage.removeItem(STORAGE_KEY_PERSONAL_BASELINE);
    location.reload();
  }
}


/* =========================================================
   CSV Room (CSV置き場)
   - browser can't list server folders automatically
   - so we load a manifest file (csv_library.json) if present
   - fallback to DEFAULT list embedded in this HTML
========================================================= */
const CSV_ROOM_MANIFEST_CANDIDATES = [
  'csv_library.json',
  'csv/csv_library.json',
  'csv_manifest.json',
  'csv/manifest.json'
];

// You can edit this default list directly if you don't want a json manifest.
const CSV_ROOM_DEFAULT_ITEMS = [
  { name: '★1年 Unit8 お試し（単語）', url: '★1年Unit8お試し.csv', desc: '1年 Unit8-1 単語（お試し）' },
  { name: 'おためし４（文/SVOCMタグ）', url: 'おためし４.csv', desc: 'SVOCMタグ付きの例文セット' },
  { name: 'サンプル（ここを編集）', url: 'sample.csv', desc: '同じフォルダに sample.csv を置くとダウンロードできます。' }
];

function normalizeCsvRoomItems(items){
  if(!Array.isArray(items)) return [];
  return items.map(it=>({
    name: String(it.name || it.title || it.label || '').trim() || 'CSV',
    url:  String(it.url || it.path || it.href || '').trim(),
    desc: String(it.desc || it.description || it.note || '').trim()
  })).filter(it=>!!it.url);
}

async function loadCsvRoomItems(){
  for(const u of CSV_ROOM_MANIFEST_CANDIDATES){
    try{
      const res = await fetch(u, { cache: 'no-store' });
      if(!res.ok) continue;
      const j = await res.json();
      const items = Array.isArray(j) ? j : (j.items || j.files || []);
      const norm = normalizeCsvRoomItems(items);
      if(norm.length) return norm;
    }catch(e){
      // ignore and fallback
    }
  }
  return normalizeCsvRoomItems(CSV_ROOM_DEFAULT_ITEMS);
}

function renderCsvRoomCards(items){
  const list = document.getElementById('csv-room-list');
  if(!list) return;
  list.innerHTML = '';

  if(!items.length){
    list.innerHTML = `<div class="p-6 rounded-2xl bg-white/10 border border-white/20 text-white/80 text-sm">
      CSV一覧がありません（csv_library.json が見つからない / または中身が空です）
    </div>`;
    return;
  }

  items.forEach((it, idx)=>{
    const card = document.createElement('div');
    card.className = 'rounded-2xl bg-white/90 border border-white/40 shadow-sm p-5 flex flex-col gap-2';
    const safeUrl = encodeURI(it.url);
    card.innerHTML = `
      <div class="flex items-start justify-between gap-3">
        <div class="min-w-0">
          <div class="text-base font-extrabold text-slate-800 truncate">${escapeHtml(it.name)}</div>
          <div class="text-xs text-slate-500 mt-0.5 break-all">${escapeHtml(it.url)}</div>
        </div>
        <a href="${escapeHtmlAttr(safeUrl)}" download
           class="shrink-0 bg-sky-600 hover:bg-sky-500 text-white px-4 py-2 rounded-xl text-sm font-extrabold active:scale-[0.99] shadow-sm">
          <i class="fas fa-download mr-1"></i>DL
        </a>
      </div>
      ${it.desc ? `<div class="text-sm text-slate-700 leading-relaxed">${escapeHtml(it.desc)}</div>` : ''}
      <div class="text-[11px] text-slate-400 mt-1">
        ※iOS Safari は「ダウンロード」ではなく「開く」挙動になることがあります
      </div>
    `;
    list.appendChild(card);
  });
}

async function renderCsvRoom(){
  const status = document.getElementById('csv-room-status');
  if(status) status.textContent = '読み込み中…';
  const items = await loadCsvRoomItems();
  renderCsvRoomCards(items);
  if(status) status.textContent = `CSV一覧：${items.length} 件`;
}

// Export current allWords as a re-importable CSV (same column mapping as CSV Import)
function exportAllWordsCsv(){
  try{
    if(!Array.isArray(allWords) || allWords.length===0){
      alert('書き出すデータがありません（先にCSV Importしてください）');
      return;
    }

    const header = ['No','学年','Unit','セクション','English','品詞','日本語'];
    const rows = [header];

    const esc = (v)=>{
      const s = String(v ?? '');
      // quote if contains comma, double-quote, LF, or CR
      if(/[",\n\r]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
      return s;
    };

    allWords.forEach((it, i)=>{
      const g = String(it.grade ?? '');
      const sec = String(it.section ?? '');
      const en = String(it.en ?? '');
      const pos = String(it.pos ?? '');
      const ja = String(it.ja ?? '');
      rows.push([String(i+1), g, '', sec, en, pos, ja]);
    });

    const csv = rows.map(r=>r.map(esc).join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    const d = new Date();
    const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    a.href = url;
    a.download = `DrakichiTyping_export_${ymd}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1500);
  }catch(e){
    console.error(e);
    alert('書き出しに失敗しました');
  }
}

/* =========================================================
   Navigation
========================================================= */
function stopConfetti(){
  const canvas = document.getElementById('confetti-canvas');
  if(canvas) canvas.classList.add('hidden');
}

/* =========================================================
   Stats View Toggle (WPM / SRS)
========================================================= */
function setStatsView(view, {skipSave=false}={}){
  statsView = (view === 'srs') ? 'srs' : 'wpm';
  if(!skipSave){
    try{ localStorage.setItem(STORAGE_KEY_STATS_VIEW, statsView); }catch(e){}
  }

  document.querySelectorAll('[data-stats-group="wpm"]').forEach(el=>{
    el.classList.toggle('hidden', statsView !== 'wpm');
  });
  document.querySelectorAll('[data-stats-group="srs"]').forEach(el=>{
    el.classList.toggle('hidden', statsView !== 'srs');
  });

  const wBtn = document.getElementById('stats-tab-wpm');
  const sBtn = document.getElementById('stats-tab-srs');
  if(wBtn && sBtn){
    const base = 'px-5 py-2 rounded-xl text-sm font-extrabold transition';
    wBtn.className = base + (statsView==='wpm'
      ? ' bg-sky-600 text-white shadow-sm'
      : ' bg-white text-slate-600 hover:bg-slate-50');
    sBtn.className = base + (statsView==='srs'
      ? ' bg-indigo-600 text-white shadow-sm'
      : ' bg-white text-slate-600 hover:bg-slate-50');
  }

  const sc = document.getElementById("stats-scroll"); if(sc) sc.scrollTop = 0;

  // redraw visible charts after layout
  requestAnimationFrame(()=>{
    if(statsView==='wpm'){
      // Global WPM Chart (no grade/section filter)
      updateSpeedJobDisplay();
      updateSrsJobDisplay();
      const god = loadGodMaster();
      if(god.unlocked){
        document.getElementById("godmaster-card")?.classList.remove("hidden");
      }
      const limit = parseInt(document.getElementById('chart-range')?.value || '30', 10);
      const showMA = !!document.getElementById('chart-ma-toggle')?.checked;
      const maWin = parseInt(document.getElementById('chart-ma-window')?.value || '5', 10);
      renderWpmChartAllModes(limit, showMA, maWin);
      
      const hLim = parseInt(document.getElementById('wpm-hist-limit')?.value || '50', 10);
      renderWpmHistoryTable(hLim);
    }else{
      redrawSrsCharts();
    }
  });
}

function applySrsModeButtonStyles(){
  const btnN = document.getElementById('srs-mode-normal');
  const btnH = document.getElementById('srs-mode-hard');
  const btnE = document.getElementById('srs-mode-extra');
  if(!btnN || !btnH || !btnE) return;

  const base = 'px-4 py-2 rounded-xl text-sm font-extrabold transition';
  const onN = (currentSrsMode==='normal');
  const onH = (currentSrsMode==='hard');
  const onE = (currentSrsMode==='extra');

  btnN.className = base + (onN ? ' bg-emerald-600 text-white shadow-sm' : ' bg-white text-slate-600 hover:bg-slate-50');
  btnH.className = base + (onH ? ' bg-orange-600 text-white shadow-sm' : ' bg-white text-slate-600 hover:bg-slate-50');
  btnE.className = base + (onE ? ' bg-pink-600 text-white shadow-sm' : ' bg-white text-slate-600 hover:bg-slate-50');
}

function setSrsMode(mode, {skipSave=false}={}){
  currentSrsMode = (mode==='hard') ? 'hard' : (mode==='extra' ? 'extra' : 'normal');
  applySrsModeButtonStyles();
  if(!skipSave){
    try{ localStorage.setItem(STORAGE_KEY_SRS_MODE, currentSrsMode); }catch(e){}
  }
  if(statsView==='srs') redrawSrsCharts();
}

function initSrsModeTabs(){
  const btnN = document.getElementById('srs-mode-normal');
  const btnH = document.getElementById('srs-mode-hard');
  const btnE = document.getElementById('srs-mode-extra');
  if(!btnN || !btnH || !btnE) return;

  btnN.onclick = ()=>setSrsMode('normal');
  btnH.onclick = ()=>setSrsMode('hard');
  btnE.onclick = ()=>setSrsMode('extra');

  let saved = 'normal';
  try{ saved = localStorage.getItem(STORAGE_KEY_SRS_MODE) || 'normal'; }catch(e){}
  setSrsMode(saved, {skipSave:true});
}

function initSrsDeckTabs(){
  const tBtn = document.getElementById('srs-deck-typing');
  const rBtn = document.getElementById('srs-deck-reading');
  if(!tBtn || !rBtn) return;

  const setDeck = (d, opt={})=>{
    currentSrsDeck = d;
    // style
    [tBtn,rBtn].forEach(b=>{ b.classList.remove('bg-slate-900','text-white'); b.classList.add('text-slate-600'); });
    const active = (d==='reading') ? rBtn : tBtn;
    active.classList.add('bg-slate-900','text-white');
    active.classList.remove('text-slate-600');

    // タイトルテキストを少し分かりやすく
    const head1 = document.querySelector('[data-stats-group="srs"] .fa-layer-group');
    if(head1){ /* no-op */ }

    if(!opt.skipSave){
      try{ localStorage.setItem(STORAGE_KEY_STATS_SRS_DECK, d); }catch(e){}
    }
    redrawSrsCharts();
  };

  tBtn.onclick = ()=>setDeck('typing');
  rBtn.onclick = ()=>setDeck('reading');

  let saved = 'typing';
  try{ saved = localStorage.getItem(STORAGE_KEY_STATS_SRS_DECK) || 'typing'; }catch(e){}
  if(saved!=='typing' && saved!=='reading') saved='typing';

  setDeck(saved, {skipSave:true});
}



function getActiveSrsLog(){
  return (currentSrsDeck==='reading') ? (Array.isArray(readSrsLog)?readSrsLog:[]) : (Array.isArray(srsLog)?srsLog:[]);
}
function getActiveSrsData(){
  return (currentSrsDeck==='reading') ? (readSrsData||{}) : (srsData||{});
}
function deckDisplay(){
  return (currentSrsDeck==='reading') ? 'Reading SRS' : 'Typing SRS';
}

function redrawSrsCharts(){
  const months = parseInt(document.getElementById('review-range')?.value || '24', 10);
  const lines  = !!document.getElementById('review-lines-toggle')?.checked;
  renderReviewCountChart(currentSrsMode, months, lines);

  const dg   = document.getElementById('due-grade')?.value || 'all';
  const days = parseInt(document.getElementById('due-days')?.value || '30', 10);
  const inc  = !!document.getElementById('due-overdue-toggle')?.checked;
  renderDueForecastChart(dg, currentSrsMode, days, inc);

  // ▼ 追加部分（Deckに連動）
  renderFSRSDistributions(document.getElementById('fsrs-dist-grade')?.value, document.getElementById('fsrs-dist-mode')?.value);
  renderHeatmap(document.getElementById('heatmap-grade')?.value, document.getElementById('heatmap-mode')?.value);

  // Deckラベル
  try{
    const el = document.getElementById('srs-deck-note');
    if(el) el.textContent = deckDisplay();
  }catch(e){}
}



function initStatsTabs(){
  const wBtn = document.getElementById('stats-tab-wpm');
  const sBtn = document.getElementById('stats-tab-srs');
  if(!wBtn || !sBtn) return;

  wBtn.onclick = ()=>setStatsView('wpm');
  sBtn.onclick = ()=>setStatsView('srs');

  let saved = 'wpm';
  try{ saved = localStorage.getItem(STORAGE_KEY_STATS_VIEW) || 'wpm'; }catch(e){}
  setStatsView(saved, {skipSave:true});
}

function goToScreen(screenName){
  try{ stopReadingRecognition(); }catch(e){}
  hideRewardOverlay();
  stopConfetti();

  screens.forEach(s=>document.getElementById(`screen-${s}`).classList.add('hidden'));
  const target = document.getElementById(`screen-${screenName}`);
  target.classList.remove('hidden');
  target.classList.remove('anim-fade-in');
  void target.offsetWidth;
  target.classList.add('anim-fade-in');

  // Stats scroll fix (iOS): let outer container scroll on stats screen
  const app = document.getElementById('app-container');
  const main = document.getElementById('main-content');
  if(app && main){
    if(screenName==='stats'){
      app.classList.add('stats-root-scroll');
      main.classList.add('stats-main-visible');
      app.scrollTop = 0;
    }else{
      app.classList.remove('stats-root-scroll');
      main.classList.remove('stats-main-visible');
      app.scrollTop = 0;
    }
  }

  // BGM control (Title on Grade, Section BGM on Section/Settings, Stats BGM on Stats)
  if(screenName==='grade' || screenName==='csvroom') playBgm('title');
  else if(screenName==='section' || screenName==='settings') playBgm('section');
  else if(screenName==='stats') playBgm('stats');
  else stopBgm();

  if(screenName==='grade'){
    backBtn.classList.add('hidden');
    ctrlArea.classList.remove('hidden');
  }else if(screenName==='csvroom'){
backBtn.classList.remove('hidden');
backLabel.textContent="Home";
backBtn.onclick=()=>goToScreen('grade');
ctrlArea.classList.remove('hidden');
renderCsvRoom();
  }else if(screenName==='section'){
    backBtn.classList.remove('hidden');
    backLabel.textContent="Grades";
    backBtn.onclick=()=>goToScreen('grade');
    ctrlArea.classList.remove('hidden');
    if(currentSettings.grade) renderSectionList(currentSettings.grade);
  }else if(screenName==='settings'){
    backBtn.classList.remove('hidden');
    backLabel.textContent="Sections";
    backBtn.onclick=()=>goToScreen('section');
    ctrlArea.classList.remove('hidden');
    updateResumeHint();
    updateSrsPanel();
    updateReadingModeUI();
    const q = document.getElementById('question-order');
    if(q) q.value = currentSettings.questionOrder || 'random';
  }else if(screenName==='practice'){
    backBtn.classList.remove('hidden');
    backLabel.textContent="Quit";
    backBtn.onclick=()=>{
      if(confirm("学習を終了しますか？（途中経過は保存されます）")){
        if(sessionInterval) clearInterval(sessionInterval); // タイマー停止
        checkStudyReward(); // ここまでの学習時間を保存
        goToScreen('settings');
      }
    };
    ctrlArea.classList.add('hidden');
    applyPracticeInputModeUI();
  }else if(screenName==='result'){
    backBtn.classList.add('hidden');
       // iOS対策: 結果画面でも戻るボタンを表示（レイアウト崩れでボタンが押せない場合の保険）
    backBtn.classList.remove('hidden');
    backLabel.textContent="Back";
    backBtn.onclick=()=>goToScreen('section');
    ctrlArea.classList.add('hidden');
  }else if(screenName==='stats'){
    const sc = document.getElementById("stats-scroll"); if(sc) sc.scrollTop = 0;
    renderStatsList();
    setupChartSelectors();
    initSrsModeTabs();
    initSrsDeckTabs();
    setupReviewChartSelectors();
    setupDueForecastSelectors();
    setupSRSNewSelectors(); // ▼ これを追加
    initStatsTabs();

    // Force redraw after layout (iOS Safari can report 0 widths on first frame)
    setTimeout(()=>{ try{ setStatsView(statsView, {skipSave:true}); }catch(e){} }, 80);
    setTimeout(()=>{ try{ setStatsView(statsView, {skipSave:true}); }catch(e){} }, 280);

    backBtn.classList.remove('hidden');
    backLabel.textContent="Home";
    backBtn.onclick=()=>goToScreen('grade');
    ctrlArea.classList.add('hidden');
  }
}

window.selectGrade = function(g){
  if(allWords.length===0) return;
  currentSettings.grade = g;
  renderSectionList(g);
  goToScreen('section');
};

window.selectSection = function(sec){
  currentSettings.section = sec;
  document.getElementById('selected-section-label').textContent = sec;
  goToScreen('settings');
};

window.selectSrsReview = function(mode){
  // SRS復習：この学年の「全セクション」から、指定モード( Standard/Recall/Challenge )だけを抽出して復習
  currentSettings.section = '__ALL__';
  currentSettings.srsReviewOnly = true;

  // set mode button highlight if available
  if(typeof window.selectMode === 'function'){
    window.selectMode(mode);
  }else{
    currentSettings.mode = mode;
  }

  const tgl = document.getElementById('srs-review-toggle');
  if(tgl) tgl.checked = true;

  const modeLabel = (mode==='normal') ? 'Normal' : (mode==='hard' ? 'Hard' : 'Ex-Hard');
  const lbl = document.getElementById('selected-section-label');
  if(lbl) lbl.textContent = `SRS 復習（全セクション / ${modeLabel}）`;

  goToScreen('settings');
};


window.selectReadingSrsReview = function(mode){
  // 音読SRS復習：この学年の「全セクション」から、音読SRS(別デッキ)の期限(due)だけを復習
  currentSettings.section = '__ALL__';
  currentSettings.srsReviewOnly = true;
  currentSettings.readingMode = true; // 音読モードON（=音読SRSを使う）

  if(typeof window.selectMode === 'function'){
    window.selectMode(mode);
  }else{
    currentSettings.mode = mode;
  }

  const tgl = document.getElementById('srs-review-toggle');
  if(tgl) tgl.checked = true;

  const r = document.getElementById('reading-mode-toggle');
  if(r) r.checked = true;

  const modeLabel = (mode==='normal') ? 'Normal' : (mode==='hard' ? 'Hard' : 'Ex-Hard');
  const lbl = document.getElementById('selected-section-label');
  if(lbl) lbl.textContent = `音読SRS 復習（全セクション / ${modeLabel}）`;

  goToScreen('settings');
};



function renderSectionList(grade){
  const container = document.getElementById('section-list-container');
  container.innerHTML='';

  const gradeLabel = (grade==='custom') ? 'Custom' : `Grade ${grade}`;
  document.getElementById('selected-grade-label').textContent = gradeLabel;

  if(!gradeMap[grade]){
    container.innerHTML = '<p class="text-gray-400 col-span-full text-center py-10">データがありません</p>';
    return;
  }

  const sections = Array.from(gradeMap[grade]).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true,sensitivity:'base'}));

  // ===== SRS復習（全セクション統合・モード別）=====
  // 「この学年の全セクション」から、モード別に期限(due)の問題だけを集めて復習できます。
  const makeSrsModeCard = (mode, title, borderCls, numCls, iconHtml)=>{
    const info = countSrsForGradeMode(grade, mode);
    const card = document.createElement('div');
    card.className = `
      relative bg-white border-2 rounded-2xl shadow-sm transition-all cursor-pointer group
      min-h-[170px] ${borderCls} hover:shadow-md
    `;
    card.onclick = ()=>window.selectSrsReview(mode);
    card.innerHTML = `
      <div class="p-4 flex flex-col h-full justify-between">
        <div class="flex items-start justify-between gap-2">
          <span class="text-lg font-extrabold ${numCls} group-hover:opacity-90 transition block truncate">
            ${iconHtml} SRS 復習（${title}）
          </span>
          <span class="text-[10px] font-bold bg-slate-50 text-slate-600 border border-slate-200 px-2 py-1 rounded-full whitespace-nowrap">
            全セクション統合
          </span>
        </div>
        <div class="mt-3 bg-slate-50 p-3 rounded-lg">
          <div class="text-[11px] font-bold text-slate-500 text-center">期限(due) / 登録数</div>
          <div class="mt-2 text-center ${numCls} font-mono font-extrabold text-2xl">
            ${info.due}<span class="text-slate-400 font-mono font-bold text-base"> / ${info.total}</span>
          </div>
          <div class="text-[10px] text-slate-400 mt-1 text-center">
            ※このモードだけ（Normal/Hard/Ex-Hard は別デッキ）
          </div>
        </div>
      </div>
    `;
    container.appendChild(card);
  };

  makeSrsModeCard('normal','Normal','border-sky-300 hover:border-sky-500','text-sky-700','<i class="fas fa-book mr-2"></i>');
  makeSrsModeCard('hard','Hard','border-orange-300 hover:border-orange-500','text-orange-700','<i class="fas fa-headphones mr-2"></i>');
  makeSrsModeCard('extra','Ex-Hard','border-rose-300 hover:border-rose-500','text-rose-700','<i class="fas fa-bullseye mr-2"></i>');


  // ===== 音読SRS復習（全セクション統合・モード別）=====
  const readHead = document.createElement('div');
  readHead.className = 'col-span-full md:col-span-2 lg:col-span-3 mt-2 mb-1 px-1';
  readHead.innerHTML = `
    <div class="bg-white/85 backdrop-blur border border-white/40 rounded-2xl p-4 shadow-sm">
      <div class="text-sm font-extrabold text-slate-700">
        <i class="fas fa-microphone-alt mr-2 text-indigo-600"></i>音読SRS 復習（できた / わからない）
      </div>
      <div class="text-xs text-slate-500 mt-1">
        ※音読専用SRSはタイピングSRSと別デッキ。Ex-Hardは音声が流れません。
      </div>
    </div>
  `;
  container.appendChild(readHead);

  const makeReadSrsModeCard = (mode, title, borderCls, numCls, iconHtml)=>{
    const info = countReadSrsForGradeMode(grade, mode);
    const card = document.createElement('div');
    card.className = `
      relative bg-white border-2 rounded-2xl shadow-sm transition-all cursor-pointer group
      min-h-[170px] ${borderCls} hover:shadow-md
    `;
    card.onclick = ()=>window.selectReadingSrsReview(mode);
    card.innerHTML = `
      <div class="p-4 flex flex-col h-full justify-between">
        <div class="flex items-start justify-between gap-2">
          <span class="text-lg font-extrabold ${numCls} group-hover:opacity-90 transition block truncate">
            ${iconHtml} 音読SRS 復習（${title}）
          </span>
          <span class="text-[10px] font-bold bg-slate-50 text-slate-600 border border-slate-200 px-2 py-1 rounded-full whitespace-nowrap">
            全セクション統合
          </span>
        </div>
        <div class="mt-3 bg-slate-50 p-3 rounded-lg">
          <div class="text-[11px] font-bold text-slate-500 text-center">期限(due) / 登録数</div>
          <div class="mt-2 text-center ${numCls} font-mono font-extrabold text-2xl">
            ${info.due}<span class="text-slate-400 font-mono font-bold text-base"> / ${info.total}</span>
          </div>
          <div class="text-[10px] text-slate-400 mt-1 text-center">
            ※このモードだけ（Normal/Hard/Ex-Hard は別デッキ）
          </div>
        </div>
      </div>
    `;
    container.appendChild(card);
  };

  makeReadSrsModeCard('normal','Normal','border-indigo-300 hover:border-indigo-500','text-indigo-700','<i class="fas fa-microphone mr-2"></i>');
  makeReadSrsModeCard('hard','Hard','border-purple-300 hover:border-purple-500','text-purple-700','<i class="fas fa-microphone mr-2"></i>');
  makeReadSrsModeCard('extra','Ex-Hard','border-fuchsia-300 hover:border-fuchsia-500','text-fuchsia-700','<i class="fas fa-user-ninja mr-2"></i>');


  sections.forEach(sec=>{
    const targets = allWords.filter(w=>w.grade===grade && w.section.includes(sec));
    const total = targets.length;

    const key = keyFor(grade, sec);
    const stat = statsData[key] || {normal:{score:0,wpm:0},hard:{score:0,wpm:0},extra:{score:0,wpm:0}};

    const isFullClear = total>0 &&
      stat.normal.score>=total &&
      stat.hard.score>=total &&
      stat.extra.score>=total;

    const getLine = (label, s, totalCount)=>{
      const cleared = (s.score>=totalCount && totalCount>0);
      const crown = cleared ? '<i class="fas fa-crown text-yellow-500 ml-1"></i>' : '';
      const wpm = (s.wpm>0) ? `<span class="ml-2 text-[10px] opacity-75 font-mono">${s.wpm}wpm</span>` : '';
      const color = cleared ? 'text-sky-600 font-extrabold' : 'text-slate-500';
      return `
        <div class="grid grid-cols-[3.5rem_1fr] items-center gap-2 text-[11px] leading-5">
          <span class="font-extrabold text-slate-400">${label}</span>
          <div class="${color} text-right overflow-hidden text-ellipsis whitespace-nowrap">
            ${s.score}/${totalCount}${crown}${wpm}
          </div>
        </div>
      `;
    };

    const card = document.createElement('div');
    card.className = `
      relative bg-white border-2 rounded-2xl shadow-sm transition-all cursor-pointer group
      min-h-[170px]
      ${isFullClear ? 'border-yellow-300 full-clear-glow' : 'border-slate-200 hover:border-sky-400 hover:shadow-md'}
    `;
    card.onclick = ()=>selectSection(sec);

    card.innerHTML = `
      <div class="p-4 flex flex-col h-full justify-between">
        <div class="flex items-start justify-between gap-2">
          <span class="text-lg font-bold text-slate-700 group-hover:text-sky-600 transition block truncate">${sec}</span>
          ${isFullClear ? '<span class="text-[10px] font-bold bg-yellow-100 text-yellow-700 border border-yellow-200 px-2 py-1 rounded-full whitespace-nowrap">FULL CLEAR</span>' : ''}
        </div>
        <div class="mt-3 space-y-1 bg-slate-50 p-2 rounded-lg">
          ${getLine('Norm', stat.normal, total)}
          ${getLine('Hard', stat.hard, total)}
          ${getLine('Ex-Hard', stat.extra, total)}
        </div>
      </div>
    `;
    container.appendChild(card);
  });
}

/* =========================================================
   Settings
========================================================= */
window.selectMode = function(m){
    currentSettings.mode = m;
  document.querySelectorAll('.mode-btn').forEach(btn=>{
    btn.className = "mode-btn p-4 rounded-xl border-2 border-slate-200 text-slate-500 font-bold text-center transition hover:shadow-md bg-white";
  });
  const active = document.getElementById(`btn-mode-${m}`);
  const colors = {normal:'sky', hard:'orange', extra:'rose'};
  const c = colors[m];
  active.className = `mode-btn p-4 rounded-xl border-2 border-${c}-500 bg-${c}-50 text-${c}-700 font-bold text-center transition ring-2 ring-${c}-500 ring-offset-2 hover:shadow-md transform scale-[1.03]`;
  updateResumeHint();
  updateSrsPanel();
  updateReadingModeUI();
  try{ if(currentSettings && currentSettings.readingMode) updateAnswerPeekUI(currentTargetPlain); }catch(e){}
};

document.getElementById('time-slider').addEventListener('input',(e)=>{
  currentSettings.timeLimitMin = parseInt(e.target.value,10);
  document.getElementById('time-val-display').innerHTML = `${currentSettings.timeLimitMin} <span class="text-sm">min</span>`;
});

const qOrderEl = document.getElementById('question-order');
if(qOrderEl){
  // init UI from current state
  try{ qOrderEl.value = currentSettings.questionOrder || 'random'; }catch(e){}
  qOrderEl.addEventListener('change',(e)=>{
    const v = (e.target.value==='registered') ? 'registered' : 'random';
    currentSettings.questionOrder = v;
    try{ localStorage.setItem(STORAGE_KEY_QUESTION_ORDER, v); }catch(err){}
  });
}

document.getElementById('sfx-type-toggle').addEventListener('change',(e)=>{
  currentSettings.sfxType = !!e.target.checked;
});
document.getElementById('sfx-coin-toggle').addEventListener('change',(e)=>{
  currentSettings.sfxCoin = !!e.target.checked;
});
document.getElementById('sfx-clear-toggle').addEventListener('change',(e)=>{
  currentSettings.sfxClear = !!e.target.checked;
});

document.getElementById('srs-review-toggle').addEventListener('change',(e)=>{
  currentSettings.srsReviewOnly = !!e.target.checked;
});

const readingToggleEl = document.getElementById('reading-mode-toggle');
if(readingToggleEl){
  readingToggleEl.addEventListener('change',(e)=>{
    currentSettings.readingMode = !!e.target.checked;
    /* readingMode is not persisted */
    updateReadingModeUI();
  });
}

function updateReadingModeUI(){
  const t = document.getElementById('reading-mode-toggle');
  if(t) t.checked = !!currentSettings.readingMode;

  const note = document.getElementById('reading-mode-note');
  if(note) note.classList.toggle('hidden', !currentSettings.readingMode);
  try{ updateReadingBadges(); }catch(e){}
}

function applyPracticeInputModeUI(){
  const panel = document.getElementById('speech-panel');
  const micBtn = document.getElementById('speech-mic-btn');
  const input = document.getElementById('practice-input');
  const okBtn = document.getElementById('reading-ok-btn');

  if(currentSettings.readingMode){
    if(panel) panel.classList.remove('hidden');
    if(micBtn) micBtn.classList.remove('hidden');
    if(okBtn) okBtn.classList.remove('hidden');
    if(input){
      input.value = '';
      input.disabled = true;
      try{ input.blur(); }catch(e){}
    }
    resetSpeechPanel();

  try{ updateAnswerPeekUI(currentTargetPlain); }catch(e){}
  }else{
    if(panel) panel.classList.add('hidden');
    if(micBtn) micBtn.classList.add('hidden');
    if(okBtn) okBtn.classList.add('hidden');
    if(input){
      input.disabled = false;
    }
    stopReadingRecognition();
  }
}



function updateResumeHint(){
  const hint = document.getElementById('resume-hint');
  const k = keyForMode(currentSettings.grade, currentSettings.section, currentSettings.mode);
  const has = !!progressData[k];
  hint.classList.toggle('hidden', !has);
}


/* =========================================================
   SRS (Anki-like, auto grading)
   - Keyed per (grade, section, mode, en)
   - Automatic judgment:
     * mistake -> Again
     * pause >= 1.2s OR too slow vs baseline -> Hard
     * else -> Good
   - Scheduling (simple SM-2-like):
     * Good: interval *= ease (new -> 1d)
     * Hard: interval *= ease * 0.6 (new -> 0.6d)
     * Again: relearn (10min)
========================================================= */
function srsKey(grade, sectionKey, mode, en){
  return `${grade}||${sectionKey}||${mode}||${en}`;
}


// Index existing SRS cards so ALL-sections review can still find cards even if section labels changed.
let srsKeyIndex = null; // Map: `${grade}||${mode}||${en}` -> [sectionKey,...]
function rebuildSrsKeyIndex(){
  const m = new Map();
  for(const k of Object.keys(srsData||{})){
    if(typeof k !== 'string') continue;
    const parts = k.split('||');
    if(parts.length < 4) continue;
    const g = parts[0];
    const sec = parts[1];
    const mode = parts[2];
    const en = parts.slice(3).join('||');
    const idxKey = `${g}||${mode}||${en}`;
    if(!m.has(idxKey)) m.set(idxKey, []);
    m.get(idxKey).push(sec);
  }
  srsKeyIndex = m;
}
function ensureSrsKeyIndex(){
  if(!srsKeyIndex) rebuildSrsKeyIndex();
}

function resolveExistingSrsKey(item, mode=currentSettings.mode){
  const g = String(item.grade);
  const en = plainEnOf(item);
  const secPrimary = srsSectionKeyForItem(item);
  const kPrimary = srsKey(g, secPrimary, mode, en);
  if(srsData && srsData[kPrimary]) return kPrimary;

  // Only try fallback in ALL-sections review.
  if(currentSettings.section !== '__ALL__') return kPrimary;

  ensureSrsKeyIndex();
  const idxKey = `${g}||${mode}||${en}`;
  const secs = srsKeyIndex.get(idxKey);
  if(!secs || !secs.length) return kPrimary;

  const itemSec = normalizeSectionName(item.section);
  let best = null, bestScore = -1;
  for(const sec of secs){
    const s = String(sec||'');
    let score = 0;
    if(s === itemSec) score = 3;
    else if(itemSec.includes(s)) score = 2;
    else if(s.includes(itemSec)) score = 1;
    if(score > bestScore){ bestScore = score; best = s; }
  }

  if(best && bestScore >= 1){
    const k = srsKey(g, best, mode, en);
    if(srsData && srsData[k]) return k;
  }
  return kPrimary;
}



// Resolve SRS key for an item as if we were in ALL-sections mode (does not depend on currentSettings.section).
function resolveExistingSrsKeyAll(item, mode=currentSettings.mode){
  const g = String(item.grade);
  const en = plainEnOf(item);
  const itemSec = normalizeSectionName(item.section);
  const kPrimary = srsKey(g, itemSec, mode, en);
  if(srsData && srsData[kPrimary]) return kPrimary;

  ensureSrsKeyIndex();
  const idxKey = `${g}||${mode}||${en}`;
  const secs = srsKeyIndex.get(idxKey);
  if(!secs || !secs.length) return kPrimary;

  let best = null, bestScore = -1;
  for(const sec of secs){
    const s = String(sec||'');
    let score = 0;
    if(s === itemSec) score = 3;
    else if(itemSec.includes(s)) score = 2;
    else if(s.includes(itemSec)) score = 1;
    if(score > bestScore){ bestScore = score; best = s; }
  }

  if(best && bestScore >= 1){
    const k = srsKey(g, best, mode, en);
    if(srsData && srsData[k]) return k;
  }
  return kPrimary;
}

// Section key used for SRS.
// - In a specific section: use the selected section key
// - In ALL-sections review: use the item's real section (normalized)
function srsSectionKeyForItem(item){
  if(currentSettings.section==='__ALL__'){
    return normalizeSectionName(item.section);
  }
  return currentSettings.section;
}

function srsKeyForItem(item, mode=currentSettings.mode){
  return resolveExistingSrsKey(item, mode);
}

function getSrsCard(item, mode=currentSettings.mode){
  const k = srsKeyForItem(item, mode);
  return srsData[k] || null;
}

function ensureSrsCard(item, mode=currentSettings.mode){
  const k = srsKeyForItem(item, mode);
  if(!srsData[k]){
    // FSRS v6 fields: difficulty(D), stability(S), state, dueTs, lastReviewTs, lapses, reps
    // Fallback for old data is handled in applySrsResult or migration
    srsData[k] = { 
      state:'new', 
      difficulty:0, 
      stability:0, 
      intervalDays:0, 
      dueTs:0, 
      lapses:0, 
      reps:0,
      lastReviewTs:0 
    };
    srsKeyIndex = null; // mark index dirty

  }
  return srsData[k];
}

/* =========================================================
   Read SRS (音読専用デッキ)  ※タイピングSRSとは別保存
========================================================= */
function rebuildReadSrsKeyIndex(){
  const m = new Map();
  for(const k in (readSrsData||{})){
    if(!k || typeof k !== 'string') continue;
    const parts = k.split('||');
    if(parts.length < 4) continue;
    const g = parts[0], mode = parts[2], en = parts.slice(3).join('||');
    const sec = parts[1] || '';
    const idxKey = `${g}||${mode}||${en}`;
    if(!m.has(idxKey)) m.set(idxKey, []);
    m.get(idxKey).push(sec);
  }
  readSrsKeyIndex = m;
}
function ensureReadSrsKeyIndex(){
  if(!readSrsKeyIndex) rebuildReadSrsKeyIndex();
}

function resolveExistingReadSrsKey(item, mode=currentSettings.mode){
  const g = String(item.grade);
  const en = plainEnOf(item);
  const secPrimary = srsSectionKeyForItem(item);
  const kPrimary = srsKey(g, secPrimary, mode, en);
  if(readSrsData && readSrsData[kPrimary]) return kPrimary;

  // Only try fallback in ALL-sections review.
  if(currentSettings.section !== '__ALL__') return kPrimary;

  ensureReadSrsKeyIndex();
  const idxKey = `${g}||${mode}||${en}`;
  const secs = readSrsKeyIndex.get(idxKey);
  if(!secs || !secs.length) return kPrimary;

  const itemSec = normalizeSectionName(item.section);
  let best = null, bestScore = -1;
  for(const sec of secs){
    const s = String(sec||'');
    let score = 0;
    if(s === itemSec) score = 3;
    else if(itemSec.includes(s)) score = 2;
    else if(s.includes(itemSec)) score = 1;
    if(score > bestScore){ bestScore = score; best = s; }
  }
  if(best && bestScore >= 1){
    const k = srsKey(g, best, mode, en);
    if(readSrsData && readSrsData[k]) return k;
  }
  return kPrimary;
}

// Resolve key as if ALL-sections mode (does not depend on currentSettings.section)
function resolveExistingReadSrsKeyAll(item, mode=currentSettings.mode){
  const g = String(item.grade);
  const en = plainEnOf(item);
  const itemSec = normalizeSectionName(item.section);
  const kPrimary = srsKey(g, itemSec, mode, en);
  if(readSrsData && readSrsData[kPrimary]) return kPrimary;

  ensureReadSrsKeyIndex();
  const idxKey = `${g}||${mode}||${en}`;
  const secs = readSrsKeyIndex.get(idxKey);
  if(!secs || !secs.length) return kPrimary;

  let best = null, bestScore = -1;
  for(const sec of secs){
    const s = String(sec||'');
    let score = 0;
    if(s === itemSec) score = 3;
    else if(itemSec.includes(s)) score = 2;
    else if(s.includes(itemSec)) score = 1;
    if(score > bestScore){ bestScore = score; best = s; }
  }
  if(best && bestScore >= 1){
    const k = srsKey(g, best, mode, en);
    if(readSrsData && readSrsData[k]) return k;
  }
  return kPrimary;
}

function readSrsKeyForItem(item, mode=currentSettings.mode){
  return resolveExistingReadSrsKey(item, mode);
}

function getReadSrsCard(item, mode=currentSettings.mode){
  const k = readSrsKeyForItem(item, mode);
  return readSrsData[k] || null;
}

function ensureReadSrsCard(item, mode=currentSettings.mode){
  const k = readSrsKeyForItem(item, mode);
  if(!readSrsData[k]){
    readSrsData[k] = {
      state:'new',
      difficulty:0,
      stability:0,
      intervalDays:0,
      dueTs:0,
      lapses:0,
      reps:0,
      lastReviewTs:0
    };
    readSrsKeyIndex = null;
  }
  return readSrsData[k];
}

function isReadDue(item, mode=currentSettings.mode){
  const k = readSrsKeyForItem(item, mode);
  const card = readSrsData[k];
  if(!card) return false;
  return (card.dueTs||0) > 0 && (card.dueTs <= nowTs());
}

// Count due/total cards across ALL sections within a grade for a given mode (音読SRS).
function countReadSrsForGradeMode(grade, mode){
  const g = String(grade);
  const now = nowTs();
  let due = 0;
  let total = 0;
  for(const it of (allWords||[])){
    if(String(it.grade) !== g) continue;
    const k = resolveExistingReadSrsKeyAll(it, mode);
    const card = readSrsData[k];
    if(!card) continue;
    total++;
    if((card.dueTs||0) > 0 && (card.dueTs <= now)) due++;
  }
  return {due, total};
}

function nowTs(){ return Date.now(); }
function daysToMs(d){ return d * 24 * 60 * 60 * 1000; }

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

/* =========================================================
   FSRS v6 (JS Implementation)
   - Desired Retention: 0.9
   - Parameters: Default weights (v5/v6 generator standard)
========================================================= */
const FSRS = {
  p: {
    w: [0.40255, 1.18385, 3.173, 15.69105, 7.19605, 2.19518, 0.0062, 0.56175, 0.7152, 0.18028, 1.05705, 2.35284, 0.03224, 0.3424, 0.73975, 0.02272, 0.65405, 0.08386, 0.04],
    request_retention: 0.9,
    max_interval: 36500
  },

  // Rating: 1=Again, 2=Hard, 3=Good, 4=Easy
  calculate(card, rating, now) {
    // Migration / Initialization
    if (typeof card.stability === 'undefined') {
      // Fallback from SM-2
      card.stability = card.intervalDays || 0;
      // Map ease(1.3-3.0) to D(1-10). Lower ease = Higher D.
      // ease=2.5 -> D=5 approx.
      const oldEase = card.ease || 2.5;
      card.difficulty = clamp(((3.0 - oldEase) / 1.7) * 9 + 1, 1, 10);
      card.reps = 0;
    }

    const lastDate = card.lastReviewTs || card.dueTs || now;
    const elapsedDays = Math.max(0, (now - lastDate) / 86400000);
    
    let retrievability = 0;
    if (card.state === 'new') {
      retrievability = 0;
    } else if (card.stability > 0) {
      // R = (1 + factor * t / S)^-1. For R=0.9 at t=S, factor = 1/0.9 - 1 = 0.111...
      const factor = 19/81; // FSRS v5 constant for R=0.9
      retrievability = Math.pow(1 + factor * (elapsedDays / card.stability), -1);
    }

    // Update D
    // D_0 = w4 - (rating-3)*w5
    // D_new = D_prev - w6*(rating-3)
    // Mean reversion: w7*D_0(3) + (1-w7)*D_new
    let nextD = card.difficulty;
    if (card.state === 'new') {
      nextD = this.p.w[4] - (rating - 3) * this.p.w[5];
    } else {
      nextD = nextD - this.p.w[6] * (rating - 3);
    }
    nextD = clamp(nextD, 1, 10);
    // Mean reversion
    const d0_3 = this.p.w[4] - (3 - 3) * this.p.w[5]; // D0 for Good
    nextD = this.p.w[7] * d0_3 + (1 - this.p.w[7]) * nextD;

    // Update S
    let nextS = card.stability;
    if (card.state === 'new') {
      nextS = this.p.w[rating - 1];
    } else if (rating === 1) {
      // Forget (Again)
      // S_new = w11 * D^-w12 * ((S+1)^w13 - 1) * exp((1-R)*w14)
      nextS = this.p.w[11] * Math.pow(nextD, -this.p.w[12]) * (Math.pow(card.stability + 1, this.p.w[13]) - 1) * Math.exp((1 - retrievability) * this.p.w[14]);
    } else {
      // Review (Hard/Good/Easy)
      // S_new = S * (1 + exp(w8) * (11-D) * S^-w9 * (exp((1-R)*w10) - 1))
      // Hard penalty: w15 (if rating=2) -> w15 is used in v5? 
      // Standard v5 formula handles rating via D update, but some variants use hard penalty.
      // Using standard v5 formula:
      const rFunc = Math.exp((1 - retrievability) * this.p.w[10]) - 1;
      const y = 1 + Math.exp(this.p.w[8]) * (11 - nextD) * Math.pow(card.stability, -this.p.w[9]) * rFunc;
      nextS = card.stability * y;
      
      // Hard penalty (optional in some implementations, but standard v5 uses w15/w16 for different things? 
      // Actually w15/w16 are for "short term" in some versions. 
      // Let's stick to the core formula. If rating is Hard, D increases, which naturally reduces future S growth.
    }
    nextS = Math.max(0.1, Math.min(nextS, 36500));

    // Next Interval
    // If desired retention is 0.9, Interval = S.
    let nextIvl = nextS;
    // If request_retention != 0.9, adjust: I = S * (9 * (1/r - 1))
    if (this.p.request_retention !== 0.9) {
      nextIvl = nextS * 9 * (1 / this.p.request_retention - 1);
    }
    nextIvl = Math.max(1, Math.min(Math.round(nextIvl), this.p.max_interval));

    return {
      difficulty: nextD,
      stability: nextS,
      interval: nextIvl
    };
  }
};

/** Baseline seconds/word for this mode (global, last 50 plays median) */
function getBaselineSecPerWord(mode){
  const w = historyData
    .filter(h=>h && h.mode===mode && isValidWpmRow(h))
    .slice(-50)
    .map(h=>60/h.wpm);
  if(w.length>=10){
    const sorted = [...w].sort((a,b)=>a-b);
    const mid = Math.floor(sorted.length/2);
    const med = (sorted.length%2===0) ? (sorted[mid-1]+sorted[mid])/2 : sorted[mid];
    return clamp(med, 0.8, 10); // safety
  }
  // fallback (beginner friendly)
  const fallback = {normal:3.0, hard:3.3, extra:3.6};
  return fallback[mode] || 3.0;
}

/** =========================================================
 * Personal baseline (seconds per char) for this device/user
 * - Used to relax "Hard" threshold for very slow typists
 * - Stored in localStorage, so each iPad/PC learns its own baseline
========================================================= */
function loadPersonalBaseline(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY_PERSONAL_BASELINE);
    if(!raw) return {v:1};
    const obj = JSON.parse(raw);
    return (obj && typeof obj === 'object') ? obj : {v:1};
  }catch(e){
    return {v:1};
  }
}
function savePersonalBaseline(obj){
  try{ localStorage.setItem(STORAGE_KEY_PERSONAL_BASELINE, JSON.stringify(obj)); }catch(e){}
}
function _median(arr){
  const a = [...arr].sort((x,y)=>x-y);
  const mid = Math.floor(a.length/2);
  return (a.length%2) ? a[mid] : (a[mid-1] + a[mid]) / 2;
}
function personalBaselineFallbackSpc(mode){
  // seconds per char (beginner-friendly)
  const map = {normal:1.20, hard:1.35, extra:1.50};
  return map[mode] || 1.20;
}
function getPersonalBaselineInfo(mode){
  const data = loadPersonalBaseline();
  const arr = (data && Array.isArray(data[mode])) ? data[mode].filter(n => typeof n==='number' && isFinite(n)) : [];
  const last = arr.slice(-20);
  const n = last.length;
  let spc;
  if(n >= 5){
    const win = last.slice(-10);
    spc = _median(win);
  }else{
    spc = personalBaselineFallbackSpc(mode);
  }
  spc = clamp(spc, 0.25, 8.0); // 0.25s/char (very fast) .. 8s/char (very slow)
  return {spc, n};
}
function updatePersonalBaseline(mode, elapsedSec, charsNoSpace){
  if(!mode) return;
  if(!charsNoSpace || charsNoSpace < 5) return; // ignore tiny prompts (noisy)
  if(!(elapsedSec > 0) || !isFinite(elapsedSec)) return;
  if(elapsedSec > 180) return; // ignore AFK/outliers

  let spc = elapsedSec / charsNoSpace; // seconds per char
  if(!isFinite(spc)) return;
  spc = clamp(spc, 0.25, 12.0);

  const data = loadPersonalBaseline();
  if(!Array.isArray(data[mode])) data[mode] = [];
  data[mode].push(spc);
  if(data[mode].length > 80) data[mode] = data[mode].slice(-80);
  data.v = 1;
  savePersonalBaseline(data);
}

/** Compute allow time for a given string (charsNoSpace) */
function computeAllowTimeDetail(charsNoSpace, mode){
  // Absolute baseline: 5文字につき4秒（=0.8秒/文字）。元の基準は残す（速い子を不利にしない）。
  const abs = Math.ceil(charsNoSpace * 4 / 5);

  // Personal baseline: その端末（=その子）の直近の傾向から「Hard」境界を緩める
  const info = getPersonalBaselineInfo(mode); // seconds per char
  const base = charsNoSpace * info.spc;

  // サンプルが少ないうちは少し甘め（最初からGood体験を作る）
  const grace = (info.n < 5) ? 1.55 : 1.28; // +55% / +28%
  const personal = Math.ceil(base * grace + 0.5);

  // 上限（放置AFK等を除外しつつ、極端に長くならないように）
  const cap = Math.ceil(charsNoSpace * 10.0); // 10秒/文字（WPM≒1.2）相当
  const bounded = Math.min(personal, cap);

  const allowSec = Math.max(abs, bounded);
  return {
    allowSec,
    absSec: abs,
    personalSec: bounded,
    usedPersonal: bounded > abs,
    samples: info.n,
    spc: info.spc,
    grace
  };
}
function computeAllowTimeSec(charsNoSpace, mode){
  return computeAllowTimeDetail(charsNoSpace, mode).allowSec;
}

// 判定が「標準」か「やさしめ（端末別）」か、見た目で分かるように表示
function updateJudgeAssistBadge(detail){
  const el = document.getElementById('practice-judge-badge');
  if(!el) return;
  if(currentSettings && currentSettings.readingMode){
    el.textContent = '判定: 手動';
    el.className = 'px-4 py-1 bg-emerald-50 border border-emerald-200 text-emerald-700 rounded-full text-xs font-extrabold';
    return;
  }
  if(!detail || !isFinite(detail.allowSec) || !isFinite(detail.absSec) || detail.absSec <= 0){
    el.textContent = '判定: —';
    el.className = 'px-4 py-1 bg-white border border-slate-200 text-slate-600 rounded-full text-xs font-bold shadow-sm whitespace-nowrap';
    el.title = '判定情報を取得できませんでした';
    return;
  }

  const pct = Math.max(0, Math.round((detail.allowSec / detail.absSec - 1) * 100));
  const isAssist = detail.usedPersonal && pct >= 5;

  if(isAssist){
    el.textContent = `判定: やさしめ +${pct}%`;
    el.className = 'px-4 py-1 bg-amber-50 border border-amber-200 text-amber-700 rounded-full text-xs font-extrabold shadow-sm whitespace-nowrap';
    el.title = `この端末の過去データから判定を少しゆるめています（サンプル${detail.samples}）。`;
  }else{
    el.textContent = '判定: 標準';
    el.className = 'px-4 py-1 bg-white border border-slate-200 text-slate-600 rounded-full text-xs font-bold shadow-sm whitespace-nowrap';
    el.title = '基準：5文字につき4秒（必要な場合のみ自動で調整）';
  }
}


// SRSの復習頻度を「判定: やさしめ +◯%」に連動させて調整（案B）
// - +% が大きいほど、次回までの間隔を短縮して早めに出す
// - factor = 1 / (1 + pct) （pct=0.2なら×0.83）
// - 下限は×0.50（短縮しすぎ防止）
function getSrsIntervalFactorFromAllowDetail(detail){
  try{
    if(!detail || !isFinite(detail.allowSec) || !isFinite(detail.absSec) || detail.absSec <= 0) return 1;
    if(!detail.usedPersonal) return 1;
    const pct = Math.max(0, (detail.allowSec / detail.absSec - 1)); // 0..n
    if(pct < 0.05) return 1; // 5%未満は補正なし
    const alpha = 1.0; // 補正の強さ（1.0=そのまま）
    let factor = 1 / (1 + alpha * pct);
    factor = clamp(factor, 0.50, 1.00);
    return factor;
  }catch(e){
    return 1;
  }
}
function getCurrentSrsIntervalFactor(){
  return getSrsIntervalFactorFromAllowDetail(window.__lastAllowTimeDetail);
}


/** Classify this answer for Anki-like "回答カウント" chart (based on state BEFORE updating) */
function classifySrsCategory(cardBefore, wasDue, reviewOnly){
  const st = cardBefore ? (cardBefore.state || 'new') : 'new';

  // "詰め込み": not in review-only session AND answering a review card before it was due
  if(st === 'review' && !reviewOnly && !wasDue) return 'cram';

  if(st === 'relearning') return 'relearning';
  if(st === 'new' || st === 'learning') return 'learning';

  if(st === 'review'){
    const iv = (cardBefore && typeof cardBefore.intervalDays === 'number') ? cardBefore.intervalDays : 0;
    return (iv >= 21) ? 'mature' : 'young';
  }
  return 'learning';
}

function pushSrsLog(entry){
  if(!entry || !entry.ts) return;
  srsLog.push(entry);
  const MAX = 300000;
  if(srsLog.length > MAX) srsLog.splice(0, srsLog.length - MAX);
}
function pushReadSrsLog(entry){
  if(!entry || !entry.ts) return;
  readSrsLog.push(entry);
  const MAX = 300000;
  if(readSrsLog.length > MAX) readSrsLog.splice(0, readSrsLog.length - MAX);
}


/** Update SRS schedule (auto) */
function applySrsResult(item, mode, result, intervalFactor=1){
  // result: 'again' | 'hard' | 'good' | 'easy'
  const card = ensureSrsCard(item, mode);
  const ts = nowTs();

  // Map string result to FSRS rating
  let rating = 3; // Good
  if (result === 'again') rating = 1;
  else if (result === 'hard') rating = 2;
  else if (result === 'good') rating = 3;
  else if (result === 'easy') rating = 4;

  // Calculate FSRS
  const next = FSRS.calculate(card, rating, ts);

  // Update card
  card.difficulty = next.difficulty;
  card.stability = next.stability;
  card.intervalDays = next.interval; // Keep intervalDays for compatibility

  // Ex-HardでEasyなら即座に定着（21日以上）とみなす特別ルール
  if(mode === 'extra' && result === 'easy' && card.intervalDays < 21){
    card.intervalDays = 21;
    if(card.stability < 21) card.stability = 21;
  }

  // 「判定: やさしめ +◯%」に応じて、復習間隔（due）を短縮して早めに出す（案B）
  if(!(intervalFactor > 0) || !isFinite(intervalFactor)) intervalFactor = 1;
  intervalFactor = clamp(intervalFactor, 0.25, 1.00); // safety
  const _baseIvl = card.intervalDays;
  const _adjIvl = clamp(Math.round(_baseIvl * intervalFactor), 1, FSRS.p.max_interval);
  card.intervalDays = _adjIvl;

  card.lastReviewTs = ts;
  card.reps = (card.reps || 0) + 1;

  if (result === 'again') {
    card.lapses = (card.lapses || 0) + 1;
    card.state = 'relearning';
    // Again doesn't use long interval immediately in FSRS usually, 
    // but here we use the calculated interval (which will be short for low S)
    // or we can enforce a short "learning step".
    // FSRS calculates S based on "Forget", so next interval will be small (e.g. <1 day).
    // For practice UX, we set dueTs to tomorrow (or calculated days).
    // Note: In-session repetition (+3) handles the immediate retry.
    card.dueTs = ts + daysToMs(card.intervalDays);
  }else{
    card.state = 'review';
    card.dueTs = ts + daysToMs(card.intervalDays);
  }

  // SRSランク更新チェック
  const masteredCount = getSrsMasteredCount();
  updateSrsRank(masteredCount);

  saveAll();
}

function applyReadSrsResult(item, mode=currentSettings.mode, result='good', intervalFactor=1.0){
  const ts = nowTs();
  const card = ensureReadSrsCard(item, mode);

  // Map result -> FSRS rating
  // result: 'again'|'hard'|'good'|'easy'
  let rating = 3;
  if(result==='again') rating = 1;
  else if(result==='hard') rating = 2;
  else if(result==='easy') rating = 4;

  const before = {...card};
  const next = FSRS.calculate(card, rating, ts);

  // Apply updates
  card.state = next.state;
  card.difficulty = next.difficulty;
  card.stability = next.stability;
  // NOTE:
  // 音読SRSは「わかる / わからない」の二択運用。
  // OK（again以外）を押したら“今日中は消化扱い”になって欲しいので、
  // 0日になって due が即復活しないよう、最低1日を保証する。
  // （わからない=again は 0日で即復活OK）
  let nextDays = Math.max(0, Math.round((next.intervalDays || 0) * (intervalFactor||1)));
  if(result !== 'again') nextDays = Math.max(1, nextDays);
  card.intervalDays = nextDays;
  card.reps = (card.reps||0) + 1;
  card.lastReviewTs = ts;

  if(rating===1){
    card.lapses = (card.lapses||0) + 1;
  }

  // Due date
  card.dueTs = ts + daysToMs(card.intervalDays);

  saveAll();
}


function isDue(item, mode=currentSettings.mode){
  const k = srsKeyForItem(item, mode);
  const card = srsData[k];
  if(!card) return false;
  return (card.dueTs||0) > 0 && (card.dueTs <= nowTs());
}

function getSrsMasteredCount(){
  let count = 0;
  for(const key in srsData){
    // intervalDays >= 21 を「定着（Mature）」とみなす
    if(srsData[key].intervalDays >= 21) count++;
  }
  return count;
}

// Count due/total cards across ALL sections within a grade for a given mode.
function countSrsForGradeMode(grade, mode){
  const g = String(grade);
  const now = nowTs();
  let due = 0;
  let total = 0;

  // Count only cards that can be mapped to currently loaded words.
  for(const it of (allWords||[])){
    if(String(it.grade) !== g) continue;
    const k = resolveExistingSrsKeyAll(it, mode);
    const card = srsData[k];
    if(!card) continue;
    total++;
    if((card.dueTs||0) > 0 && (card.dueTs <= now)) due++;
  }

  return {due, total};
}

function updateSrsPanel(){
  const dueEl = document.getElementById('srs-due-count');
  const totalEl = document.getElementById('srs-total-count');
  if(!dueEl || !totalEl) return;

  const targets = getTargets();
  const now = nowTs();
  let due = 0;
  let totalRegistered = 0;

  targets.forEach(it=>{
    const card = (currentSettings.readingMode ? getReadSrsCard(it, currentSettings.mode) : getSrsCard(it, currentSettings.mode));
    if(card){
      totalRegistered++;
      if((card.dueTs||0) > 0 && (card.dueTs <= now)) due++;
    }
  });

  dueEl.textContent = String(due);
  totalEl.textContent = String(totalRegistered);
}

/* ==============================
   BGM (Title / Section / Stats)
   - Plays on Grade / Section / Settings / Stats screens (controlled by goToScreen)
   - Stops when practice starts (and on other screens)
   - Volume adjustable + mute (saved)
============================== */
let bgm = { title:null, section:null, stats:null, reward:null };

/* --- タイトルBGMの選択プリセット --- 
   追加したい場合：files に mp3 ファイル名を足してください（このHTMLと同じフォルダに置く）
   例）{id:'my_song', label:'タイトル：MySong', files:['MySong.mp3']}
*/
const TITLE_BGM_PRESETS = [
  { id:'default',         label:'Du,Du,Du Drakichi Typing City Pop',    files:['title_bgm.mp3']},
  { id:'iwontkeepwaiting', label:'I Won\'t Keep Waiting',               files:['typeshoot_title.mp3'] },
  { id:'original',        label:'Du,Du,Du, Drakichi Typing Original',    files:['originaltitle.mp3'] },
  { id:'tough',           label:'ToughなDrakichi',                       files:['ToughなDrakichi.mp3'] },
   { id:'yatta',          label:'Yatta!',                       files:['Yatta!.mp3'] },
  { id:'mute',            label:'無音',                                  files:[] }
];

function getTitleBgmPreset(id){
  return TITLE_BGM_PRESETS.find(p=>p.id===id) || TITLE_BGM_PRESETS.find(p=>p.id==='default') || TITLE_BGM_PRESETS[0];
}

function createBgmMaybe(candidates, opts={}){
  if(!candidates || candidates.length===0) return null;
  return createAudioWithFallback(candidates, opts);
}

function replaceBgmTrack(key, candidates, opts={}){
  const wasActive = (currentBgmName === key);

  const old = bgm[key];
  if(old){
    try{ old.pause(); old.currentTime = 0; }catch(e){}
  }

  bgm[key] = createBgmMaybe(candidates, opts);

  // WebAudioが有効なら新しいトラックもつなぐ
  if(bgmGain) wireBgmToCtx();

  applyBgmVolume();

  // すでにアンロック済みで、そのBGMが選ばれている画面なら再生
  if(bgmUnlocked && wasActive) playBgm(key);
}

function applyTitleBgmPreset(presetId, {save=true}={}){
  const preset = getTitleBgmPreset(presetId);
  if(save){
    try{ localStorage.setItem(STORAGE_KEY_TITLE_BGM, preset.id); }catch(e){}
  }
  replaceBgmTrack('title', preset.files, {loop:true});
}


let bgmVol = 0.8; 
let bgmMuted = false;
/* ▼▼▼ 追加：効果音用の変数を定義 ▼▼▼ */
let sfxRankUp = null;
let sfxSecret = null;
let sfxGod = null;
let sfxPenalty = null;
let bgmUnlocked = false;
let currentBgmName = null;
let bgmGain = null;
let bgmReqId = 0;

function initBgm(){
  // Create HTMLAudio tracks
  const savedTitlePreset = (()=>{ try{ return (localStorage.getItem(STORAGE_KEY_TITLE_BGM) || '').trim() || 'default'; }catch(e){ return 'default'; } })();

  bgm.title   = createBgmMaybe(getTitleBgmPreset(savedTitlePreset).files, {loop:true});
  bgm.section = createAudioWithFallback(['section_bgm.mp3','セクション選択画面.mp3'], {loop:true});
  bgm.stats   = createAudioWithFallback(['DrakichiISeeChatter.mp3'], {loop:true});
  bgm.reward15 = createAudioWithFallback(['15min_study.mp3'], {loop:true});
  bgm.reward30 = createAudioWithFallback(['matsuri.mp3'], {loop:true});
  /* ▼▼▼ 追加：ランクアップ音などを事前に生成しておく ▼▼▼ */
  // Rank-up / special jingles (fallback filenames + URL-encoding)
  sfxRankUp  = createAudioWithFallback(['RankUp.mp3']);
  sfxSecret  = createAudioWithFallback(['destroyer_creator.mp3']);
  sfxGod     = createAudioWithFallback(['Godmaster.mp3']);
  sfxPenalty = createAudioWithFallback(['namakemono.mp3']);

  // Restore settings
  const savedVol = localStorage.getItem(STORAGE_KEY_BGM_VOL);
  bgmVol = savedVol !== null ? parseFloat(savedVol) : 0.8;
  bgmMuted = localStorage.getItem(STORAGE_KEY_BGM_MUTE) === '1';

  applyBgmVolume();
  updateBgmMuteIcon();

  const volEl = document.getElementById('bgm-vol');
  if(volEl){
    volEl.value = Math.round(bgmVol * 100);
    volEl.addEventListener('input', ()=>{
      bgmVol = parseInt(volEl.value, 10) / 100;
      localStorage.setItem(STORAGE_KEY_BGM_VOL, bgmVol);
      applyBgmVolume();
    });
  }

  const muteBtn = document.getElementById('bgm-mute-btn');
  if(muteBtn){
    muteBtn.addEventListener('click', () => {
      bgmMuted = !bgmMuted;
      localStorage.setItem(STORAGE_KEY_BGM_MUTE, bgmMuted ? '1' : '0');
      applyBgmVolume();
      updateBgmMuteIcon();
    });
  }

// Title BGM selector (タイトル画面用)
const titleSel = document.getElementById('title-bgm-select');
if(titleSel){
  titleSel.innerHTML = TITLE_BGM_PRESETS
    .map(p => `<option value="${p.id}">${p.label}</option>`)
    .join('');
  titleSel.value = getTitleBgmPreset(savedTitlePreset).id;
  titleSel.addEventListener('change', ()=>{
    applyTitleBgmPreset(titleSel.value, {save:true});
  });
}

  const hintBtn = document.getElementById('bgm-hint-btn');
  if(hintBtn){
    hintBtn.addEventListener('click', (ev)=>{
      ev.preventDefault();
      unlockBgmProxy();
    });
  }

  setupStartOverlay();
}

function createAudioWithFallback(candidates, opts={}){
  const a = new Audio();
  a.preload = 'auto';
  a.playsInline = true;
  a.setAttribute('playsinline', '');
  if(opts.loop) a.loop = true;
  let i = 0;
  const setSrc = () => {
    if(i >= candidates.length) return;
    a.src = encodeURI(candidates[i++]);
    a.load();
  };
  setSrc();
  a.onerror = () => setSrc();
  return a;
}


function primeAudioSilent(a){
  if(!a) return;
  try{
    const prevVol = a.volume;
    const prevMuted = a.muted;
    a.muted = true;
    a.volume = 0;
    const p = a.play();
    const done = () => {
      try{ a.pause(); a.currentTime = 0; }catch(e){}
      a.volume = prevVol;
      a.muted = prevMuted;
    };
    if(p && typeof p.then === 'function'){
      p.then(done).catch(()=>{ try{ a.load(); }catch(e){}; done(); });
    } else {
      done();
    }
  }catch(e){
    try{ a.load(); }catch(_e){}
  }
}

function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') audioCtx.resume();
  if(!bgmGain){
    bgmGain = audioCtx.createGain();
    bgmGain.connect(audioCtx.destination);
  }
  wireBgmToCtx();
}


function wireBgmToCtx(){
  if(!audioCtx || !bgmGain) return;
  Object.values(bgm).forEach(a => {
    if(!a) return;
    if(a.__ctxWired) return;
    try{
      const src = audioCtx.createMediaElementSource(a);
      src.connect(bgmGain);
      a.__ctxWired = true;
    }catch(e){
      // createMediaElementSourceは1要素につき1回のみ等の制約があるため、失敗しても無視
      // a.__ctxWired = true;
    }
  });
}

function applyBgmVolume(){
  // つまみ(0〜1) → “聞こえ方”補正 → 最大でもBGM_MAX_LIMITで頭打ち
  const knob = Math.min(1, Math.max(0, bgmVol));
  const shaped = bgmMuted ? 0 : Math.pow(knob, BGM_VOL_CURVE);
  const finalVol = shaped * BGM_MAX_LIMIT;

  // WebAudioで繋がっている場合はGainNodeだけで制御（iOSでも確実）
  if(bgmGain){
    try{ bgmGain.gain.value = finalVol; }catch(e){}
  }

  Object.values(bgm).forEach(a => {
    if(!a) return;
    // WebAudio接続済みなら要素側の音量は1.0固定、未接続なら要素側で制御（フォールバック）
    a.volume = (a.__ctxWired) ? 1 : finalVol;
  });
}
function updateBgmMuteIcon(){
  const btn = document.getElementById('bgm-mute-btn');
  if(btn) btn.innerHTML = bgmMuted ? '<i class="fas fa-volume-xmark"></i>' : '<i class="fas fa-volume-high"></i>';
}

/* --- スタートオーバーレイの実装 --- */
function setupStartOverlay(){
  const overlay = document.getElementById('start-overlay');
  if (!overlay) return;

  const startAction = () => {
    if (overlay.dataset.started === 'true') return;
    overlay.dataset.started = 'true';

    try {
      // Audio Contextのアンロック & BGM開始
      try { unlockBgmProxy(); } catch(e){ console.error(e); }

      // ペナルティチェック（クリック後なので音声再生可能）
      try { checkPenaltyOnLoad(); } catch(e){ console.error(e); }
    } finally {
      // 消去アニメーション
      overlay.style.opacity = '0';
      setTimeout(() => { overlay.style.display = 'none'; }, 500);
    }
  };

  overlay.addEventListener('pointerdown', startAction, { once: true });
  overlay.addEventListener('click', startAction, { once: true });
  overlay.addEventListener('touchstart', startAction, { once: true });
}

function unlockBgmProxy(){
  if(bgmUnlocked) return;
  bgmUnlocked = true;
  ensureAudioCtx();

  // iOS対策：ユーザー操作のタイミングで“無音で一瞬再生→停止”しておくと、後から確実に鳴る
  primeAudioSilent(sfxRankUp);
  primeAudioSilent(sfxSecret);
  primeAudioSilent(sfxGod);
  primeAudioSilent(sfxPenalty);

  playBgm(currentBgmName || 'title');
}

function playBgm(name){
  if(!bgmUnlocked) {
      currentBgmName = name;
      return;
  }
  currentBgmName = name;
  bgmReqId++;
  const req = bgmReqId;

  // BGM切り替え時に、長い演出用SFX（ランクアップ音など）が鳴っていたら止める
  [sfxRankUp, sfxSecret, sfxGod, sfxPenalty].forEach(a => {
    if(a) { a.pause(); a.currentTime = 0; }
  });

  Object.entries(bgm).forEach(([k, a]) => {
    if(!a) return;
    // reward15 / reward30 などのバリエーションに対応
    if(k === name) {
      a.play().catch(() => {});
    } else {
      a.pause();
      a.currentTime = 0;
    }
  });
  applyBgmVolume();
}

function stopBgm(){
  Object.values(bgm).forEach(a => { if(a) { a.pause(); a.currentTime = 0; } });
}

/* =========================================================
   15min Study Reward
========================================================= */
let rewardOverlayLocked = false;

function showRewardOverlay(type) {
  const overlay = document.getElementById('reward-overlay');
  const img = document.getElementById('reward-gif');
  const msg = document.getElementById('reward-msg');
  const hint = document.getElementById('reward-close-hint');

  if (overlay) {
    if(type === '30'){
      if(img) img.src = "Matsuri.gif";
      if(img) img.src = "matsuri.gif";
      if(msg) msg.textContent = "今週の平均学習時間30分達成！すごい！祭りだ！";
      // 枠線の色などを変えても良いが、今回は画像と文言のみ変更
      if(img) img.className = "max-w-sm md:max-w-md rounded-2xl shadow-2xl border-4 border-rose-500";
      playBgm('reward30');
    } else {
      // default 15
      if(img) img.src = "15min_study.gif";
      if(msg) msg.textContent = "今週の平均学習時間15分達成！おめでとう！Practice makes perfect!";
      if(img) img.className = "max-w-sm md:max-w-md rounded-2xl shadow-2xl border-4 border-yellow-300";
      playBgm('reward15');
    }

    // 5秒間ロックする
    rewardOverlayLocked = true;
    overlay.classList.remove('cursor-pointer');
    if(hint) hint.style.opacity = '0';

    overlay.classList.remove('hidden');
    overlay.classList.add('flex');

    setTimeout(() => {
      rewardOverlayLocked = false;
      overlay.classList.add('cursor-pointer');
      if(hint) hint.style.opacity = '1';
    }, 5000);
  }
}

window.hideRewardOverlay = function() {
  if (rewardOverlayLocked) return;
  const overlay = document.getElementById('reward-overlay');
  if (overlay && !overlay.classList.contains('hidden')) {
    overlay.classList.add('hidden');
    overlay.classList.remove('flex');
    stopBgm();
  }
}

/* =========================================================
   Audio: SFX (toggle) & Speech (always, except extra)
========================================================= */
let audioCtx = null;

// --- Typing MP3 SFX ---
// Put the mp3 in the same folder as this HTML, or change this path.
const TYPE_SFX_URL = encodeURI('typing 音.mp3');
const TYPE_SFX_POOL_SIZE = 6;
let typeSfxPool = [];
let typeSfxIdx = 0;

function initTypeSfxPool(){
  if(typeSfxPool.length) return;
  for(let i=0;i<TYPE_SFX_POOL_SIZE;i++){
    const a = new Audio(TYPE_SFX_URL);
    a.preload = 'auto';
    a.volume = 0.35; // adjust if needed
    typeSfxPool.push(a);
  }
}
function playTypeMp3(){
  initTypeSfxPool();
  if(!typeSfxPool.length) return;
  const a = typeSfxPool[typeSfxIdx];
  typeSfxIdx = (typeSfxIdx + 1) % typeSfxPool.length;
  try{
    a.pause();
    a.currentTime = 0;
    a.play();
  }catch(e){
    // ignore autoplay restrictions / decode issues
  }
}

function ensureAudioCtx(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') audioCtx.resume();
}

function beep(freq, dur=0.04, type='square', gain=0.04){
  ensureAudioCtx();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

function sfxType(){
  if(!currentSettings.sfxType) return;
  // Prefer MP3 typing sound. If it can't play, fallback to a short beep.
  try{
    playTypeMp3();
  }catch(e){
    beep(1800, 0.02, 'square', 0.04);
  }
}

function sfxCoin(){
  if(!currentSettings.sfxCoin) return;

  // “マリオっぽい”二段
  beep(1318, 0.04, 'triangle', 0.06);
  setTimeout(()=>beep(1760, 0.05, 'triangle', 0.06), 60);
}

function sfxBuzzer(){
  if(!currentSettings.sfxCoin) return;
  // 「ブブー」っぽい低いブザー
  beep(110, 0.16, 'square', 0.08);
  setTimeout(()=>beep(95, 0.18, 'square', 0.08), 170);
}

function sfxLevelUp(){
  if(!currentSettings.sfxClear) return;

  // ドラクエ風（それっぽい短いフレーズ）
  const seq = [523,659,784,988,1175,1318];
  seq.forEach((f,i)=>setTimeout(()=>beep(f, 0.12, 'triangle', 0.05), i*120));
}

function sfxFullClear(){
  if(!currentSettings.sfxClear) return;
  // 豪華版
  const seq = [523,659,784,988,1175,1318,1568];
  seq.forEach((f,i)=>setTimeout(()=>beep(f, 0.14, 'triangle', 0.055), i*130));
}

/* Speech (US Female / UK Male) */
let voices = [];
const VOICE_PROFILE_KEY = 'drakichi_typing_voice_profile_v2';
let voiceProfile = 'us_female';

const VOICE_PROFILES = ['us_female','us_male','uk_female','uk_male'];
function normalizeVoiceProfile(v){
  return VOICE_PROFILES.includes(v) ? v : 'us_female';
}

let speechPrimed = false;
function primeSpeechOnce(){
  if(speechPrimed) return;
  speechPrimed = true;
  try{
    if(isIOSDevice()){
      // iOS/Safari: voices may not populate until first user gesture + speak.
      // IMPORTANT: do NOT schedule a later cancel() here.
      // A delayed cancel() can kill the next real utterance on some browsers (notably Windows/Chrome).
      try{ window.speechSynthesis.cancel(); }catch(e){}
      const u = new SpeechSynthesisUtterance('.');
      // Some iOS versions won't prime if volume is exactly 0
      u.volume = 0.01;
      u.rate = 1.0;
      u.pitch = 1.0;
      u.lang = getDesiredLang(voiceProfile);
      window.speechSynthesis.speak(u);
    }
  }catch(e){
    // ignore
  }
  // iOS: voice list may appear after the first gesture + speak
  setTimeout(refreshVoices, 120);
  setTimeout(refreshVoices, 500);
  setTimeout(refreshVoices, 1200);
}


function isIOSDevice(){
  // iPadOS 13+ reports MacIntel, so also check touch points
  return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
         (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}

function loadVoiceProfile(){
  const saved = localStorage.getItem(VOICE_PROFILE_KEY);
  voiceProfile = normalizeVoiceProfile(saved || voiceProfile);
}

function saveVoiceProfile(){
  voiceProfile = normalizeVoiceProfile(voiceProfile);
  localStorage.setItem(VOICE_PROFILE_KEY, voiceProfile);
  updateVoiceStatus();
}

function refreshVoices(){
  try{
    voices = window.speechSynthesis.getVoices() || [];
  }catch(e){
    voices = [];
  }

  // Keep the UI limited to 4 profiles (US/UK x male/female)
  voiceProfile = normalizeVoiceProfile(voiceProfile);
  const sel = document.getElementById('voice-profile');
  if(sel && sel.value !== voiceProfile){
    sel.value = voiceProfile;
  }

  updateVoiceStatus();
}

window.speechSynthesis.onvoiceschanged = refreshVoices;

function getDesiredLang(profile){
  return (profile && profile.startsWith('uk_')) ? 'en-GB' : 'en-US';
}

function genderFromProfile(profile){
  return (profile && profile.endsWith('_male')) ? 'male' : 'female';
}

function normLang(l){
  return (l || '').replace('_','-').toLowerCase();
}


// Normalize voice names across OS/locales (e.g., iOS may show Japanese labels like "Ava（プレミアム）").
function normalizeVoiceStr(s){
  return String(s||'')
    .toLowerCase()
    .replace(/（/g,'(').replace(/）/g,')')
    .replace(/[【】［］]/g,' ')
    .replace(/プレミアム/g,'premium')
    .replace(/高品質/g,'premium')
    .replace(/拡張/g,'enhanced')
    .replace(/エンハンスド/g,'enhanced')
    .replace(/強化/g,'enhanced')
    .replace(/\s+/g,' ')
    .trim();
}
function compactVoiceStr(s){
  return normalizeVoiceStr(s).replace(/[^a-z0-9]+/g,'');
}

const VOICE_CANDIDATES_IOS = {
  us_male:   [
    'Evan (Premium)','Evan（プレミアム）','Evan Premium',
    'Evan (Enhanced)','Evan（拡張）','Evan Enhanced',
    'Evan',
    'Aaron (Premium)','Aaron (Enhanced)','Aaron',
    'Alex (Enhanced)','Alex',
    'Nathan','Fred','Tom'
  ],
  us_female: [
    'Ava (Premium)','Ava（プレミアム）','Ava Premium','Ava（Premium）',
    'Ava (Enhanced)','Ava（拡張）','Ava Enhanced',
    'Ava',
    'Samantha (Enhanced)','Samantha（拡張）','Samantha Enhanced',
    'Samantha',
    'Allison','Zoe','Susan'
  ],
  uk_male:   [
    'Daniel (Premium)','Daniel（プレミアム）','Daniel Premium',
    'Daniel (Enhanced)','Daniel（拡張）','Daniel Enhanced',
    'Daniel',
    'Oliver (Enhanced)','Oliver',
    'Arthur','Thomas'
  ],
  uk_female: [
    'Kate (Premium)','Kate（プレミアム）','Kate Premium',
    'Kate (Enhanced)','Kate（拡張）','Kate Enhanced',
    'Kate',
    'Serena (Enhanced)','Serena',
    'Martha','Catherine','Stephanie'
  ]
};

const VOICE_CANDIDATES_OTHER = {
  us_male:   [
    'Microsoft Guy Online (Natural)','Microsoft Guy',
    'Google US English Male','Google US English (Male)',
    'Microsoft David','Microsoft Mark',
    'Guy','David','Mark','Alex'
  ],
  us_female: [
    'Microsoft Aria Online (Natural)','Microsoft Jenny Online (Natural)',
    'Google US English',
    'Microsoft Aria','Microsoft Jenny','Microsoft Zira',
    'Aria','Jenny','Zira','Samantha'
  ],
  uk_male:   [
    'Microsoft Ryan Online (Natural)','Microsoft George Online (Natural)',
    'Google UK English Male',
    'Microsoft Ryan','Microsoft George',
    'Ryan','George','Daniel','Oliver'
  ],
  uk_female: [
    'Microsoft Sonia Online (Natural)','Microsoft Libby Online (Natural)',
    'Google UK English Female',
    'Microsoft Sonia','Microsoft Libby',
    'Sonia','Libby','Serena','Kate'
  ]
};

// Hints (best-effort). Web Speech API does not expose gender, so we infer from names.
const FEMALE_HINTS = ['samantha','ava','allison','nicky','karen','moira','tessa','kathy','zira','aria','jenny','sonia','libby','serena','kate','martha','stephanie','emily'];
const MALE_HINTS   = ['alex','daniel','oliver','george','harry','david','guy','ryan','mark','james','fred','tom','evan','nathan','arthur','rishi','rocko'];


function hasAnyTag(s, tags){
  if(!s) return false;
  const t = String(s).toLowerCase();
  return tags.some(x => t.includes(x));
}

function voiceQualityScore(v){
  // Prefer higher quality variants when available.
  const n = (v && v.name) ? String(v.name) : '';
  const u = (v && v.voiceURI) ? String(v.voiceURI) : '';
  const s = normalizeVoiceStr(n + ' ' + u);

  let score = 0;
  // Premium / Enhanced on iOS
  if(hasAnyTag(s, ['premium','プレミアム','high quality','高品質'])) score += 220;
  if(hasAnyTag(s, ['enhanced','拡張','拡張版','エンハンスド','強化'])) score += 150;

  // Microsoft/Google high quality labels (Windows/Chrome etc)
  if(hasAnyTag(s, ['online','natural','neural','wavenet','studio'])) score += 140;

  // Slightly prefer default voice if everything else ties
  if(v && v.default) score += 10;

  return score;
}

function voiceBaseScore(profile, v){
  const name = ((v&&v.name)||'') + ' ' + ((v&&v.voiceURI)||'');
  const s = normalizeVoiceStr(name);

  // Preference order per profile (cross-platform)
  const pref = {
    us_female: [
      ['ava',1000], ['aria',980], ['jenny',960], ['zira',920],
      ['samantha',880], ['allison',850], ['zoe',820], ['susan',810]
    ],
    us_male: [
      ['evan',1000], ['guy',980], ['aaron',970], ['alex',950],
      ['mark',920], ['david',900], ['nathan',880], ['fred',860], ['tom',850]
    ],
    uk_female: [
      ['kate',1000], ['sonia',980], ['libby',960], ['serena',930],
      ['martha',900], ['catherine',880], ['stephanie',860]
    ],
    uk_male: [
      ['daniel',1000], ['ryan',980], ['george',960], ['oliver',930],
      ['arthur',900], ['thomas',880]
    ]
  }[profile] || [];

  for(const [key,score] of pref){
    if(s.includes(key)) return score;
  }
  return 0;
}


function pickVoice(profile){
  profile = normalizeVoiceProfile(profile);
  const list = (voices && voices.length) ? voices : (window.speechSynthesis.getVoices() || []);
  if(!list || list.length === 0) return null;

  const targetLang = getDesiredLang(profile).toLowerCase();
  const poolLang = list.filter(v => normLang(v.lang).startsWith(targetLang));
  const poolEn   = list.filter(v => normLang(v.lang).startsWith('en'));
  const pool = poolLang.length ? poolLang : (poolEn.length ? poolEn : list);

  const ios = isIOSDevice();
  const candidatesMap = ios ? VOICE_CANDIDATES_IOS : VOICE_CANDIDATES_OTHER;
  const candidates = candidatesMap[profile] || [];
  const voiceText = v => `${(v&&v.name)||''} ${(v&&v.voiceURI)||''}`;
  const cmp = s => compactVoiceStr(s);

  // 1) Candidate quick-hit (handles localized variants)
  for(const c of candidates){
    const cc = cmp(c);
    const found = pool.find(v => cmp(voiceText(v)).includes(cc));
    if(found) return found;
  }

  // 2) Score-based selection: base preference + quality bonus (+ gender penalty)
  const wants = genderFromProfile(profile);
  let best = null;
  let bestScore = -1e9;

  for(const v of pool){
    const nameL = normalizeVoiceStr(((v&&v.name)||'') + ' ' + ((v&&v.voiceURI)||''));
    let score = voiceBaseScore(profile, v) + voiceQualityScore(v);

    // Prefer correct language when available
    if(normLang(v.lang).startsWith(targetLang)) score += 30;

    // Penalize obvious opposite gender
    if(wants === 'male' && FEMALE_HINTS.some(h => nameL.includes(h))) score -= 320;
    if(wants === 'female' && MALE_HINTS.some(h => nameL.includes(h))) score -= 320;

    if(score > bestScore){
      bestScore = score;
      best = v;
    }
  }
  if(best) return best;

  // 3) Fallback: first in language pool
  if(poolLang.length) return poolLang[0];
  return pool[0] || null;
}

function updateVoiceStatus(){
  const el = document.getElementById('voice-status');
  if(!el) return;

  const v = pickVoice(voiceProfile);
  if(!v){
    el.textContent = '英語音声が見つかりません（端末にEnglish音声が未インストールの可能性）';
    return;
  }
  const labels = {
    us_male: 'US 男性',
    us_female: 'US 女性',
    uk_male: 'UK 男性',
    uk_female: 'UK 女性'
  };
  const label = labels[voiceProfile] || voiceProfile;
  const wants = genderFromProfile(voiceProfile);
  const nameL = normalizeVoiceStr(v.name);
  let note = '';
  if(wants === 'male' && FEMALE_HINTS.some(h => nameL.includes(h))) note = '（男性音声が見つからず代替）';
  if(wants === 'female' && MALE_HINTS.some(h => nameL.includes(h))) note = '（女性音声が見つからず代替）';
  el.textContent = `${label}${note}：${v.name} (${v.lang})`;
}

function initVoiceUI(){
  loadVoiceProfile();

  const sel = document.getElementById('voice-profile');
  if(sel){
    sel.value = normalizeVoiceProfile(voiceProfile);
    voiceProfile = sel.value;
    sel.addEventListener('change', ()=>{
      voiceProfile = normalizeVoiceProfile(sel.value);
      saveVoiceProfile();
    });
  }

  const btn = document.getElementById('voice-test-btn');
  if(btn){
    btn.addEventListener('click', ()=>{
    // When opening, refresh the peek text from the current question
    if(!answerPeekShown){
      try{ setAnswerPeek(getAnswerPeekText()); }catch(e){}
    }
    answerPeekShown = !answerPeekShown;
    box.classList.toggle('hidden', !answerPeekShown);
    btn.textContent = answerPeekShown ? '隠す' : '表示';
  });
  }

  // Load voices (some browsers populate async)
  refreshVoices();
  setTimeout(refreshVoices, 300);
  setTimeout(refreshVoices, 1200);

  // iOS: voice list may appear only after the first user gesture
  window.addEventListener('pointerdown', primeSpeechOnce, {once:true});
  window.addEventListener('touchstart', primeSpeechOnce, {once:true});
  window.addEventListener('keydown', primeSpeechOnce, {once:true});
}

// GC対策用グローバル変数
window._lastUtterance = null;

function speak(text){
  if(currentSettings.mode === 'extra' && !currentSettings.readingMode) return; // 仕様: Ex-Hardは音声なし（ただし音読モード中はON）
  try{
    window.speechSynthesis.cancel();

    // 音声リストが空なら再取得を試みる
    if(!voices || voices.length === 0) refreshVoices();

    const u = new SpeechSynthesisUtterance(text);
    window._lastUtterance = u; // GC対策: 変数に保持する

    const v = pickVoice(voiceProfile);

    if(v){
      u.voice = v;
      u.lang = v.lang || getDesiredLang(voiceProfile);
    }else{
      u.lang = getDesiredLang(voiceProfile);
    }

    u.rate = 1.0;
    u.pitch = 1.0;
    
    u.onend = () => { window._lastUtterance = null; };
    u.onerror = (err) => { console.error('TTS Error:', err); };

    window.speechSynthesis.speak(u);
  }catch(e){
    console.error('Speak error:', e);
  }
}




/* =========================================================
   Speech Recognition (Reading Mode) - Web Speech API
   - Simple: recognize spoken text and compare with target
   - NOTE: This is NOT a phoneme-level pronunciation score.
========================================================= */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let speechRec = null;
let speechActive = false;
let speechFinal = '';
let speechInterim = '';
let speechStartTs = 0;

// ---- Reading (Speech) evaluation (separate from typing) ----
let readingEval = { ok:0, attempts:0, sumPct:0, sumSpeed:0, lastPct:0, lastSpeed:0, lastGrade:'', lastOk:false };
function readingOkThreshold(){
  const m = (currentSettings && currentSettings.mode) ? currentSettings.mode : 'normal';
  if(m==='hard') return 0.90;
  if(m==='extra') return 0.95;
  return 0.85;
}
function readingGradeFromPct(pct){
  if(pct>=98) return 'S';
  if(pct>=95) return 'A';
  if(pct>=90) return 'B';
  if(pct>=85) return 'C';
  return 'D';
}
function resetReadingEval(){
  readingEval = { ok:0, attempts:0, sumPct:0, sumSpeed:0, lastPct:0, lastSpeed:0, lastGrade:'', lastOk:false };
  updateReadingBadges();
}
function getReadingAvgPct(){
  return readingEval.attempts ? (readingEval.sumPct/readingEval.attempts) : 0;
}
function updateReadingBadges(){
  const badge = document.getElementById('practice-reading-badge');
  const wpmBadge = document.getElementById('practice-wpm-badge');
  const sc = document.getElementById('speech-score');

  if(badge){
    if(currentSettings && currentSettings.readingMode){
      badge.classList.remove('hidden');
      if(readingEval.attempts){
        const avg = Math.round(getReadingAvgPct());
        const g = readingGradeFromPct(avg);
        badge.textContent = `READ: ${readingEval.ok}/${readingEval.attempts}  AVG: ${avg}% (${g})`;
      }else{
        badge.textContent = 'READ: 0';
      }
    }else{
      badge.classList.add('hidden');
    }
  }

  if(wpmBadge && currentSettings && currentSettings.readingMode){
    wpmBadge.textContent = 'WPM: —';
  }

  // Keep the speech panel small text in sync (optional)
  if(sc && currentSettings && currentSettings.readingMode && readingEval.attempts){
    const avg = Math.round(getReadingAvgPct());
    const g = readingGradeFromPct(avg);
    // Don't overwrite detailed per-attempt message; only show when empty
    if(!sc.textContent) sc.textContent = `累計：${readingEval.ok}/${readingEval.attempts}  平均：${avg}% (${g})`;
  }
}

function isSpeechRecSupported(){
  return !!SpeechRecognition;
}

function normalizeSpeechText(s){
  return String(s||'')
    .toLowerCase()
    .replace(/[’‘]/g, "'")
    .replace(/[^a-z0-9'\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function wordsOf(s){
  const t = normalizeSpeechText(s);
  return t ? t.split(' ') : [];
}

function editDistanceWords(a, b){
  const n = a.length, m = b.length;
  const dp = Array.from({length:n+1}, ()=>new Array(m+1).fill(0));
  for(let i=0;i<=n;i++) dp[i][0]=i;
  for(let j=0;j<=m;j++) dp[0][j]=j;
  for(let i=1;i<=n;i++){
    for(let j=1;j<=m;j++){
      const cost = (a[i-1]===b[j-1]) ? 0 : 1;
      dp[i][j] = Math.min(
        dp[i-1][j] + 1,
        dp[i][j-1] + 1,
        dp[i-1][j-1] + cost
      );
    }
  }
  return dp[n][m];
}

function speechSimilarity(target, spoken){
  const ta = wordsOf(target);
  const sa = wordsOf(spoken);
  if(ta.length===0 && sa.length===0) return 1;
  if(ta.length===0 || sa.length===0) return 0;
  const dist = editDistanceWords(ta, sa);
  const denom = Math.max(ta.length, sa.length);
  return Math.max(0, 1 - (dist / denom));
}

function setSpeechStatus(msg, scoreText=''){
  const st = document.getElementById('speech-status');
  const sc = document.getElementById('speech-score');
  if(st) st.textContent = msg;
  if(sc) sc.textContent = scoreText;
}

function setSpeechTranscript(txt){
  const el = document.getElementById('speech-transcript');
  if(el) el.textContent = txt || '';
}


// ===== Answer Peek (Hard/Ex-Hard 音読の自己判定用) =====
let answerPeekShown = false;
function setAnswerPeek(text){
  const wrap = document.getElementById('answer-peek-wrap');
  const box  = document.getElementById('answer-peek-text');
  const btn  = document.getElementById('answer-peek-toggle');
  if(!wrap || !box || !btn) return;
  box.textContent = String(text||'');
}
function updateAnswerPeekUI(targetText){
  const wrap = document.getElementById('answer-peek-wrap');
  const box  = document.getElementById('answer-peek-text');
  const btn  = document.getElementById('answer-peek-toggle');
  if(!wrap || !box || !btn) return;

  const shouldShow = !!(currentSettings && currentSettings.readingMode && (currentSettings.mode==='hard' || currentSettings.mode==='extra'));
  wrap.classList.toggle('hidden', !shouldShow);

  if(!shouldShow){
    answerPeekShown = false;
    box.classList.add('hidden');
    btn.textContent = '答え表示';
    return;
  }

  setAnswerPeek(targetText || getAnswerPeekText());
  answerPeekShown = false;
  box.classList.add('hidden');
  btn.textContent = '答え表示';
}

function getAnswerPeekText(){
  try{
    const q = (typeof currentQuestion==='function') ? currentQuestion() : null;
    const raw1 = q ? (q.en ?? q.answer ?? q.target ?? '') : '';
    const raw2 = (typeof currentTargetPlain !== 'undefined') ? currentTargetPlain : '';
    const raw = raw1 || raw2;
    const plain = (typeof normalizeTypingText==='function')
      ? normalizeTypingText((typeof stripRoleMarkup==='function') ? stripRoleMarkup(raw) : raw)
      : String(raw||'');
    return plain;
  }catch(e){
    return '';
  }
}

(function bindAnswerPeekOnce(){
  const btn = document.getElementById('answer-peek-toggle');
  const box = document.getElementById('answer-peek-text'); // legacy (we no longer use this box)
  if(!btn) return;
  if(btn.dataset.bound==='1') return;
  btn.dataset.bound='1';

  btn.addEventListener('click', ()=>{
    // Hard/Ex-Hard 音読の自己判定用：中央の出題表示エリアに答えを表示する
    try{
      const ans = getAnswerPeekText();
      if(ans){
        // Show in the main word display (center)
        if(typeof revealAnswerInDisplay==='function') revealAnswerInDisplay(ans);
        setSpeechStatus('答えを表示しました（中央） できた/わからない を押してください');
      }else{
        setSpeechStatus('答えが見つかりません（この問題データに英語が入っていない可能性）');
      }
    }catch(e){
      setSpeechStatus('答え表示でエラーが発生しました');
    }
    // Keep legacy box hidden always
    try{ if(box) box.classList.add('hidden'); }catch(e){}
    answerPeekShown = true;
    btn.textContent = '答え再表示';
  });
})();

function resetSpeechPanel(){
  speechFinal = '';
  speechInterim = '';
  speechStartTs = 0;
  setSpeechTranscript('');
  {const isLocal=(location.hostname==='localhost'||location.hostname==='127.0.0.1');const sec=(window.isSecureContext||isLocal);const hint=sec?'':'（HTTPS必須）';setSpeechStatus('「音読」→ 読んだら「できた」/ 無理なら「わからない」'+hint, sec?'':`現在: ${location.protocol}//${location.host}`);}
  setMicButtonState(false);

  try{ updateAnswerPeekUI(''); }catch(e){}
}

function ensureSpeechRec(){
  if(speechRec || !isSpeechRecSupported()) return;
  speechRec = new SpeechRecognition();
  speechRec.interimResults = true;
  speechRec.continuous = false;
  speechRec.maxAlternatives = 3;

  speechRec.onstart = ()=>{
    speechActive = true;
    speechStartTs = performance.now();
    speechFinal = '';
    speechInterim = '';
    setSpeechTranscript('');
    setSpeechStatus('Listening…（読み上げてください）');
    setMicButtonState(true);
  };

  speechRec.onresult = (event)=>{
    let finalTxt = '';
    let interimTxt = '';
    for(let i=event.resultIndex; i<event.results.length; i++){
      const res = event.results[i];
      const alt = res && res[0] ? res[0].transcript : '';
      if(res.isFinal) finalTxt += alt + ' ';
      else interimTxt += alt + ' ';
    }
    if(finalTxt.trim()) speechFinal += finalTxt;
    speechInterim = interimTxt;

    const combined = (speechFinal + ' ' + speechInterim).trim();
    setSpeechTranscript(combined);
  };

  speechRec.onerror = (e)=>{
    speechActive = false;
    setMicButtonState(false);
    const code = (e && e.error) ? String(e.error) : 'error';

    // Friendly messages
    let msg = '音声認識エラー: ' + code;
    if(code === 'not-allowed' || code === 'service-not-allowed'){
      msg = 'マイクが許可されていません（🔒サイト設定でマイクを「許可」）';
    }else if(code === 'audio-capture'){
      msg = 'マイクを取得できません（端末のマイク/OS設定を確認）';
    }else if(code === 'network'){
      msg = 'ネットワークエラー（回線/フィルタで遮断の可能性）';
    }else if(code === 'no-speech'){
      msg = '音声が検出できません（声量/マイク入力先を確認）';
    }else if(code === 'aborted'){
      msg = '中断しました（もう一度「音読」を押してください）';
    }

    setSpeechStatus(msg, `error: ${code}`);
  };

  speechRec.onend = ()=>{
    speechActive = false;
    setMicButtonState(false);

    if(!currentSettings.readingMode) return;
    if(sessionEnded || isTransitioning) return;

    const spoken = (speechFinal || speechInterim || '').trim();
    if(!spoken){
      setSpeechStatus('聞き取れませんでした。もう一度（Stopで区切れます）');
      return;
    }

    // NOTE: 文字起こしは参考表示。自動採点はしない（自己申告）
    setSpeechStatus('聞き取り完了。できた→「できた」／無理→「わからない」', '（スピード不問）');
  };
}

async function startReadingRecognition(){
  if(!currentSettings.readingMode) return;

  // Secure context check (mic requires HTTPS or localhost)
  const isLocal = (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
  if(!window.isSecureContext && !isLocal){
    setSpeechStatus('HTTPSで開いてください（マイクはHTTPS必須）', `現在: ${location.protocol}//${location.host}`);
    try{ alert('音読モードは HTTPS(SSL) で開かないとマイクが使えません。URLが https:// になっているか確認してください。'); }catch(e){}
    return;
  }

  if(!isSpeechRecSupported()){
    alert('このブラウザは音声認識(Web Speech API)に対応していません。PCのChrome推奨です。');
    setSpeechStatus('このブラウザは音声認識に非対応です（PC Chrome推奨）');
    return;
  }

  // Stop TTS while listening (avoid self-capture / conflicts)
  try{ window.speechSynthesis && window.speechSynthesis.cancel(); }catch(e){}

  // Proactively request mic permission (triggers prompt reliably)
  if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      // stop immediately; permission remains granted
      try{ stream.getTracks().forEach(t=>t.stop()); }catch(e){}
    }catch(err){
      const name = (err && (err.name || err.message)) ? (err.name || err.message) : 'unknown';
      let msg = 'マイク権限が必要です（許可してください）';
      if(String(name).toLowerCase().includes('notallowed')) msg = 'マイクが拒否されています（ブラウザの🔒設定で許可）';
      if(String(name).toLowerCase().includes('notfound')) msg = 'マイクが見つかりません（接続/OS設定を確認）';
      setSpeechStatus(msg, `error: ${name}`);
      return;
    }
  }

  ensureSpeechRec();
  if(!speechRec) return;

  try{ speechRec.lang = getDesiredLang(voiceProfile); }catch(e){}

  // Start recognition
  try{
    setSpeechStatus('Listening…（読み上げてください）');
    speechRec.start();
  }catch(e){
    console.warn('speech start failed', e);
    const em = (e && (e.name || e.message)) ? (e.name || e.message) : 'start_failed';
    setSpeechStatus('音声認識を開始できませんでした（権限/対応/HTTPSを確認）', String(em));
  }
}

function stopReadingRecognition(){
  try{
    if(speechRec && speechActive) speechRec.stop();
  }catch(e){}
  speechActive = false;
  setMicButtonState(false);
}

function setMicButtonState(active){
  const btn = document.getElementById('speech-mic-btn');
  const icon = document.getElementById('speech-mic-icon');
  const label = document.getElementById('speech-mic-label');
  if(!btn || !icon || !label) return;
  if(active){
    btn.classList.remove('bg-emerald-600','hover:bg-emerald-700');
    btn.classList.add('bg-rose-600','hover:bg-rose-700');
    icon.className = 'fas fa-stop text-2xl';
    label.textContent = 'Stop';
  }else{
    btn.classList.remove('bg-rose-600','hover:bg-rose-700');
    btn.classList.add('bg-emerald-600','hover:bg-emerald-700');
    icon.className = 'fas fa-microphone text-2xl';
    label.textContent = '音読';
  }
}

// Mic button
const speechMicBtn = document.getElementById('speech-mic-btn');
if(speechMicBtn){
  speechMicBtn.addEventListener('click', ()=>{
    if(!currentSettings.readingMode) return;
    if(speechActive) stopReadingRecognition();
    else startReadingRecognition();
  });
}

/* =========================================================
   Confetti (Canvas)
========================================================= */
let confettiRunning = false;

function fireConfetti({durationMs=1600, count=120, burst=2}={}){
  const canvas = document.getElementById('confetti-canvas');
  if(!canvas) return;

  const rect = document.getElementById('app-container').getBoundingClientRect();
  canvas.width = Math.floor(rect.width * devicePixelRatio);
  canvas.height = Math.floor(rect.height * devicePixelRatio);
  canvas.style.width = rect.width + "px";
  canvas.style.height = rect.height + "px";

  const ctx = canvas.getContext('2d');
  canvas.classList.remove('hidden');
  confettiRunning = true;

  const W = canvas.width, H = canvas.height;
  const particles = [];
  const rand = (a,b)=>a + Math.random()*(b-a);

  function spawn(n, power=1){
    for(let i=0;i<n;i++){
      const size = rand(6,12) * devicePixelRatio;
      particles.push({
        x: rand(W*0.2, W*0.8),
        y: rand(-H*0.05, H*0.05),
        w: size,
        h: size * rand(0.6, 1.2),
        vx: rand(-2.8,2.8)*devicePixelRatio*power,
        vy: rand(2.5,6.5)*devicePixelRatio*power,
        rot: rand(0,Math.PI*2),
        vr: rand(-0.25,0.25)*power,
        color: `hsl(${Math.floor(rand(0,360))} 90% 60%)`,
        life: rand(durationMs*0.6, durationMs)
      });
    }
  }

  spawn(Math.floor(count/burst), 1.0);

  let last = performance.now();
  const start = last;

  function tick(now){
    if(!confettiRunning) return;
    const dt = Math.min(32, now-last);
    last = now;

    const t = now-start;
    if(burst>=2 && t>180 && t<220) spawn(Math.floor(count/burst), 1.1);
    if(burst>=3 && t>360 && t<400) spawn(Math.floor(count/burst), 1.2);

    ctx.clearRect(0,0,W,H);

    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life -= dt;
      if(p.life<=0 || p.y>H+p.h*2){
        particles.splice(i,1);
        continue;
      }
      p.vy += 0.08 * devicePixelRatio;
      p.vx *= 0.995;
      p.x += p.vx;
      p.y += p.vy;
      p.rot += p.vr;

      ctx.save();
      ctx.translate(p.x,p.y);
      ctx.rotate(p.rot);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      ctx.restore();
    }

    if(now-start < durationMs || particles.length>0){
      requestAnimationFrame(tick);
    }else{
      canvas.classList.add('hidden');
      confettiRunning = false;
    }
  }

  requestAnimationFrame(tick);
}

/* =========================================================
   Stats + History
========================================================= */
function saveStats(grade, section, mode, score, wpm){
  const key = keyFor(grade, section);
  const now = new Date().toLocaleDateString();

  if(!statsData[key]){
    statsData[key] = {
      normal:{score:0,wpm:0},
      hard:{score:0,wpm:0},
      extra:{score:0,wpm:0},
      date:""
    };
  }

  const cur = statsData[key][mode];
  if(score > cur.score) cur.score = score;
  if(wpm   > cur.wpm)   cur.wpm   = wpm;
  statsData[key].date = now;

  saveAll();
}

function addHistory(grade, section, mode, score, wpm, meta={}){
  const row = {ts:Date.now(), grade, section, mode, wpm, score};
  if(meta && typeof meta==='object'){
    for(const k in meta){
      if(!(k in row)) row[k] = meta[k];
    }
  }
  historyData.push(row);
  if(historyData.length > 3000) historyData = historyData.slice(-3000);
  saveAll();
}

/* Summary */
function summarizeWpm(grade, section){
  const now = Date.now();
  const weekMs = 7*24*60*60*1000;

  const rows = historyData
    .filter(r=>{
      if(grade && r.grade!==grade) return false;
      if(section && r.section!==section) return false;
      return true;
    })
    .sort((a,b)=>a.ts-b.ts);

  // WPM集計は validWpm=true の行だけ（1語セクション等は除外）
  const rowsWpm = rows.filter(isValidWpmRow);

  const week = rowsWpm.filter(r=>now-r.ts<=weekMs);
  const weekAvg = week.length ? Math.round(week.reduce((a,b)=>a+b.wpm,0)/week.length) : null;

  let best = null;
  rowsWpm.forEach(r=>{ if(!best || r.wpm>best.wpm) best=r; });

  const last10 = rowsWpm.slice(-10);
  const prev10 = rowsWpm.slice(-20,-10);
  const avg = arr => arr.length ? (arr.reduce((a,b)=>a+b.wpm,0)/arr.length) : null;
  const lastAvg = avg(last10);
  const prevAvg = avg(prev10);
  const growth = (lastAvg!=null && prevAvg!=null) ? Math.round(((lastAvg-prevAvg)/Math.max(1,prevAvg))*100) : null;

  return {weekAvg, best, growth};
}

function renderWpmSummary(grade, section){
  const elWeek = document.getElementById('sum-week-avg');
  const elBest = document.getElementById('sum-best');
  const elBestNote = document.getElementById('sum-best-note');
  const elGrowth = document.getElementById('sum-growth');

  // if(!grade || !section){
  //   elWeek.textContent = elBest.textContent = elGrowth.textContent = "-";
  //   elBestNote.textContent = "—";
  //   return;
  // }

  const {weekAvg, best, growth} = summarizeWpm(grade, section);
  elWeek.textContent = (weekAvg!=null) ? `${weekAvg}` : "-";

  if(best){
    elBest.textContent = `${best.wpm}`;
    elBestNote.textContent = `${best.mode.toUpperCase()} / ${new Date(best.ts).toLocaleDateString()}`;
  }else{
    elBest.textContent = "-";
    elBestNote.textContent = "—";
  }

  if(growth!=null){
    elGrowth.textContent = `${growth>0?'+':''}${growth}%`;
    elGrowth.className = `text-3xl font-mono font-bold mt-1 ${growth>=0 ? 'text-emerald-600' : 'text-rose-600'}`;
  }else{
    elGrowth.textContent = "-";
    elGrowth.className = 'text-3xl font-mono font-bold text-rose-600 mt-1';
  }
}

/* Chart helpers */
function movingAverage(arr, win){
  if(!arr || arr.length===0) return [];
  const w = Math.max(1, win|0);
  const out = [];
  for(let i=0;i<arr.length;i++){
    const start = Math.max(0, i-w+1);
    const slice = arr.slice(start, i+1);
    const avg = slice.reduce((a,b)=>a+b,0)/slice.length;
    out.push(avg);
  }
  return out;
}


function dayKeyTs(ts){
  const d = new Date(ts);
  d.setHours(0,0,0,0);
  return d.getTime();
}
function fmtMD(ts){
  const d = new Date(ts);
  const m = d.getMonth()+1;
  const day = d.getDate();
  return `${m}/${day}`;
}
function movingAverageWithNull(arr, win){
  const w = Math.max(1, win|0);
  const out = [];
  for(let i=0;i<arr.length;i++){
    // take last up to w non-null values (including i)
    const vals = [];
    for(let j=i; j>=0 && vals.length<w; j--){
      const v = arr[j];
      if(v!=null && !Number.isNaN(v)) vals.push(v);
    }
    if(vals.length===0) out.push(null);
    else out.push(vals.reduce((a,b)=>a+b,0)/vals.length);
  }
  return out;
}

function renderWpmHistoryTable(limit=50){
  const body = document.getElementById('wpm-history-body');
  if(!body) return;
  body.innerHTML = '';

  const rows = historyData
    // No filter: show all history
    .sort((a,b)=>b.ts-a.ts)
    .slice(0, limit);

  if(rows.length===0){
    body.innerHTML = '<tr><td class="p-4 pl-5 text-slate-400" colspan="4">履歴がありません</td></tr>';
    return;
  }

  const modeLabel = (m)=> (m==='normal'?'Normal':(m==='hard'?'Hard':'Ex-Hard'));
  const modeBadge = (m)=>{
    if(m==='normal') return '<span class="px-2 py-0.5 rounded-full text-[11px] font-extrabold bg-sky-50 text-sky-700 border border-sky-200">Normal</span>';
    if(m==='hard') return '<span class="px-2 py-0.5 rounded-full text-[11px] font-extrabold bg-orange-50 text-orange-700 border border-orange-200">Hard</span>';
    return '<span class="px-2 py-0.5 rounded-full text-[11px] font-extrabold bg-rose-50 text-rose-700 border border-rose-200">Ex-Hard</span>';
  };

  rows.forEach((r, i)=>{
    const tr = document.createElement('tr');
    tr.className = (i%2===0) ? 'border-b border-slate-100 bg-white' : 'border-b border-slate-100 bg-slate-50/50';
    tr.innerHTML = `
      <td class="p-3 pl-5 text-slate-600 font-mono text-xs">${new Date(r.ts).toLocaleDateString('ja-JP')}</td>
      <td class="p-3 font-bold text-slate-700"><span class="text-[10px] text-slate-400 mr-1">G${r.grade}</span>${r.section}</td>
      <td class="p-3 text-center">${modeBadge(r.mode)}</td>
      <td class="p-3 pr-5 text-right font-mono font-extrabold text-slate-700">${(r && r.validWpm===false) ? '—' : r.wpm}</td>
    `;
    body.appendChild(tr);
  });
}

function renderWpmChartAllModes(days=30, showMA=true, maWin=5){
  const canvas = document.getElementById('wpm-chart');
  const note = document.getElementById('wpm-chart-note');
  const bestBox = document.getElementById('wpm-best-by-mode');
  if(!canvas) return;

  const cssW = canvas.clientWidth;
  const cssH = 220;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(cssW*dpr);
  canvas.height = Math.floor(cssH*dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  if(bestBox) bestBox.textContent = '';

  const modes = ["normal","hard","extra"];
  const labels = {normal:"Normal", hard:"Hard", extra:"Ex-Hard"};
  const colors = {normal:"#0ea5e9", hard:"#f97316", extra:"#ec4899"};

  const filtered = historyData
    // No filter: Global aggregation
    .sort((a,b)=>a.ts-b.ts);

  if(filtered.length===0){
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#94a3b8";
    ctx.fillText("WPM履歴がまだありません", 12, 28);
    if(note) note.textContent = "";
    if(bestBox) bestBox.textContent = "";
    return;
  }

  // Aggregate by day: take MAX WPM per day per mode
  const dayMap = new Map(); // dayTs -> {normal: wpm, hard: wpm, extra: wpm}
  filtered.forEach(r=>{
    if(!isValidWpmRow(r)) return;
    const dts = dayKeyTs(r.ts);
    if(!dayMap.has(dts)) dayMap.set(dts, {normal:null, hard:null, extra:null});
    const obj = dayMap.get(dts);
    const cur = obj[r.mode];
    if(cur==null || r.wpm > cur) obj[r.mode] = r.wpm;
  });

  let dayKeys = Array.from(dayMap.keys()).sort((a,b)=>a-b);

  // Limit to last N days with any record (not calendar days)
  if(days && dayKeys.length > days){
    dayKeys = dayKeys.slice(-days);
  }

  const series = {};
  const allVals = [];

  modes.forEach(m=>{
    const vals = dayKeys.map(dts=>{
      const v = dayMap.get(dts)?.[m];
      return (v==null) ? null : v;
    });
    const ma = showMA ? movingAverageWithNull(vals, maWin) : [];
    series[m] = {vals, ma};
    vals.forEach(v=>{ if(v!=null) allVals.push(v); });
    if(showMA) ma.forEach(v=>{ if(v!=null) allVals.push(v); });
  });

  if(allVals.length===0){
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#94a3b8";
    ctx.fillText("この範囲にはデータがありません", 12, 28);
    if(note) note.textContent = "";
    if(bestBox) bestBox.textContent = "";
    return;
  }

  const min = Math.min(...allVals);
  const max = Math.max(...allVals);

  const top=18, left=44, right=18, bottom=28;
  const x0=left, x1=cssW-right;
  const y0=top, y1=cssH-bottom;

  const yMin = Math.max(0, Math.floor(min-5));
  const yMax = Math.max(yMin+10, Math.ceil(max+5));
  const yScale = (y1-y0)/(yMax-yMin);

  // axes
  ctx.strokeStyle="#e2e8f0"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke();

  // ticks
  ctx.fillStyle="#94a3b8"; ctx.font="11px sans-serif";
  const ticks = [yMin, Math.round((yMin+yMax)/2), yMax];
  ticks.forEach(t=>{
    const y = y1 - (t-yMin)*yScale;
    ctx.strokeStyle="#f1f5f9";
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
    ctx.fillText(String(t), 8, y+4);
  });

  // x labels (start/mid/end)
  const n = dayKeys.length;
  const xStep = (n<=1)?0:(x1-x0)/(n-1);
  ctx.fillStyle="#94a3b8"; ctx.font="11px sans-serif";
  if(n>=1){
    ctx.fillText(fmtMD(dayKeys[0]), x0, y1+18);
    if(n>=3){
      const mid = dayKeys[Math.floor((n-1)/2)];
      const mx = x0 + Math.floor((n-1)/2)*xStep;
      ctx.fillText(fmtMD(mid), mx-12, y1+18);
    }
    ctx.fillText(fmtMD(dayKeys[n-1]), x1-28, y1+18);
  }

  // legend
  let lx=x0, ly=12;
  ctx.font="12px sans-serif";
  modes.forEach(m=>{
    ctx.fillStyle = colors[m];
    ctx.fillRect(lx,ly,10,10);
    ctx.fillStyle="#475569";
    ctx.fillText(labels[m], lx+14, ly+10);
    lx += 92;
  });
  if(showMA){
    ctx.strokeStyle="#64748b";
    ctx.setLineDash([5,4]);
    ctx.beginPath(); ctx.moveTo(x0+280, ly+5); ctx.lineTo(x0+320, ly+5); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle="#475569";
    ctx.fillText(`MA(${maWin})`, x0+326, ly+10);
  }

  function drawLineWithNull(vals, color, width=2, dotted=false){
    if(!vals || vals.length===0) return;
    ctx.strokeStyle=color; ctx.lineWidth=width;
    if(dotted) ctx.setLineDash([6,4]); else ctx.setLineDash([]);
    ctx.beginPath();
    let started = false;
    for(let i=0;i<vals.length;i++){
      const v = vals[i];
      if(v==null || Number.isNaN(v)){
        started = false;
        continue;
      }
      const x = x0 + i*xStep;
      const y = y1 - (v - yMin)*yScale;
      if(!started){
        ctx.moveTo(x,y);
        started = true;
      }else{
        ctx.lineTo(x,y);
      }
    }
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawPoints(vals, color){
    ctx.fillStyle=color;
    for(let i=0;i<vals.length;i++){
      const v = vals[i];
      if(v==null || Number.isNaN(v)) continue;
      const x = x0 + i*xStep;
      const y = y1 - (v - yMin)*yScale;
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
    }
  }

  modes.forEach(m=>{
    drawLineWithNull(series[m].vals, colors[m], 2, false);
    drawPoints(series[m].vals, colors[m]);
    if(showMA) drawLineWithNull(series[m].ma, colors[m], 2, true);
  });

  // Best by mode (overall, not limited)
  const bestByMode = {normal:null, hard:null, extra:null};
  filtered.forEach(r=>{
    const cur = bestByMode[r.mode];
    if(cur==null || r.wpm>cur) bestByMode[r.mode]=r.wpm;
  });

  if(bestBox){
    const nBest = (bestByMode.normal==null)?'-':bestByMode.normal;
    const hBest = (bestByMode.hard==null)?'-':bestByMode.hard;
    const eBest = (bestByMode.extra==null)?'-':bestByMode.extra;
    bestBox.innerHTML = `
      <div class="flex flex-wrap items-center gap-3">
        <span class="text-xs font-bold text-slate-400 uppercase tracking-wider">今までのベスト</span>
        <span class="px-2 py-1 rounded-xl bg-sky-50 border border-sky-200 text-sky-700 text-sm font-extrabold">Normal ${nBest}</span>
        <span class="px-2 py-1 rounded-xl bg-orange-50 border border-orange-200 text-orange-700 text-sm font-extrabold">Hard ${hBest}</span>
        <span class="px-2 py-1 rounded-xl bg-rose-50 border border-rose-200 text-rose-700 text-sm font-extrabold">Ex-Hard ${eBest}</span>
        <span class="text-xs text-slate-400 ml-auto">※1日=その日の最高WPM（同日複数回ならMAX）</span>
      </div>
    `;
  }

  if(note){
    const from = fmtMD(dayKeys[0]);
    const to = fmtMD(dayKeys[dayKeys.length-1]);
    note.textContent = `全学年・全セクション統合｜横軸=日付（${from} → ${to}）｜直近${Math.min(days, dayKeys.length)}日分表示`;
  }

  // Summary is still specific to grade/section? Or should be global?
  // The summary cards (top of stats) are currently updated by renderWpmSummary(grade, section).
  // Since we removed selectors, we can't update them for a specific section easily here.
  // Let's just leave the summary cards showing "Select a section to see details" or similar,
  // OR make them global too. For now, let's show global stats.
  renderWpmSummary(null, null); // Show global stats
}



function setupChartSelectors(){
  const rangeSel = document.getElementById('chart-range');
  const maToggle = document.getElementById('chart-ma-toggle');
  const maWindow = document.getElementById('chart-ma-window');
  const histSel  = document.getElementById('wpm-hist-limit');
  if(!rangeSel || !maToggle || !maWindow) return;

  const redraw = ()=>{
    renderWpmChartAllModes(
      parseInt(rangeSel.value,10),
      maToggle.checked,
      parseInt(maWindow.value,10)
    );

    const lim = parseInt(histSel?.value || '50', 10);
    renderWpmHistoryTable(lim);
  };

  rangeSel.onchange=redraw;
  maToggle.onchange=redraw;
  maWindow.onchange=redraw;
  if(histSel) histSel.onchange=redraw;

  redraw();
}



/* =========================================================
   Answer Count chart (Anki-like)
   - Uses srsLog (per-answer events)
   - Stacked bars: monthly answer counts by category
   - Optional lines: cumulative counts (right axis)
========================================================= */
function niceCeil(v){
  if(!isFinite(v) || v<=0) return 10;
  const exp = Math.floor(Math.log10(v));
  const base = Math.pow(10, exp);
  const n = v/base;
  const step = (n<=1)?1:(n<=2)?2:(n<=5)?5:10;
  return step*base;
}

function modeDisplay(m){
  if(m==='normal') return 'Normal';
  if(m==='hard') return 'Hard';
  if(m==='extra') return 'Ex-Hard';
  if(m==='all') return 'All';
  return String(m||'');
}
function monthIndexFromTs(ts){
  const d = new Date(ts);
  return d.getFullYear()*12 + d.getMonth(); // month 0-11
}
function ymLabelFromMonthIndex(mi){
  const y = Math.floor(mi/12);
  const m = mi%12 + 1;
  return `${String(y).slice(2)}/${String(m).padStart(2,'0')}`;
}

function buildMonthlyBins(modeFilter, months){
  const now = new Date();
  const curMi = now.getFullYear()*12 + now.getMonth();
  const startMi = curMi - (months-1);

  const bins = Array.from({length:months}, ()=>({
    mature:0, young:0, relearning:0, learning:0, cram:0
  }));

  const LOG = getActiveSrsLog();

  const filtered = (Array.isArray(LOG)?LOG:[])
    .filter(e=>e && typeof e.ts==='number')
    .filter(e=>{
      if(modeFilter && modeFilter!=='all' && e.mode !== modeFilter) return false;
      const mi = monthIndexFromTs(e.ts);
      return mi>=startMi && mi<=curMi;
    });

  filtered.forEach(e=>{
    const mi = monthIndexFromTs(e.ts);
    const idx = mi - startMi;
    if(idx<0 || idx>=months) return;
    const c = e.category || 'learning';
    if(bins[idx][c]==null) bins[idx][c]=0;
    bins[idx][c] += 1;
  });

  const labels = Array.from({length:months}, (_,i)=>ymLabelFromMonthIndex(startMi+i));

  return {labels, bins, filtered, startMi, curMi};
}

function renderReviewCountChart(modeFilter='all', months=24, showLines=true){
  const canvas = document.getElementById('review-count-chart');
  const note = document.getElementById('review-count-note');
  const summary = document.getElementById('review-count-summary');
  if(!canvas) return;

  const cssW = canvas.clientWidth;
  const cssH = 260;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(cssW*dpr);
  canvas.height = Math.floor(cssH*dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  const LOG = getActiveSrsLog();

  const hasLog = Array.isArray(LOG) && LOG.length>0;
  if(!hasLog){
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#94a3b8";
    ctx.fillText("まだSRSログがありません（1問でも解けばここに貯まります）", 12, 28);
    if(note) note.textContent = "";
    if(summary) summary.textContent = "";
    return;
  }

  const {labels, bins, filtered} = buildMonthlyBins(modeFilter, months);

  const orderCats = ['mature','young','relearning','learning','cram'];
  const catLabel = {
    mature:'定着済', young:'定着中', relearning:'学び直し', learning:'学習', cram:'詰め込み'
  };
  const colors = {
    mature:'#16a34a',   // green
    young:'#86efac',    // light green
    relearning:'#ef4444',// red
    learning:'#3b82f6', // blue
    cram:'#facc15'      // yellow
  };

  const totals = bins.map(b=>orderCats.reduce((s,c)=>s+(b[c]||0),0));
  const maxBar = Math.max(1, ...totals);
  const yLeftMax = niceCeil(maxBar);

  // cumulative (right axis)
  const cum = {};
  orderCats.forEach(c=>cum[c]=[]);
  let run = {};
  orderCats.forEach(c=>run[c]=0);
  for(let i=0;i<bins.length;i++){
    orderCats.forEach(c=>{
      run[c] += (bins[i][c]||0);
      cum[c].push(run[c]);
    });
  }
  const cumMax = Math.max(1, ...orderCats.map(c=>cum[c][cum[c].length-1]||0));
  const yRightMax = niceCeil(cumMax);

  const top=18, left=44, right=52, bottom=34;
  const x0=left, x1=cssW-right;
  const y0=top, y1=cssH-bottom;

  // axes
  ctx.strokeStyle="#e2e8f0"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke();
  // right axis
  ctx.beginPath(); ctx.moveTo(x1,y0); ctx.lineTo(x1,y1); ctx.stroke();

  // grid + left ticks
  ctx.fillStyle="#94a3b8"; ctx.font="11px sans-serif";
  const leftTicks = [0, Math.round(yLeftMax/2), yLeftMax];
  leftTicks.forEach(t=>{
    const y = y1 - (t/yLeftMax)*(y1-y0);
    ctx.strokeStyle="#f1f5f9";
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
    ctx.fillStyle="#94a3b8";
    ctx.fillText(String(t), 8, y+4);
  });

  // right ticks
  const rightTicks = [0, Math.round(yRightMax/2), yRightMax];
  rightTicks.forEach(t=>{
    const y = y1 - (t/yRightMax)*(y1-y0);
    ctx.fillStyle="#94a3b8";
    ctx.fillText(String(t), x1+6, y+4);
  });

  const n = labels.length;
  const step = (x1-x0)/n;
  const barW = Math.max(4, step*0.72);

  // bars (stacked)
  for(let i=0;i<n;i++){
    const x = x0 + i*step + (step-barW)/2;
    let yTop = y1;
    orderCats.forEach(cat=>{
      const v = bins[i][cat]||0;
      if(v<=0) return;
      const h = (v/yLeftMax) * (y1-y0);
      yTop -= h;
      ctx.fillStyle = colors[cat];
      ctx.fillRect(x, yTop, barW, h);
    });
  }

  // x labels (every 3 months)
  ctx.fillStyle="#94a3b8"; ctx.font="10px sans-serif";
  for(let i=0;i<n;i++){
    if(n>14 && i%3!==0 && i!==n-1) continue;
    const x = x0 + i*step + step/2;
    const lab = labels[i];
    ctx.save();
    ctx.translate(x, y1+14);
    ctx.rotate(-Math.PI/6);
    ctx.textAlign='center';
    ctx.fillText(lab, 0, 0);
    ctx.restore();
  }

  // legend
  let lx=x0, ly=10;
  ctx.font="12px sans-serif";
  orderCats.forEach(cat=>{
    ctx.fillStyle = colors[cat];
    ctx.fillRect(lx,ly,10,10);
    ctx.fillStyle="#475569";
    ctx.fillText(catLabel[cat], lx+14, ly+10);
    lx += 84;
  });

  // lines (cumulative)
  if(showLines){
    orderCats.forEach(cat=>{
      const vals = cum[cat];
      ctx.strokeStyle = colors[cat];
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.75;
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const x = x0 + i*step + step/2;
        const y = y1 - ((vals[i]||0)/yRightMax)*(y1-y0);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    });
  }

  const totalInRange = filtered.length;
  if(note){
    note.textContent = `棒＝月別の回答数（左軸）／線＝累計（右軸）｜対象：${deckDisplay()} / ${modeFilter==='all'?'All modes':modeDisplay(modeFilter)}｜期間：${months}か月｜合計：${totalInRange}回`;
  }

  // summary (study days ratio)
  if(summary){
    const LOG2 = getActiveSrsLog();
    const ev = (Array.isArray(LOG2)?LOG2:[]).filter(e=>{
      if(modeFilter && modeFilter!=='all' && e.mode !== modeFilter) return false;
      return e && typeof e.ts==='number';
    });
    if(ev.length===0){
      summary.textContent = "";
    }else{
      const minTs = Math.min(...ev.map(e=>e.ts));
      const first = new Date(minTs); first.setHours(0,0,0,0);
      const today = new Date(); today.setHours(0,0,0,0);
      const totalDays = Math.max(1, Math.floor((today-first)/86400000)+1);

      const daySet = new Set(ev.map(e=>{
        const d = new Date(e.ts);
        return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
      }));
      const studiedDays = daySet.size;
      const ratio = Math.round((studiedDays/totalDays)*100);

      const totalAll = ev.length;
      const avgPerDay = (totalAll/totalDays).toFixed(1);
      const avgWhen = (totalAll/Math.max(1,studiedDays)).toFixed(1);

      summary.innerHTML = `
        <div class="text-slate-500 font-bold mb-1">学習サマリー（${modeFilter==='all'?'全モード':modeDisplay(modeFilter)}）</div>
        <div>学習した日数の割合：<span class="font-bold">${ratio}%</span>（${studiedDays} / ${totalDays}）</div>
        <div>合計：<span class="font-bold">${totalAll}</span> 回答</div>
        <div>学習した日の平均：<span class="font-bold">${avgWhen}</span> 回/日</div>
        <div>毎日学習した場合の平均：<span class="font-bold">${avgPerDay}</span> 回/日</div>
      `;
    }
  }
}

function setupReviewChartSelectors(){
  const rangeSel = document.getElementById('review-range');
  const lineTgl = document.getElementById('review-lines-toggle');
  if(!rangeSel || !lineTgl) return;

  const redraw = ()=>redrawSrsCharts();

  rangeSel.onchange = redraw;
  lineTgl.onchange  = redraw;

  redraw();
}

/* =========================================================
   Due Forecast chart (Anki-like)
   - Uses srsData (per-card schedule)
   - Bars: number of due cards per day for next N days
========================================================= */
function startOfDayTs(ts){
  const d = new Date(ts);
  d.setHours(0,0,0,0);
  return d.getTime();
}

function buildDueForecastBins(gradeFilter='all', modeFilter='all', days=30, includeOverdue=true){
  const msDay = 86400000;
  const today0 = startOfDayTs(Date.now());

  const bins = Array.from({length:days}, ()=>0);
  const labels = Array.from({length:days}, (_,i)=>{
    const d = new Date(today0 + i*msDay);
    return `${d.getMonth()+1}/${String(d.getDate()).padStart(2,'0')}`;
  });

  let overdue = 0;
  let total = 0;

  const DATA = getActiveSrsData();

  for(const [k, card] of Object.entries(DATA||{})){
    if(!k || typeof k !== 'string') continue;
    const parts = k.split('||');
    if(parts.length < 4) continue;

    const g = parts[0];
    const m = parts[2];

    if(gradeFilter && gradeFilter!=='all' && g !== String(gradeFilter)) continue;
    if(modeFilter && modeFilter!=='all' && m !== modeFilter) continue;

    if(!card || typeof card.dueTs !== 'number' || card.dueTs<=0) continue;
    total++;

    let dueTs = card.dueTs;
    if(dueTs < today0){
      overdue++;
      if(includeOverdue) dueTs = today0;
      else continue;
    }

    const d0 = startOfDayTs(dueTs);
    const idx = Math.floor((d0 - today0)/msDay);
    if(idx>=0 && idx<days) bins[idx] += 1;
  }

  const dueToday = bins[0] || 0;
  const due7 = bins.slice(0, Math.min(7,days)).reduce((a,b)=>a+b,0);
  const dueAll = bins.reduce((a,b)=>a+b,0);

  return {labels, bins, overdue, total, dueToday, due7, dueAll, today0};
}

function renderDueForecastChart(gradeFilter='all', modeFilter='all', days=30, includeOverdue=true){
  const canvas = document.getElementById('due-forecast-chart');
  const note = document.getElementById('due-forecast-note');
  const summary = document.getElementById('due-forecast-summary');
  if(!canvas) return;

  const cssW = canvas.clientWidth;
  const cssH = 220;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.floor(cssW*dpr);
  canvas.height = Math.floor(cssH*dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  const DATA2 = getActiveSrsData();
  const hasSrs = DATA2 && Object.keys(DATA2).length>0;
  if(!hasSrs){
    ctx.font = "14px sans-serif";
    ctx.fillStyle = "#94a3b8";
    ctx.fillText("まだSRSデータがありません（SRSをONにして1問でも解くと貯まります）", 12, 28);
    if(note) note.textContent = "";
    if(summary) summary.textContent = "";
    return;
  }

  const {labels, bins, overdue, total, dueToday, due7, dueAll, today0} =
    buildDueForecastBins(gradeFilter, modeFilter, days, includeOverdue);

  const maxBar = Math.max(1, ...bins);
  const yMax = niceCeil(maxBar);

  const top=18, left=44, right=16, bottom=34;
  const x0=left, x1=cssW-right;
  const y0=top, y1=cssH-bottom;

  // axes
  ctx.strokeStyle="#e2e8f0"; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x0,y1); ctx.lineTo(x1,y1); ctx.stroke();

  // grid + ticks
  ctx.fillStyle="#94a3b8"; ctx.font="11px sans-serif";
  const ticks = [0, Math.round(yMax/2), yMax];
  ticks.forEach(t=>{
    const y = y1 - (t/yMax)*(y1-y0);
    ctx.strokeStyle="#f1f5f9";
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke();
    ctx.fillStyle="#94a3b8";
    ctx.fillText(String(t), 8, y+4);
  });

  // bars
  const n = labels.length;
  const step = (x1-x0)/n;
  const barW = Math.max(3, step*0.8);

  for(let i=0;i<n;i++){
    const v = bins[i]||0;
    if(v<=0) continue;
    const h = (v/yMax)*(y1-y0);
    const x = x0 + i*step + (step-barW)/2;
    const y = y1 - h;
    // today highlight
    ctx.fillStyle = (i===0) ? "#6366f1" : "#a5b4fc";
    ctx.fillRect(x, y, barW, h);
  }

  // x labels (every few days)
  ctx.fillStyle="#94a3b8"; ctx.font="10px sans-serif";
  const every = (days<=14)?1:(days<=30)?3:7;
  for(let i=0;i<n;i++){
    if(i%every!==0 && i!==n-1) continue;
    const x = x0 + i*step + step/2;
    ctx.save();
    ctx.translate(x, y1+14);
    ctx.rotate(-Math.PI/6);
    ctx.textAlign='center';
    ctx.fillText(labels[i], 0, 0);
    ctx.restore();
  }

  // title note
  const gLabel = (gradeFilter==='all') ? 'All grades' : ((gradeFilter==='custom') ? 'Custom' : `Grade ${gradeFilter}`);
  const mLabel = (modeFilter==='all') ? 'All modes' : modeDisplay(modeFilter);
  if(note){
    note.textContent = `棒＝日別の復習予定（次の${days}日）｜対象：${deckDisplay()} / ${gLabel} / ${mLabel}｜期限切れ：${includeOverdue?'今日に含める':'除外'}`;
  }

  // summary
  if(summary){
    const end = new Date(today0 + (days-1)*86400000);
    const endStr = `${end.getMonth()+1}/${String(end.getDate()).padStart(2,'0')}`;
    summary.innerHTML = `
      <div class="text-slate-500 font-bold mb-1">復習サマリー</div>
      <div>期限切れ（overdue）：<span class="font-bold">${overdue}</span> 件</div>
      <div>今日のdue：<span class="font-bold">${dueToday}</span> 件</div>
      <div>7日以内のdue：<span class="font-bold">${due7}</span> 件</div>
      <div>${days}日以内（〜${endStr}）のdue：<span class="font-bold">${dueAll}</span> 件</div>
      <div>登録カード（dueTsあり）：<span class="font-bold">${total}</span> 件</div>
    `;
  }
}

function setupDueForecastSelectors(){
  const gradeSel = document.getElementById('due-grade');
  const daysSel  = document.getElementById('due-days');
  const overdueTgl = document.getElementById('due-overdue-toggle');
  if(!gradeSel || !daysSel || !overdueTgl) return;

  // populate grade options once (keep selection if possible)
  const prev = gradeSel.value || 'all';
  gradeSel.innerHTML = '<option value="all">All grades</option>';
  Object.keys(gradeMap).sort((a,b)=>{
    if(a==='custom') return 1;
    if(b==='custom') return -1;
    return a-b;
  }).forEach(g=>{
    const opt = document.createElement('option');
    opt.value = g;
    opt.textContent = (g==='custom') ? 'Custom' : `Grade ${g}`;
    gradeSel.appendChild(opt);
  });
  gradeSel.value = (Array.from(gradeSel.options).some(o=>o.value===prev)) ? prev : 'all';

  const redraw = ()=>redrawSrsCharts();

  gradeSel.onchange = redraw;
  daysSel.onchange  = redraw;
  overdueTgl.onchange = redraw;

  redraw();
}

/* =========================================================
   Stats list render
========================================================= */
function renderStatsList(){
  const container = document.getElementById('stats-list-container');
  container.innerHTML='';

  const list = [];
  const sortedGrades = Object.keys(gradeMap).sort((a,b)=>{
    if(a==='custom') return 1;
    if(b==='custom') return -1;
    return a-b;
  });

  sortedGrades.forEach(g=>{
    const secs = Array.from(gradeMap[g]).sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}));
    secs.forEach(s=>{
      const key = keyFor(g,s);
      const stat = statsData[key];
      const count = allWords.filter(w=>w.grade===g && w.section.includes(s)).length;
      if(stat) list.push({grade:g, section:s, count, ...stat});
    });
  });

  if(list.length===0){
    container.innerHTML='<div class="p-8 text-center text-gray-400">学習履歴がありません</div>';
    return;
  }

  list.forEach((item,idx)=>{
    const row = document.createElement('div');
    row.className = `grid grid-cols-12 gap-2 p-3 text-sm border-b border-slate-100 hover:bg-slate-50 transition ${idx%2===0?'bg-white':'bg-slate-50/50'}`;

    const gradeDisplay = item.grade==='custom' ? '<span class="text-rose-500"><i class="fas fa-star"></i></span>' : `G${item.grade}`;
    const fmt = (s)=>{
      if(s.score===0) return '<span class="text-gray-300">-</span>';
      const crown = s.score>=item.count ? '👑' : '';
      return `<div>${s.score}/${item.count}${crown}</div><div class="text-[10px] text-gray-400">${s.wpm}wpm</div>`;
    };

    row.innerHTML = `
      <div class="col-span-1 pl-4 text-slate-500 font-bold font-mono self-center">${gradeDisplay}</div>
      <div class="col-span-3 font-bold text-slate-700 truncate self-center">${item.section}</div>
      <div class="col-span-8 grid grid-cols-3 gap-2 text-center">
        <div>${fmt(item.normal)}</div>
        <div>${fmt(item.hard)}</div>
        <div>${fmt(item.extra)}</div>
      </div>
    `;
    container.appendChild(row);
  });
}

/* =========================================================
   Session Execution: unique questions, early clear, resume progress
========================================================= */
let sessionInterval = null;
let sessionTargets = [];
let order = [];     // indices into sessionTargets (includes repeats inserted by SRS)
let queuePos = 0;   // pointer in order
let masteredSet = new Set(); // indices that reached Good in this run
let correctChars = 0;

// Keystroke-based WPM (more realistic; ignores autocorrect/predictive bursts)
let ksTotal = 0;      // total character key presses (incl. spaces/punct)
let ksCorrect = 0;    // key presses that matched expected char at that moment
let ksBackspace = 0;  // backspace count (debug)
let totalActiveTimeMs = 0;


// WPM timing (starts on first keystroke of this run)
let sessionStartMs = 0;
let sessionEndMs = 0; // WPM timing end (set at finish)
let usedSoftKeyboard = false; // true if on-screen keyboard was used during this run
let timerStartMs = 0; // when the countdown timer starts (used for fair WPM in timed mode)


let sessionStarted = false;
// per-question tracking
let qStartTs = 0;
let qHadMistake = false;
let qMaxPauseMs = 0;
let qPauseCount = 0;
let qLastInputTs = 0;
let qFirstInput = false;
let qActiveTypedMs = 0;
let isCoarsePointer = false;


let totalSeconds = 0;
let timeLeftSec = 0;
let isTransitioning = false;

// === Mobile keyboard helpers (v9) ===
(function(){
  try{
    isCoarsePointer = false;
    try{
      const coarse = !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
      const touch = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);
      isCoarsePointer = coarse || touch;
    }catch(e){ isCoarsePointer = ('ontouchstart' in window) || (navigator.maxTouchPoints>0); }
  }catch(e){ isCoarsePointer = false; }

  const setKb = () => {
    // iOS Safari: visualViewport gives the "visible" area excluding the keyboard
    const vv = window.visualViewport;
    let kb = 0;
    if(vv){
      const innerH = window.innerHeight || 0;
      kb = Math.max(0, innerH - vv.height - vv.offsetTop);
      // When keyboard is open, kb is usually > 150
      document.body.classList.toggle('kb-open', kb > 150);
    
      if(kb > 150 && sessionStarted && !sessionEnded) usedSoftKeyboard = true;
}else{
      document.body.classList.remove('kb-open');
    }
    document.documentElement.style.setProperty('--kb-offset', kb + 'px');
  };

  // run now + on viewport changes
  window.addEventListener('resize', setKb, {passive:true});
  window.addEventListener('orientationchange', setKb, {passive:true});
  if(window.visualViewport){
    window.visualViewport.addEventListener('resize', setKb, {passive:true});
    window.visualViewport.addEventListener('scroll', setKb, {passive:true});
  }
  setKb();
})();


function getProgressKey(){
  return keyForMode(currentSettings.grade, currentSettings.section, currentSettings.mode);
}

function setProgress(){
  if(currentSettings.srsReviewOnly) return;
  const k = getProgressKey();
  progressData[k] = {
    order,
    pos: queuePos,
    correctChars,
    mastered: Array.from(masteredSet)
  };
  saveAll();
}

function clearProgress(){
  if(currentSettings.srsReviewOnly) return;
  const k = getProgressKey();
  delete progressData[k];
  saveAll();
}

function getTargets(){
  // Normal: within a specific section
  if(currentSettings.section==='__ALL__'){
    // ALL-sections review/practice: all sections within this grade
    return allWords.filter(w=>w.grade===currentSettings.grade);
  }
  return allWords.filter(w=>w.grade===currentSettings.grade && w.section.includes(currentSettings.section));
}

/* ▼▼▼ 追加機能：FSRS分布＆ヒートマップ ▼▼▼ */
function renderFSRSDistributions(gradeFilter='all', modeFilter='all') {
  const cR=document.getElementById('chart-retrievability'), cD=document.getElementById('chart-difficulty'), cS=document.getElementById('chart-stability');
  if(!cR||!cD||!cS)return;
  const cards=[], now=Date.now();
  const DATA = getActiveSrsData();
  for(const [k,c] of Object.entries(DATA||{})){
    if(!k||typeof k!=='string')continue; const p=k.split('||'); if(p.length<4)continue;
    if(gradeFilter!=='all'&&p[0]!==String(gradeFilter))continue;
    if(modeFilter!=='all'&&p[2]!==modeFilter)continue;
    const diff=c.difficulty||5, stab=c.stability||(c.intervalDays||0), last=c.lastReviewTs||c.dueTs||now;
    let r=0;
    if(c.state!=='new'&&stab>0){ const el=Math.max(0,(now-last)/86400000); r=Math.pow(1+(19/81)*(el/stab),-1); }
    cards.push({r,d:diff,s:stab});
  }
  const summary=document.getElementById('fsrs-stats-summary'); if(summary)summary.textContent=`Total Cards: ${cards.length}`;
  
  const draw=(cv,d,lbl,col)=>{
    const dpr=window.devicePixelRatio||1, rect=cv.getBoundingClientRect();
    cv.width=rect.width*dpr; cv.height=rect.height*dpr;
    const ctx=cv.getContext('2d'); ctx.scale(dpr,dpr); ctx.clearRect(0,0,rect.width,rect.height);
    const max=Math.max(...d)||1, W=rect.width, H=rect.height, cH=H-18, step=W/d.length, bW=Math.max(2,step-2);
    d.forEach((v,i)=>{
      const h=(v/max)*cH, x=i*step+(step-bW)/2;
      ctx.fillStyle=col; ctx.fillRect(x,4+(cH-h),bW,h);
      if(i%2===0||d.length<8){ ctx.fillStyle="#94a3b8"; ctx.font="9px sans-serif"; ctx.textAlign="center"; ctx.fillText(lbl[i],x+bW/2,H-2); }
    });
  };

  const bR=Array(10).fill(0); cards.forEach(c=>bR[Math.min(9,Math.floor(c.r*10))]++);
  draw(cR,bR,['0%','10','20','30','40','50','60','70','80','90%'],'#6366f1');

  const bD=Array(10).fill(0); cards.forEach(c=>bD[Math.min(9,Math.max(0,Math.round(c.d)-1))]++);
  draw(cD,bD,['1','2','3','4','5','6','7','8','9','10'],'#f59e0b');

  const sR=[1,3,7,14,30,90,180,365,99999], sL=['1d','3d','7d','14d','1m','3m','6m','1y','+'], bS=Array(sR.length).fill(0);
  cards.forEach(c=>{ if(c.s>0){ const i=sR.findIndex(l=>c.s<l); if(i!==-1)bS[i]++; } });
  draw(cS,bS,sL,'#10b981');
}

function renderHeatmap(gradeFilter='all', modeFilter='all'){
  const grid=document.getElementById('hm-grid'), mEl=document.getElementById('hm-months'); if(!grid)return;
  grid.innerHTML=''; mEl.innerHTML='';
  
  // データ集計
  const counts={}, logs=getActiveSrsLog();
  let total=0;
  logs.forEach(l=>{
    if(!l||!l.ts) return;
    if(gradeFilter!=='all'){ const g=l.grade||(l.cardId?l.cardId.split('|')[0]:null); if(String(g)!==String(gradeFilter))return; }
    if(modeFilter!=='all'&&l.mode!==modeFilter)return;
    const d=new Date(l.ts), k=`${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()}`;
    counts[k]=(counts[k]||0)+1; total++;
  });
  
  // 色分け閾値
  const vals=Object.values(counts).filter(v=>v>0).sort((a,b)=>a-b);
  let q1=1,q2=3,q3=6,q4=10;
  if(vals.length>5){ q1=vals[Math.floor(vals.length*0.25)]; q2=vals[Math.floor(vals.length*0.5)]; q3=vals[Math.floor(vals.length*0.75)]; q4=vals[Math.floor(vals.length*0.9)]; }
  const col=n=>n===0?'bg-slate-200':(n<=q1?'bg-emerald-200':(n<=q2?'bg-emerald-300':(n<=q3?'bg-emerald-500':'bg-emerald-800')));

  // カレンダー生成準備
  const today=new Date(); today.setHours(0,0,0,0);
  const start=new Date(today); start.setDate(today.getDate()-365);
  while(start.getDay()!==1) start.setDate(start.getDate()-1); // 月曜始まりに調整

  let d=new Date(start);
  let html='';
  
  // 月ラベル管理用
  let currentMonthLabel = null;
  let currentMonthWeeks = 0;
  let lastMonth = -1;

  // 371日分（53週分）ループ
  for(let i=0; i<371; i++){
    const k=`${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()}`, n=counts[k]||0;
    
    // ■ 月ラベルの処理（週の頭＝月曜日に判定）
    if(d.getDay()===1){
      const m = d.getMonth();
      if(m !== lastMonth){
        // 月が変わったら、前の月のラベル幅を確定させる
        if(currentMonthLabel){
          // 1週あたり約15px (w-3=12px + gap=3px)
          currentMonthLabel.style.width = (currentMonthWeeks * 15) + 'px'; 
        }
        
        // 新しい月のラベルを作成
        const lb = document.createElement('div');
        lb.textContent = d.toLocaleString('en-us', { month:'short' });
        lb.className = 'text-[10px] text-slate-400 truncate'; // 幅固定・文字あふれ防止
        lb.style.textAlign = 'left';
        mEl.appendChild(lb);
        
        currentMonthLabel = lb;
        currentMonthWeeks = 0;
        lastMonth = m;
      }
      currentMonthWeeks++; // この月の週数をカウント
    }

    // マス目生成
    html+=`<div class="${col(n)} rounded-[1px] w-3 h-full hover:ring-2 hover:ring-slate-400 cursor-pointer" title="${k}: ${n} reviews"></div>`;
    d.setDate(d.getDate()+1);
  }
  
  // 最後の月の幅を確定
  if(currentMonthLabel){
    currentMonthLabel.style.width = (currentMonthWeeks * 15) + 'px';
  }

  grid.innerHTML=html;

  // ストリーク計算（変更なし）
  let curr=0, long=0, tmp=0, check=new Date(today);
  while(true){
    const k=`${check.getFullYear()}-${check.getMonth()+1}-${check.getDate()}`;
    if(counts[k]>0){curr++; check.setDate(check.getDate()-1);}
    else{ if(k===`${today.getFullYear()}-${today.getMonth()+1}-${today.getDate()}`){check.setDate(check.getDate()-1); continue;} break; }
  }
  if(Object.keys(counts).length>0){
    const sorted=Object.keys(counts).sort((a,b)=>new Date(a)-new Date(b)), sD=new Date(sorted[0]), eD=new Date(sorted[sorted.length-1]), itr=new Date(sD);
    while(itr<=eD){
      const k=`${itr.getFullYear()}-${itr.getMonth()+1}-${itr.getDate()}`;
      if(counts[k]>0){tmp++; long=Math.max(long,tmp);}else{tmp=0;}
      itr.setDate(itr.getDate()+1);
    }
  }
  document.getElementById('hm-total').textContent=total.toLocaleString();
  document.getElementById('hm-current-streak').textContent=curr;
  document.getElementById('hm-longest-streak').textContent=long;
}

function setupSRSNewSelectors(){
  const fills=(id,fn)=>{
    const el=document.getElementById(id); if(!el)return;
    const prev=el.value; el.innerHTML='<option value="all">All Grades</option>';
    Object.keys(gradeMap||{}).sort().forEach(g=>{ const o=document.createElement('option'); o.value=g; o.textContent=`Grade ${g}`; el.appendChild(o); });
    el.value=prev; el.onchange=fn;
  };
  fills('fsrs-dist-grade',()=>renderFSRSDistributions(document.getElementById('fsrs-dist-grade').value, document.getElementById('fsrs-dist-mode').value));
  fills('heatmap-grade',()=>renderHeatmap(document.getElementById('heatmap-grade').value, document.getElementById('heatmap-mode').value));
  const hook=(id,fn)=>{const el=document.getElementById(id); if(el)el.onchange=fn;};
  hook('fsrs-dist-mode',()=>renderFSRSDistributions(document.getElementById('fsrs-dist-grade').value, document.getElementById('fsrs-dist-mode').value));
  hook('heatmap-mode',()=>renderHeatmap(document.getElementById('heatmap-grade').value, document.getElementById('heatmap-mode').value));
}
/* ▲▲▲ 追加機能終わり ▲▲▲ */

window.startSession = function(){
  stopBgm();
  // allow audio on first gesture (for iOS etc.)
  ensureAudioCtx();

  let targets = getTargets();
  if(targets.length===0) return alert("No data");

  // SRS review-only: due cards within this section (or ALL sections when section==='__ALL__')
  if(currentSettings.srsReviewOnly){
    const dueTargets = targets.filter(it=> (currentSettings.readingMode ? isReadDue(it, currentSettings.mode) : isDue(it, currentSettings.mode)) );
    if(dueTargets.length>0){
      targets = dueTargets;
    }else{
      alert("期限(due)の復習カードがありません。");
      // keep review-only on; just don't start
      return;
    }
  }

  sessionTargets = targets;

  const k = getProgressKey();
  const saved = progressData[k];

  const freshStart = ()=>{
    order = [...Array(sessionTargets.length).keys()];
    // shuffle (ランダム時のみ)
    if((currentSettings.questionOrder || 'random') !== 'registered'){
      for(let i=order.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [order[i],order[j]] = [order[j],order[i]];
      }
    }
    queuePos = 0;
    correctChars = 0;
    ksTotal = 0;
    ksCorrect = 0;
    ksBackspace = 0;
    masteredSet = new Set();
    setProgress();
  };

  if(saved && Array.isArray(saved.order) && typeof saved.pos === 'number' && !currentSettings.srsReviewOnly){
    // resume (only for normal start, not review-only)
    const ok = saved.order.every(i=>Number.isInteger(i) && i>=0 && i<sessionTargets.length);
    if(ok){
      order = saved.order;
      queuePos = saved.pos;
      correctChars = 0; // reset WPM counter on resume
      ksTotal = 0;
      ksCorrect = 0;
      ksBackspace = 0;
      masteredSet = new Set(Array.isArray(saved.mastered) ? saved.mastered : []);
    }else{
      freshStart();
    }
  }else{
    freshStart();
  }

  document.getElementById('practice-score').textContent = `${masteredSet.size}/${sessionTargets.length}`;
  document.getElementById('practice-mode-badge').textContent = modeDisplay(currentSettings.mode).toUpperCase() + (currentSettings.srsReviewOnly ? (currentSettings.readingMode ? ' (READ-SRS)' : ' (SRS)') : '') + (currentSettings.readingMode ? ' / 音読' : '');
  document.getElementById('practice-wpm-badge').textContent = currentSettings.readingMode ? 'WPM: —' : 'WPM: 0';
  try{ resetReadingEval(); }catch(e){}
  try{ document.getElementById('practice-judge-badge').textContent = '判定: …'; }catch(e){}
  sessionEnded = false;


  // reset WPM timer for this run
  sessionStartMs = 0;
  sessionStarted = false;
  sessionEndMs = 0;
  usedSoftKeyboard = false;
  timerStartMs = 0;
  ksTotal = 0;
  ksCorrect = 0;
  ksBackspace = 0;
  totalActiveTimeMs = 0;
  document.getElementById('practice-input').value = "";
  document.getElementById('practice-input').disabled = false;

  goToScreen('practice');

  // Mobile: external keyboardが無い時に内蔵キーボードがすぐ出るようにする（タップでも再表示）
  (function(){
    const ps = document.getElementById('screen-practice');
    if(ps && ps.dataset.kbfocusBound !== '1'){
      ps.dataset.kbfocusBound = '1';
      const refocus = ()=>{ if(isCoarsePointer) focusPracticeInput(); };
      ps.addEventListener('pointerdown', refocus, true);
      ps.addEventListener('touchstart', refocus, {passive:true, capture:true});
    }
  })();
  focusPracticeInput();
  requestAnimationFrame(()=>focusPracticeInput());

  setQuestion();
  startTimer(currentSettings.timeLimitMin * 60);
};

function currentQuestion(){
  if(queuePos >= order.length) return null;
  return sessionTargets[order[queuePos]];
}

/* =========================================================
   Auto-fit: word-displayを最大2行に収める（3行以上なら縮小）
   - 1〜2行で収まる場合はそのまま（元サイズに戻す）
   - 必要なときだけ font-size を下げます
========================================================= */
function countWordDisplayLines(){
  const display = document.getElementById('word-display');
  if(!display) return 1;
  const spans = display.querySelectorAll('.char-base');
  if(!spans || spans.length===0) return 1;

  const tops = new Set();
  spans.forEach(s=>{
    const r = s.getBoundingClientRect();
    // 小数誤差を吸収
    tops.add(Math.round(r.top));
  });
  return Math.max(1, tops.size);
}

function resetWordDisplaySizing(){
  const display = document.getElementById('word-display');
  if(!display) return;
  display.style.fontSize = '';
}

function fitWordDisplayToMaxLines(maxLines=2){
  const display = document.getElementById('word-display');
  if(!display) return;

  // いったん元に戻して判定（短い問題で縮小が残らないように）
  resetWordDisplaySizing();

  // DOM描画後にサイズ調整（iOS/Chromeで安定）
  requestAnimationFrame(()=>{
    // もう一度安全にリセット（途中で他処理が入る可能性）
    resetWordDisplaySizing();

    // すでに2行以内なら何もしない
    if(countWordDisplayLines() <= maxLines) return;

    const basePx = parseFloat(getComputedStyle(display).fontSize) || 48;
    const minPx  = 16; // ここを下げればさらに詰められます（読みやすさとのトレードオフ）

    let best = minPx;

    // まず最小まで落として、2行以内になるか確認
    display.style.fontSize = `${minPx}px`;
    void display.offsetHeight;

    if(countWordDisplayLines() <= maxLines){
      best = minPx;
    }else{
      // 2行に入らないほど長い場合：最小でも無理なら最小のまま（ここで終了）
      // ※ どうしても2行固定したい場合は、letter-spacing/左右padding調整も追加できます
      return;
    }

    // ここまで来たら minPx で2行以内に入るので、読みやすさ優先で「入る最大サイズ」を探す
    let lo = minPx, hi = basePx, ans = minPx;
    for(let i=0;i<12;i++){
      const mid = (lo + hi) / 2;
      display.style.fontSize = `${mid}px`;
      void display.offsetHeight;
      if(countWordDisplayLines() <= maxLines){
        ans = mid;
        lo = mid; // もっと大きくできるか試す
      }else{
        hi = mid;
      }
    }
    display.style.fontSize = `${Math.floor(ans)}px`;
  });
}

// 画面回転/リサイズでも崩れないように再フィット
window.addEventListener('resize', ()=>{
  // 練習画面のときだけ再調整（無駄な再計算を避ける）
  const session = document.getElementById('screen-practice');
  if(session && !session.classList.contains('hidden')){
    // Place cursor at the very beginning (inside the first word unit if present)
  const firstChar = display.querySelector('.char-base');
  if(firstChar && firstChar.parentNode) firstChar.parentNode.insertBefore(cursor, firstChar);

  fitWordDisplayToMaxLines(2);
  }
});





/* =========================================================
   Grammar role markup helpers (optional)
   - Add tags in the English field:
     [S]...[/S] [V]...[/V] [O]...[/O] [C]...[/C] [M]...[/M]
     (or <S>...</S> etc.)
   - Typing / TTS / SRS always use the *plain* text (tags are stripped).
========================================================= */
function stripRoleMarkup(s){
  if(!s) return '';
  return String(s)
    .replace(/\[\/?(?:S|V|O1|O2|O|C|M)\]/gi,'')
    .replace(/<\/?(?:S|V|O1|O2|O|C|M)>/gi,'');
}
function hasRoleMarkup(s){
  if(!s) return false;
  return /(\[\/?(?:S|V|O1|O2|O|C|M)\]|<\/?(?:S|V|O1|O2|O|C|M)>)/i.test(String(s));
}
// Returns [{role:'S'|'V'|'O'|'C'|'M', text:'...'}]
function parseRoleMarkup(s){
  const str = String(s ?? '');
  const out = [];
  let role = 'M';
  let buf = '';

  const flush = ()=>{
    if(buf){
      out.push({ role, text: buf });
      buf = '';
    }
  };

  // Tokenize tags and text
  const reTag = /(\[\/?(?:S|V|O1|O2|O|C|M)\]|<\/?(?:S|V|O1|O2|O|C|M)>)/ig;
  let last = 0;
  let m;
  while((m = reTag.exec(str)) !== null){
    const chunk = str.slice(last, m.index);
    if(chunk) buf += chunk;

    const tag = m[0];
    const upper = tag.replace(/[\[\]<>/]/g,'').toUpperCase(); // S/V/O/C/M
    const isClose = tag.includes('/') && !tag.startsWith('[S]') && !tag.startsWith('[V]') && !tag.startsWith('[O]') && !tag.startsWith('[C]') && !tag.startsWith('[M]');
    // For [/] tags, tag includes '/'. For HTML close tags </S>, includes '/' as well.
    // We'll detect close if it begins with '[/'' or '</'
    const beginsClose = tag.startsWith('[/') || tag.startsWith('</');
    if(beginsClose){
      // closing: flush and revert to M
      flush();
      role = 'M';
    }else{
      // opening: flush and set role
      flush();
      role = (upper==='S'||upper==='V'||upper==='O'||upper==='O1'||upper==='O2'||upper==='C'||upper==='M') ? upper : 'M';
    }
    last = reTag.lastIndex;
  }
  const tail = str.slice(last);
  if(tail) buf += tail;
  flush();

  // If there were no tags, return whole as M
  if(out.length===0){
    return [{role:'M', text:str}];
  }
  return out;
}

function plainEnOf(item){
  return stripRoleMarkup(item?.en ?? '');
}


// === Soft keyboard auto-focus helper (mobile) ===
function focusPracticeInput(){
  const input = document.getElementById('practice-input');
  if(!input) return;
  // Reading mode: do not focus (prevents iPad soft keyboard pop)
  try{ if(currentSettings && currentSettings.readingMode){ input.blur(); return; } }catch(e){}
  if(!input) return;
  try{
    input.focus({preventScroll:true});
  }catch(e){
    try{ input.focus(); }catch(e2){}
  }
  try{
    const v = input.value || '';
    input.setSelectionRange(v.length, v.length);
  }catch(e){}
}

let currentTargetPlain = '';
function setQuestion(){
  const input = document.getElementById('practice-input');
  input.value = "";
  focusPracticeInput();
  isTransitioning = false;

  // init per-question tracking
  qStartTs = performance.now();
  qHadMistake = false;
  qMaxPauseMs = 0;
  qPauseCount = 0;
  qLastInputTs = qStartTs;
  qFirstInput = false;
  qActiveTypedMs = 0;

  // clear if already finished
  if(queuePos >= order.length){
    finishSession(true);
    return;
  }

  const q = currentQuestion();
  const nextQ = (queuePos+1 < order.length) ? sessionTargets[order[queuePos+1]] : null;

  // POS
  const posEl = document.getElementById('pos-display');
  if(q.pos && q.pos !== 'nan'){
    posEl.textContent = `[${q.pos}]`;
    posEl.classList.remove('hidden');
  }else{
    posEl.classList.add('hidden');
  }

  document.getElementById('meaning-display').textContent = q.ja;

  const nextHint = document.getElementById('next-hint');

  const nextWordEl = document.getElementById('next-word-text');
  if(nextQ){
    nextHint.classList.remove('opacity-0');
    if(currentSettings.mode==='normal'){
      nextWordEl.textContent = normalizeTypingText(plainEnOf(nextQ));
    }else{
      // Hard / Ex-Hard: show Japanese only
      nextWordEl.textContent = String(nextQ.ja ?? '');
    }
  }else{
    nextHint.classList.add('opacity-0');
  }


  const display = document.getElementById('word-display');
  display.innerHTML = '';

  const cursor = document.createElement('span');
  cursor.className = 'cursor-bar';
  cursor.id = 'visual-cursor';
  display.appendChild(cursor);

  
    // Plain text used for typing/TTS/SRS (tags stripped)
  const rawEn = (q.en ?? '');
  const useRoleColors = hasRoleMarkup(rawEn);
  currentTargetPlain = normalizeTypingText(stripRoleMarkup(rawEn));

  // Update Answer Peek for Hard/Ex-Hard reading mode
  try{ if(currentSettings && currentSettings.readingMode) updateAnswerPeekUI(currentTargetPlain); }catch(e){}

  // 判定表示（この問題の「標準/やさしめ」を上部バッジに反映）
  try{
    const charsNoSpace = currentTargetPlain.replace(/\s/g,'').length;
    const detail = computeAllowTimeDetail(charsNoSpace, currentSettings.mode);
    window.__lastAllowTimeDetail = detail;
    updateJudgeAssistBadge(detail);
  }catch(e){}

  // Build display in *word units* so it won't wrap in the middle of a word.
  // We still create one .char-base per character so existing judge/highlight logic stays intact.
  const appendTextAsWordUnits = (parentEl, text)=>{
    const parts = String(text ?? '').split(/(\s+)/); // keep spaces
    parts.forEach(part=>{
      if(!part) return;

      // Spaces: can wrap here
      if(/^\s+$/.test(part)){
        part.split('').forEach(()=>{
          const span = document.createElement('span');
          span.textContent = ' ';
          span.style.width = '0.6em';
          span.className = 'char-base char-default';
          parentEl.appendChild(span);
        });
        return;
      }

      // Non-space chunk (a "word" including punctuation): wrap chars in a no-wrap container.
      const unit = document.createElement('span');
      unit.className = 'word-unit';
      parentEl.appendChild(unit);

      part.split('').forEach(char=>{
        const span = document.createElement('span');
        span.textContent = char;

        if(currentSettings.mode==='normal'){
          span.className='char-base char-default';
        }else{
          // In hard/ex-hard, hide non-space characters as before
          span.className = 'char-base ' + (char===' ' ? 'char-default' : 'char-hidden mx-0.5');
        }
        unit.appendChild(span);
      });
    });
  };

  if(useRoleColors){
    const segments = parseRoleMarkup(rawEn).map(seg=>({ ...seg, text: normalizeTypingText(seg.text) }));
    segments.forEach(seg=>{
      const wrap = document.createElement('span');
      wrap.className = 'role-' + (seg.role || 'M');
      display.appendChild(wrap);
      appendTextAsWordUnits(wrap, seg.text);
    });
  }else{
    appendTextAsWordUnits(display, currentTargetPlain);
  }

  fitWordDisplayToMaxLines(2);

  resetSpeechPanel();

  // Auto TTS
  const isReadMode = !!currentSettings.readingMode;
  const isExNoAudio = (isReadMode && currentSettings.mode==='extra');
  const replayBtn = document.getElementById('replay-voice-btn');
  if(replayBtn){
    // Ex-Hard + 音読は「音声なし」なのでボタン自体を隠す
    replayBtn.classList.toggle('hidden', isExNoAudio);
  }

  if(isReadMode){
    if(!isExNoAudio){
      try{ speak(currentTargetPlain); }catch(e){}
      setSpeechStatus('音声を聞いたら「音読」で読んで、できた→「できた」／無理→「わからない」');
    }else{
      setSpeechStatus('Ex-Hard（音声なし）: 画面の英文を見て音読 → できた/わからない を押して進む');
    }
    updateReadingBadges();
  }else{
    if(replayBtn) replayBtn.classList.remove('hidden');
    speak(currentTargetPlain);
  }
}

document.getElementById('replay-voice-btn').onclick = ()=>{
  // Ex-Hard + 音読は音声なし
  if(currentSettings && currentSettings.readingMode && currentSettings.mode==='extra') return;
  const q = currentQuestion();
  if(q) speak(normalizeTypingText(currentTargetPlain || plainEnOf(q)));
  try{ if(!currentSettings.readingMode){ document.getElementById('practice-input').focus(); } }catch(e){}
};

// Tap/click anywhere to refocus input (iOS needs a user gesture)
const sessionScreenEl = document.getElementById('screen-practice');
if(sessionScreenEl){
  const refocus = (ev)=>{
    // If user is already interacting with an input/select, don't steal focus (IME composing)
    try{
      const t = ev && ev.target;
      if(t && (t.tagName==='INPUT' || t.tagName==='TEXTAREA' || t.tagName==='SELECT')) return;
    }catch(e){}
    const input = document.getElementById('practice-input');
    if(input && !input.disabled) input.focus();
  };
  sessionScreenEl.addEventListener('pointerdown', refocus);
  sessionScreenEl.addEventListener('mousedown', refocus);
  sessionScreenEl.addEventListener('touchstart', refocus, {passive:true});
}


// 「わからない」：MISSとしてカウントしつつ、答えを表示して次へ
function revealAnswerInDisplay(answer){
  answer = normalizeTypingText(answer);
  const display = document.getElementById('word-display');
  const spans = display.querySelectorAll('.char-base');
  spans.forEach((span,i)=>{
    // Hard/Ex-Hardの隠しを解除して答えを大きく表示
    span.className = 'char-base char-correct';
    span.textContent = answer[i] ?? '';
  });
  const cursor = document.getElementById('visual-cursor');
  if(cursor) cursor.style.opacity = '0';
  fitWordDisplayToMaxLines(2);
}


function finalizeReadingManual(result){
  // result: 'good' or 'again' (manual)
  if(!currentSettings || !currentSettings.readingMode) return;
  if(sessionEnded || isTransitioning) return;

  const q = currentQuestion();
  if(!q) return;

  stopReadingRecognition();
  isTransitioning = true;

  const curIdx = order[queuePos];
  const item = sessionTargets[curIdx];
  const target = normalizeTypingText(currentTargetPlain || plainEnOf(q));

  // Update self-report reading stats
  const ok = (result !== 'again');
  readingEval.attempts++;
  readingEval.lastOk = ok;
  readingEval.lastPct = ok ? 100 : 0;
  readingEval.sumPct += readingEval.lastPct;
  readingEval.lastGrade = readingGradeFromPct(readingEval.lastPct);
  if(ok) readingEval.ok++;
  updateReadingBadges();

  // Feedback + reveal when NG
  const fb = document.getElementById('feedback-msg');
  if(ok){
    try{ sfxCoin(); }catch(e){}
    if(fb){
      fb.textContent = 'OK';
      setTimeout(()=>{ if(fb.textContent === 'OK') fb.textContent = ''; }, 600);
    }
    setSpeechStatus('できた！次へ', 'SELF: OK');
  }else{
    try{ sfxBuzzer(); }catch(e){}
    revealAnswerInDisplay(target);
    if(fb){
      fb.textContent = 'NG（答え表示）';
      setTimeout(()=>{ if(fb.textContent === 'NG（答え表示）') fb.textContent = ''; }, 900);
    }
    setSpeechStatus('わからない：NG（答え表示）', 'SELF: NG');
  }

  // 音読SRS update（別デッキ。スピードは完全に無視）
  const cardBefore = getReadSrsCard(item, currentSettings.mode) || {state:'new', intervalDays:0, dueTs:0, stability:0};
  const wasDue = (cardBefore.dueTs||0) > 0 && (cardBefore.dueTs <= nowTs());
  const category = classifySrsCategory(cardBefore, wasDue, currentSettings.srsReviewOnly);

  pushReadSrsLog({
    ts: Date.now(),
    grade: item.grade,
    sectionKey: srsSectionKeyForItem(item),
    mode: currentSettings.mode,
    result,
    category,
    channel: 'reading'
  });

  applyReadSrsResult(item, currentSettings.mode, result, getCurrentSrsIntervalFactor());
  showSrsToast(result);

  // mastery / reinsertion (within this run)
  if(ok){
    masteredSet.add(curIdx);
  }else{
    const offset = 3;
    const insertPos = Math.min(order.length, queuePos + offset);
    order.splice(insertPos, 0, curIdx);
  }

  // advance queue
  queuePos++;

  document.getElementById('practice-score').textContent = `${masteredSet.size}/${sessionTargets.length}`;
  setProgress();

  const display = document.getElementById('word-display');
  if(display) display.classList.add('anim-pop');
  setTimeout(()=>{
    if(display) display.classList.remove('anim-pop');
    if(queuePos >= order.length){
      finishSession(true);
    }else{
      setQuestion();
    }
  }, ok ? 150 : 900);
}

const dontKnowBtn = document.getElementById('dont-know-btn');
const readingOkBtn = document.getElementById('reading-ok-btn');
if(readingOkBtn){
  readingOkBtn.onclick = ()=>{
    if(sessionEnded || isTransitioning) return;
    if(currentSettings && currentSettings.readingMode){
      finalizeReadingManual('good');
    }
  };
}

if(dontKnowBtn){
  dontKnowBtn.onclick = ()=>{
    if(sessionEnded || isTransitioning) return;

    if(currentSettings && currentSettings.readingMode){
      finalizeReadingManual('again');
      return;
    }

    const q = currentQuestion();
    if(!q) return;

    isTransitioning = true;
    sfxBuzzer();

    // 答えを表示
    revealAnswerInDisplay(normalizeTypingText(currentTargetPlain || plainEnOf(q)));

    const fb = document.getElementById('feedback-msg');
    if(fb){
      fb.textContent = '答え表示！';
      setTimeout(()=>{ if(fb.textContent === '答え表示！') fb.textContent = ''; }, 900);
    }

    // finalize as "again" (incorrect)
    const curIdx = order[queuePos];
    const item = sessionTargets[curIdx];

    const cardBefore = getSrsCard(item, currentSettings.mode) || {state:'new', intervalDays:0, dueTs:0, stability:0};
    const wasDue = (cardBefore.dueTs||0) > 0 && (cardBefore.dueTs <= nowTs());
    const category = classifySrsCategory(cardBefore, wasDue, currentSettings.srsReviewOnly);
    pushSrsLog({
      ts: Date.now(),
      grade: item.grade,
      sectionKey: srsSectionKeyForItem(item),
      mode: currentSettings.mode,
      result: 'again',
      category
    });

    applySrsResult(item, currentSettings.mode, 'again', getCurrentSrsIntervalFactor());

    // immediate re-insert: Again -> +3 fixed
    const offset = 3;
    const insertPos = Math.min(order.length, queuePos + offset);
    order.splice(insertPos, 0, curIdx);

    // notify integrated SRSCore
    const elapsedSec = (performance.now() - qStartTs) / 1000;
    try{ if(window.recordAttemptForSRS){
      recordAttemptForSRS(plainEnOf(item), '', elapsedSec, 1, (qMaxPauseMs||0)/1000, true);
    }}catch(e){console.warn('recordAttemptForSRS failed', e);}

    // advance queue
    queuePos++;

    document.getElementById('practice-score').textContent = `${masteredSet.size}/${sessionTargets.length}`;
    setProgress();

    const display = document.getElementById('word-display');
    display.classList.add('anim-pop');
    setTimeout(()=>{
      display.classList.remove('anim-pop');
      const cursor = document.getElementById('visual-cursor');
      if(cursor) cursor.style.opacity = '1';

      if(queuePos >= order.length){
        finishSession(true);
      }else{
        setQuestion();
      }
    }, 900);
  };
}

function startTimer(seconds){
  if(sessionInterval) clearInterval(sessionInterval);
  totalSeconds = seconds;
  timeLeftSec = seconds;
  timerStartMs = performance.now();
  sessionEndMs = 0;
  // timed sessions: count from timer start (includes thinking time)
  sessionStarted = true;
  sessionStartMs = timerStartMs;

  const timerEl = document.getElementById('practice-timer');

  const render = ()=>{
    const m = Math.floor(timeLeftSec/60);
    const s = timeLeftSec%60;
    timerEl.textContent = `${m}:${String(s).padStart(2,'0')}`;
  };
  render();

  sessionInterval = setInterval(()=>{
    if(sessionEnded) return;
    timeLeftSec--;
    render();

    if(timeLeftSec<=10) timerEl.classList.add('text-red-500');
    else timerEl.classList.remove('text-red-500');

    // live WPM (reading mode shows —)
    if(currentSettings.readingMode){
      document.getElementById('practice-wpm-badge').textContent = 'WPM: —';
    }else{
      document.getElementById('practice-wpm-badge').textContent = `WPM: ${getLiveWpmText()}`;
    }

    if(timeLeftSec<=0) finishSession(false);
  },1000);
}

function calcWPM(){
  const totalSec = getWpmTimeSec();
  if(totalSec < 0.5) return 0; // 極端に短い時間の誤差防止
  // 正解打鍵数(ksCorrect)をベースに計算
  return Math.round((ksCorrect / 5) / (totalSec / 60));
}




/* =========================================================
   WPM reliability / anti-cheat + migration
   - 1語セクションはWPMを表示/記録しない（WPMは参考にならないため）
   - WPMは「正解キーのみ」「5文字=1語」「実測時間」で計測
========================================================= */
const WPM_RECORD_MIN_SEC  = 8;   // これ未満ならWPM表示/記録しない（例外: 打鍵数が十分ならOK）
const WPM_RECORD_MIN_KEYS = 20;  // 正解打鍵数がこれ以上なら表示OK
const WPM_TINY_SECTION_MAX_ITEMS = 1; // 1語セクションは常にWPM無効

function shouldUseEffectiveWpm(){
  // フリック(IME)向けの特別WPM補正は廃止：全端末で実時間（タイマー）基準に統一
  return false;
}

function getWallTimeSec(){
  if(!sessionStarted || !sessionStartMs) return 0;
  const end = sessionEndMs || performance.now();
  const start = timerStartMs || sessionStartMs;
  return Math.max(0, (end - start) / 1000);
}
function getEffectiveTimeSec(){
  const end = sessionEndMs || performance.now();
  let current = 0;
  if(!isTransitioning){
    current = Math.max(0, end - qStartTs);
  }
  // If soft keyboard: cap idle gaps so IME/変換待ちで極端にWPMが落ちない
  let currentEffective = current;
  if(shouldUseEffectiveWpm() && qFirstInput){
    const idle = Math.max(0, end - qLastInputTs);
    currentEffective = Math.max(250, qActiveTypedMs + Math.min(idle, 1200));
  }
  return Math.max(0, (totalActiveTimeMs + currentEffective) / 1000);
}
function getWpmTimeSec(){
  const wall = getWallTimeSec();
  if(wall <= 0) return 0;
  if(shouldUseEffectiveWpm()){
    const eff = getEffectiveTimeSec();
    // 盛れ防止：実時間の50%未満にはしない（最大でも約2倍まで）
    const safe = Math.max(eff, wall * 0.5);
    return Math.min(wall, safe);
  }
  return wall;
}
function getActiveTimeSec(){
  // backward-compatible alias (used by reliability checks / history)
  return getWpmTimeSec();
}

function isWpmReliableForRecord(){
  const items = Array.isArray(sessionTargets) ? sessionTargets.length : 0;
  if(items <= WPM_TINY_SECTION_MAX_ITEMS) return false;
  const sec = getActiveTimeSec();
  if(sec >= WPM_RECORD_MIN_SEC) return true;
  if(ksCorrect >= WPM_RECORD_MIN_KEYS) return true;
  return false;
}

function getLiveWpmText(){
  if(currentSettings && currentSettings.readingMode) return 'SPEECH';
  if(!sessionStarted) return '--';
  return isWpmReliableForRecord() ? String(calcWPM()) : '--';
}

function getWpmForSave(){
  const sec = getActiveTimeSec();
  const reliable = isWpmReliableForRecord();
  const wpmRaw = calcWPM();
  const wpm = reliable ? wpmRaw : 0;
  return {
    wpm,
    wpmRaw,
    reliable,
    sec: Math.max(0, sec),
    ksCorrect: (ksCorrect|0),
    items: Array.isArray(sessionTargets) ? sessionTargets.length : 0,
    validWpm: reliable
  };
}

function isValidWpmRow(r){
  return !!(r && r.validWpm !== false && typeof r.wpm === 'number' && isFinite(r.wpm) && r.wpm > 0);
}

let __sectionMetaCache = null;
function buildSectionMetaCache(){
  const map = new Map();
  if(!Array.isArray(allWords)) return map;
  allWords.forEach(it=>{
    if(!it) return;
    const key = keyFor(String(it.grade||''), String(it.section||''));
    let m = map.get(key);
    if(!m){
      m = {count:0, chars:0};
      map.set(key, m);
    }
    m.count++;
    const plain = normalizeTypingText(plainEnOf(it));
    m.chars += String(plain).replace(/\s/g,'').length;
  });
  return map;
}

function sanitizeWpmData(){
  if(!Array.isArray(allWords) || allWords.length===0) return false;
  if(!__sectionMetaCache) __sectionMetaCache = buildSectionMetaCache();
  let changed = false;

  // History: 1語セクションのWPMは無効化
  if(Array.isArray(historyData)){
    historyData.forEach(r=>{
      if(!r || typeof r !== 'object') return;
      const key = keyFor(String(r.grade||''), String(r.section||''));
      const meta = __sectionMetaCache.get(key);
      if(meta && meta.count <= WPM_TINY_SECTION_MAX_ITEMS){
        if(r.validWpm !== false){
          r.validWpm = false;
          changed = true;
        }
      }
    });
  }

  // Stats: 1語セクションのWPMは0にする（表示・称号判定から外す）
  if(statsData && typeof statsData==='object'){
    Object.keys(statsData).forEach(key=>{
      const meta = __sectionMetaCache.get(key);
      if(meta && meta.count <= WPM_TINY_SECTION_MAX_ITEMS){
        const st = statsData[key];
        ['normal','hard','extra'].forEach(m=>{
          if(st && st[m] && typeof st[m].wpm==='number' && st[m].wpm !== 0){
            st[m].wpm = 0;
            changed = true;
          }
        });
      }
    });
  }

  return changed;
}

function getMaxValidWpmFromStats(){
  if(!__sectionMetaCache) __sectionMetaCache = buildSectionMetaCache();
  let max = 0;
  if(!statsData || typeof statsData!=='object') return 0;
  Object.keys(statsData).forEach(key=>{
    const meta = __sectionMetaCache.get(key);
    if(meta && meta.count <= WPM_TINY_SECTION_MAX_ITEMS) return;
    const st = statsData[key];
    ['normal','hard','extra'].forEach(m=>{
      const v = st && st[m] ? st[m].wpm : 0;
      if(typeof v === 'number' && isFinite(v) && v > max) max = v;
    });
  });
  return max;
}

function sanitizeSpeedJobAgainstStats(){
  // rankが「1語セクションの爆速WPM」で上がってしまっている場合だけ、妥当な範囲に戻す
  try{
    const data = loadSpeedJob();
    const maxWpm = getMaxValidWpmFromStats();
    const threshold = SPEED_MAX_WPM / (SPEED_RANK_COUNT - 1);
    const supportedRank = Math.min(SPEED_RANK_COUNT - 1, Math.floor(maxWpm / threshold));
    let changed = false;

    if(typeof data.rank === 'number' && data.rank > supportedRank){
      data.rank = supportedRank;
      data.count = 0;
      changed = true;
    }

    if(maxWpm < SECRET_WPM){
      if(data.secretCount || data.secretUnlocked){
        data.secretCount = 0;
        data.secretUnlocked = false;
        changed = true;
      }
    }

    if(changed) saveSpeedJob(data);
  }catch(e){}
}

function sanitizeWpmDataOnce(){
  try{
    if(localStorage.getItem(STORAGE_KEY_WPM_SANITIZED)==='1') return;
  }catch(e){}

  const changed = sanitizeWpmData();
  if(changed) saveAll();

  try{ localStorage.setItem(STORAGE_KEY_WPM_SANITIZED,'1'); }catch(e){}
}

const inputEl = document.getElementById('practice-input');
// Disable mobile autocorrect / capitalization (can inflate typing metrics)
try{
  inputEl.setAttribute('autocomplete','off');
  inputEl.setAttribute('autocorrect','off');
  inputEl.setAttribute('autocapitalize','off');
  inputEl.setAttribute('spellcheck','false');
  inputEl.setAttribute('inputmode','latin');
}catch(e){}
// Block paste/drop to prevent WPM inflation by貼り付け
inputEl.addEventListener('paste', (e)=>{ e.preventDefault(); });
inputEl.addEventListener('drop', (e)=>{ e.preventDefault(); });

// IME / Flick keyboard composition guard (iOS/Android)
window.__imeComposing = false;
inputEl.addEventListener('compositionstart', ()=>{ window.__imeComposing = true; });
inputEl.addEventListener('compositionend', ()=>{
  window.__imeComposing = false;
  // trigger one more input handling after composition is committed
  try{ inputEl.dispatchEvent(new Event('input', {bubbles:true})); }catch(e){}
});


inputEl.addEventListener('keydown', (e)=>{
  // Prevent key-repeat (holding a key) from auto-filling the next question (esp. Space).
  // Allow Backspace repeat for quick delete.
  if(e.repeat && e.key !== 'Backspace'){
    e.preventDefault();
    return;
  }
  // type sound for most keys
  if(e.key.length===1 || e.key==='Backspace' || e.key==='Enter'){
    if(!isTransitioning) sfxType();
  }

  // --- Keystroke counting for WPM (ignore IME composition) ---
  if(sessionEnded || isTransitioning) return;
  if(e.isComposing) return;
  const q = currentQuestion();
  if(!q) return;

  // Ignore common shortcut bursts
  if((e.ctrlKey || e.metaKey) && ['v','c','x'].includes(e.key.toLowerCase())) return;

  if(e.key === 'Backspace'){
    ksBackspace++;
    return;
  }

  // Count only character keys (includes space/punctuation)
  if(e.key.length === 1){
    // Start WPM timer on the first counted keystroke
    if(!sessionStarted){
      sessionStarted = true;
      sessionStartMs = performance.now();
    }

    ksTotal++;

    const target = normalizeTypingText(currentTargetPlain || plainEnOf(q));
    const idx = normalizeTypingText(inputEl.value).length;
    const expected = target[idx] ?? '';
    let k = e.key;
    if(k === 'Spacebar') k = ' ';
    if(k && k.length === 1) k = normalizeTypingText(k);
    if(expected && k && k.toLowerCase() === expected.toLowerCase()){
      ksCorrect++;
    }
  }
});

inputEl.addEventListener('input', ()=>{
  if(window.__imeComposing) return;
  if(isTransitioning || !currentQuestion()){
    inputEl.value="";
    return;
  }

  let valRaw = inputEl.value;
  const norm = normalizeTypingText(valRaw);
  if(norm !== valRaw){
    inputEl.value = norm;
    valRaw = norm;
  }

  const target = normalizeTypingText(currentTargetPlain || plainEnOf(currentQuestion()));
  let val = valRaw;

  // --- BLOCKING ERROR LOGIC ---
  let errorIndex = -1;
  for(let i=0; i<val.length; i++){
    const tChar = target[i];
    if(!tChar || val[i].toLowerCase() !== tChar.toLowerCase()){
      errorIndex = i;
      break;
    }
  }

  if(errorIndex !== -1){
    qHadMistake = true;
    // Revert input to valid prefix
    val = val.substring(0, errorIndex);
    inputEl.value = val;
  }

  // pause tracking (ignore before first input)
  const now = performance.now();
  // mirror typed text (mobile)

  if(!qFirstInput){
    qFirstInput = true;
    qLastInputTs = now;
  }else{
    const delta = now - qLastInputTs;
    if(delta > qMaxPauseMs) qMaxPauseMs = delta;
    if(delta >= 1200) qPauseCount++;
    if(isCoarsePointer){
      // Touch/IME tends to include long "thinking" pauses; cap idle gaps for fair WPM
      qActiveTypedMs += Math.min(delta, 1200);
    }
    qLastInputTs = now;
  }

  const spans = document.querySelectorAll('#word-display .char-base');
  const cursor = document.getElementById('visual-cursor');
  const display = document.getElementById('word-display');

  spans.forEach((span,i)=>{
    const char = val[i];
    if(char==null){
      if(currentSettings.mode!=='normal' && target[i] !== ' ') span.className='char-base char-hidden mx-0.5';
      else span.className='char-base char-default';
    }else if(char.toLowerCase() === target[i].toLowerCase()){
      span.className='char-base char-correct mx-0';
    }else{
      if(currentSettings.mode!=='normal' && target[i] !== ' ') span.className='char-base char-hidden char-wrong mx-0.5';
      else span.className='char-base char-wrong';
    }
  });

  // Visual feedback for blocking error
  if(errorIndex !== -1){
    const span = spans[errorIndex];
    if(span){
      span.classList.add('char-wrong', 'anim-shake');
      setTimeout(()=>span.classList.remove('char-wrong', 'anim-shake'), 200);
    }
  }

  
  // Move visual cursor to the current position.
  // NOTE: chars may be nested inside .word-unit, so insert relative to the char's parent.
  if(val.length < spans.length){
    const ref = spans[val.length];
    if(ref && ref.parentNode) ref.parentNode.insertBefore(cursor, ref);
    else display.appendChild(cursor);
  }else{
    if(spans.length){
      const last = spans[spans.length-1];
      (last.parentNode || display).appendChild(cursor);
    }else{
      display.appendChild(cursor);
    }
  }
const lvAll = val.toLowerCase();
  const ltAll = target.toLowerCase();

  if(lvAll === ltAll){
    isTransitioning = true;
    sfxCoin();

      // ★追加：この問題にかかった時間を累積に足す
    const qDuration = performance.now() - qStartTs;
    // Touch/IMEは「考えてる時間」や変換の待ちで極端にWPMが下がりやすいので、入力間隔を上限1.2秒で換算した時間も使う
    const qEffective = (isCoarsePointer && qFirstInput) ? Math.max(250, qActiveTypedMs) : qDuration;
    totalActiveTimeMs += qEffective;

    // finalize per-question stats
    const elapsedSec = (performance.now() - qStartTs) / 1000;
    const charsNoSpace = target.replace(/\s/g,'').length;
    const allowDetail = computeAllowTimeDetail(charsNoSpace, currentSettings.mode);
    window.__lastAllowTimeDetail = allowDetail;
    updateJudgeAssistBadge(allowDetail);
    const allowSec = allowDetail.allowSec;
    const srsIntervalFactor = getSrsIntervalFactorFromAllowDetail(allowDetail);

    // Automatic judgment (FSRS 4-step)
    // ■ 自動判定ロジックの修正
    // ミスがあっても、ここまで到達（入力完了）していれば Again にはしません。
    let result;

    // 長文ほど『考える間』が入りやすいので、長さに応じてポーズ判定を緩めます。
    // また、タッチ/IME環境では『入力していない待ち時間』が入りがちなので、実質入力時間(qEffective)も参照します。
    const effectiveElapsedSec = (isCoarsePointer && qFirstInput) ? (qEffective / 1000) : elapsedSec;

    const allowedPauses = (charsNoSpace >= 60) ? 2 : (charsNoSpace >= 35) ? 1 : 0; // 35文字以上は1回、60文字以上は2回まで許容
    const isTooSlow = (effectiveElapsedSec > allowSec);
    const isTooManyPauses = (qPauseCount > allowedPauses);
    const bigPauseThresh = (charsNoSpace >= 80) ? 7000 : (charsNoSpace >= 60) ? 6000 : (charsNoSpace >= 35) ? 4500 : 2500;
    const isBigPause = (qMaxPauseMs >= bigPauseThresh);

    if (isTooSlow || isBigPause || isTooManyPauses) {
      result = 'hard';
    } else if (effectiveElapsedSec <= allowSec * 0.75 && qMaxPauseMs < 250 && !qHadMistake) {
      // 早くてスムーズ、かつ「ミスが一度もなかった(!qHadMistake)」場合のみ Easy
      result = 'easy';
    } else {
      // それ以外は Good
      result = 'good';
    }

// Personal baseline update (no-pause attempts only)
try{
  if(qPauseCount === 0){
    updatePersonalBaseline(currentSettings.mode, (typeof effectiveElapsedSec==='number'? effectiveElapsedSec : elapsedSec), charsNoSpace);
  }
}catch(e){}

// debug
    console.log(`Q: "${target}" | elapsed:${((typeof effectiveElapsedSec==='number'? effectiveElapsedSec : elapsedSec)).toFixed(2)}s allow:${allowSec.toFixed(2)}s | pauseCount:${qPauseCount} maxPause:${(qMaxPauseMs/1000).toFixed(2)}s | result:${result}`);
    console.log(`Q: "${target}" | result:${result} (Mistake:${qHadMistake})`);

    const curIdx = order[queuePos];
    const item = sessionTargets[curIdx];

    // log for Anki-like charts
    const cardBefore = getSrsCard(item, currentSettings.mode) || {state:'new', intervalDays:0, dueTs:0};
    const wasDue = (cardBefore.dueTs||0) > 0 && (cardBefore.dueTs <= nowTs());
    const category = classifySrsCategory(cardBefore, wasDue, currentSettings.srsReviewOnly);
    pushSrsLog({
      ts: Date.now(),
      grade: item.grade,
      sectionKey: srsSectionKeyForItem(item),
      mode: currentSettings.mode,
      result,
      category
    });

    // update SRS schedule
    applySrsResult(item, currentSettings.mode, result, srsIntervalFactor);
    showSrsToast(result);

    // Also notify integrated SRSCore (if present)
    try{ if(window.recordAttemptForSRS){
      recordAttemptForSRS(plainEnOf(item), val, (typeof effectiveElapsedSec==='number'? effectiveElapsedSec : elapsedSec), qHadMistake?1:0, (qMaxPauseMs||0)/1000, false, result);
    }}catch(e){console.warn('recordAttemptForSRS failed', e);} 

    // mastery (Good only)
    if(result === 'good' || result === 'easy'){
      masteredSet.add(curIdx);
    }

    // immediate re-insert inside this run (Again=+3, Hard=+5)
    if(result === 'again' || result === 'hard'){
      const offset = (result === 'again') ? 3 : 5;
      const insertPos = Math.min(order.length, queuePos + offset);
      order.splice(insertPos, 0, curIdx);
    }

    // advance queue
    queuePos++;

    // WPM counter (5 chars = 1 word)
    correctChars += target.length;

    document.getElementById('practice-score').textContent = `${masteredSet.size}/${sessionTargets.length}`;
    setProgress();

    display.classList.add('anim-pop');
    setTimeout(()=>{
      display.classList.remove('anim-pop');

      if(queuePos >= order.length){
        finishSession(true);
      }else{
        setQuestion();
      }
    },150);
  }
});

function checkStudyReward() {
  // 月曜始まりで週を管理
  const d = new Date();
  const day = d.getDay(); // 0=Sun, 1=Mon...
  // 月曜を基準日とする（日曜(0)なら-6日、それ以外は1との差分を引く）
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  const mondayDate = new Date(d.setDate(diff));
  // タイムゾーンの影響で日付がずれるのを防ぐため、ローカル時間でYYYY-MM-DDを生成
  const y = mondayDate.getFullYear();
  const m = String(mondayDate.getMonth() + 1).padStart(2, '0');
  const da = String(mondayDate.getDate()).padStart(2, '0');
  const currentMondayStr = `${y}-${m}-${da}`;

  let weeklyData;
  try {
    weeklyData = JSON.parse(localStorage.getItem(STORAGE_KEY_WEEKLY_STUDY)) || {};
  } catch (e) {
    weeklyData = {};
  }

  // 週が変わっていたらリセット
  if (weeklyData.weekMonday !== currentMondayStr) {
    weeklyData = {
      weekMonday: currentMondayStr,
      totalMs: 0,
      reward15Shown: false,
      reward30Shown: false
    };
  }

  // 今回の学習時間を加算
  weeklyData.totalMs += totalActiveTimeMs;
  // 二重加算防止のためリセット
  totalActiveTimeMs = 0;

  // 今週の経過日数（月曜=1日目, ... 日曜=7日目）
  const daysElapsed = (day === 0 ? 7 : day);
  const averageMs = weeklyData.totalMs / daysElapsed;

  const MIN_15 = 15 * 60 * 1000;
  const MIN_30 = 30 * 60 * 1000;
  let showType = null;

  // 30分達成（優先）
  if (averageMs >= MIN_30 && !weeklyData.reward30Shown) {
    weeklyData.reward30Shown = true;
    weeklyData.reward15Shown = true; // 30分達成なら15分も達成済み扱い
    showType = '30';
  } 
  // 15分達成
  else if (averageMs >= MIN_15 && !weeklyData.reward15Shown) {
    weeklyData.reward15Shown = true;
    showType = '15';
  }

  try{ localStorage.setItem(STORAGE_KEY_WEEKLY_STUDY, JSON.stringify(weeklyData)); }catch(e){}

  if (showType) {
    setTimeout(() => {
      showRewardOverlay(showType);
    }, 1000);
  }
}

document.getElementById('screen-practice').addEventListener('click', ()=>{ try{ if(!currentSettings.readingMode && !inputEl.disabled) inputEl.focus(); }catch(e){} });

function isFullClearNow(grade, section){
  const targetsCount = getTargets().length;
  const st = statsData[keyFor(grade, section)];
  if(!st || targetsCount<=0) return false;
  return st.normal.score>=targetsCount && st.hard.score>=targetsCount && st.extra.score>=targetsCount;
}

function finishSession(cleared=false){
  if(sessionEnded) return;
  sessionEndMs = performance.now();
  sessionEnded = true;
  if(sessionInterval) clearInterval(sessionInterval);
  document.getElementById('practice-input').disabled = true;

  // WPM: 1語セクション/短すぎる計測は無効（表示も「—」）
  const isReading = !!(currentSettings && currentSettings.readingMode);
  const w = isReading ? {wpm:0, reliable:false, sec:0, ksCorrect:0, items:(sessionTargets?sessionTargets.length:0), wpmRaw:0, validWpm:false} : getWpmForSave();
  const wpm = w.wpm;

  // 称号/ジョブ進行は「有効WPM」のときだけ
  const isRankUp = (!isReading && w.reliable) ? checkSpeedRank(wpm) : false;

  clearPenaltyOnPlay();
  document.getElementById('res-score').textContent = `${masteredSet.size}/${getTargets().length}`;
  document.getElementById('res-wpm').textContent = w.reliable ? String(wpm) : '—';
  document.getElementById('res-wpm-note').textContent = w.reliable
    ? (shouldUseEffectiveWpm() ? '（正味WPM：正解キーのみ / 5文字=1語 / スマホ補正あり）' : '（正味WPM：正解キーのみ / 5文字=1語 / 実測時間）')
    : '※短いセクションのためWPMは記録しません';

  // Reading (speech) result (separate)
  try{
    const card = document.getElementById('res-reading-card');
    const val = document.getElementById('res-reading');
    const note = document.getElementById('res-reading-note');
    if(currentSettings.readingMode && readingEval && readingEval.attempts){
      const avg = Math.round(getReadingAvgPct());
      const g = readingGradeFromPct(avg);
      if(card) card.classList.remove('hidden');
      if(val) val.textContent = `OK ${readingEval.ok}/${readingEval.attempts}`;
      if(note) note.textContent = `Avg: ${avg}% (${g})  /  Last: ${readingEval.lastPct}% (${readingEval.lastGrade})`;
    }else{
      if(card) card.classList.add('hidden');
      if(val) val.textContent = '—';
      if(note) note.textContent = 'Avg: —';
    }
  }catch(e){}

  // 音読モードではタイピングの履歴/WPM/スコアに影響させない（別の音読SRSだけ更新）
  if(!isReading){
    // history（validWpm=false の行はWPM集計/グラフから除外）
    addHistory(
      currentSettings.grade,
      currentSettings.section,
      currentSettings.mode,
      masteredSet.size,
      wpm,
      {sec:w.sec, ksCorrect:w.ksCorrect, items:w.items, wpmRaw:w.wpmRaw, validWpm:w.validWpm}
    );

    // save stats max（wpm=0 の場合はWPMは更新されない）
    saveStats(currentSettings.grade, currentSettings.section, currentSettings.mode, masteredSet.size, wpm);
  }

  // result card reset
  const resultCard = document.getElementById('result-card');
  resultCard.classList.remove('full-clear-glow');
  document.getElementById('result-topbar').className = "absolute top-0 left-0 w-full h-3 bg-gradient-to-r from-sky-400 to-indigo-400";

  if(cleared){
    // cleared whole section early or just in time
    clearProgress();

    const full = isFullClearNow(currentSettings.grade, currentSettings.section);

    if(full){
      fireConfetti({durationMs:2300, count:220, burst:3});
      if(!isRankUp) sfxFullClear();
      document.getElementById('result-msg').textContent = "FULL CLEAR!!";
      resultCard.classList.add('full-clear-glow');
      document.getElementById('result-topbar').className = "absolute top-0 left-0 w-full h-3 bg-gradient-to-r from-yellow-400 via-amber-400 to-rose-400";
    }else{
      fireConfetti({durationMs:1400, count:120, burst:2});
      if(!isRankUp) sfxLevelUp();
      document.getElementById('result-msg').textContent = "Section Clear!";
    }
  }else{
    // time up -> keep progress
    document.getElementById('result-msg').textContent = "Time Up! Continue next time.";
    setProgress();
  }

  checkStudyReward();

  goToScreen('result');
}

function checkSpeedRank(wpm){
  const data = loadSpeedJob();
  const now = Date.now();
  data.lastPlay = now;
  let isRankUp = false;

  // 隠しジョブ
  if(wpm >= SECRET_WPM && data.rank === (SPEED_RANK_COUNT - 1)){
    data.secretCount++;
    if(data.secretCount >= SECRET_REQUIRED && !data.secretUnlocked){
      data.secretUnlocked = true;
      showRankUp("speed_X_destroyer_creator.png");
      saveSpeedJob(data);
      return true;
    }
  }

  // 通常ランク
  const threshold = SPEED_MAX_WPM / (SPEED_RANK_COUNT - 1);
  const newRank = Math.min(
    SPEED_RANK_COUNT - 1,
    Math.floor(wpm / threshold)
  );

  if(newRank > data.rank){
    data.rank = newRank;
    data.count = 0;
    showRankUp(SPEED_JOBS[newRank]);
    isRankUp = true;
  }else{
    data.count++;
    const reqCount = SPEED_REQ_COUNTS[data.rank] || 300;
    if(data.count >= reqCount && data.rank < 9){
      data.rank++;
      data.count = 0;
      showRankUp(SPEED_JOBS[data.rank]);
      isRankUp = true;
    }
  }

  saveSpeedJob(data);
  checkGodMaster();
  return isRankUp;
}

/* =========================================================
   SPEED JOB SYSTEM (WPM)
========================================================= */

// ---- 設定 ----
const SPEED_MAX_WPM = 45;
const SPEED_RANK_COUNT = 10; // 0-9
const SPEED_REQ_COUNTS = [20, 35, 50, 65, 80, 95, 110, 125, 140]; // 各ランク(0->1 ～ 8->9)の必要回数
const SECRET_WPM = 70;
const SECRET_REQUIRED = 1000;

// ---- ジョブ定義 ----
const SPEED_JOBS = [
   { rank:0, name:"村人", img:"speed_0_villager.png" },
  { rank:1, name:"ドラキチの弟子", img:"speed_1_apprentice.png" },
  { rank:2, name:"タイピング見習い", img:"speed_2_trainee.png" },
  { rank:3, name:"へなちょこ剣士", img:"speed_3_swordsman.png" },
  { rank:4, name:"ガチムチ騎士", img:"speed_4_knight.png" },
  { rank:5, name:"疾風のレンジャー", img:"speed_5_ranger.png" },
  { rank:6, name:"必殺のアサシン", img:"speed_6_assassin.png" },
  { rank:7, name:"神速の忍者", img:"speed_7_ninja.png" },
  { rank:8, name:"伝説の拳士", img:"speed_8_fist.png" },
  { rank:9, name:"ドラキチ神拳伝承者", img:"speed_9_successor.png" },
];

// ---- 保存キー ----
const STORAGE_KEY_SPEED = "typing_drill_speed_job";

// ---- 取得 ----
function loadSpeedJob(){
  return JSON.parse(localStorage.getItem(STORAGE_KEY_SPEED)) || {
    rank: 0,
    count: 0,
    lastPlay: Date.now(),
    secretCount: 0
  };
}

function saveSpeedJob(data){
  localStorage.setItem(STORAGE_KEY_SPEED, JSON.stringify(data));
}

function updateSpeedJobDisplay(){
  const speedData = loadSpeedJob();
  const penaltyData = loadPenalty();
  const imgEl = document.getElementById("speed-job-img");
  const nameEl = document.getElementById("speed-job-name");
  const nextEl = document.getElementById("speed-job-next");

  if(!imgEl || !nameEl) return;
  let jobName, jobImg;
  let nextText = "";

  if (penaltyData.state === 'sloth') {
    jobName = "伝説のナマケモノ";
    jobImg = "penalty_sloth.png";
    nextText = `回復条件: あと${10 - (penaltyData.recoveryCount||0)}回練習`;
  } else if (penaltyData.state === 'player') {
    jobName = "根っからの遊び人";
    jobImg = "penalty_player.png";
    nextText = `回復条件: あと${5 - (penaltyData.recoveryCount||0)}回練習`;
  } else if (speedData.secretUnlocked) {
    jobName = "すべてを破壊し、創造するモノ";
    jobImg = "speed_X_destroyer_creator.png";
    nextText = "Hidden Job Unlocked";
  } else {
    const job = SPEED_JOBS[speedData.rank] || SPEED_JOBS[0];
    jobName = job.name;
    jobImg = job.img;

    if(speedData.rank < 9){
      const nextRank = speedData.rank + 1;
      const nextJob = SPEED_JOBS[nextRank];
      const wpmReq = Math.ceil(nextRank * (SPEED_MAX_WPM / (SPEED_RANK_COUNT - 1)));
      const reqCount = SPEED_REQ_COUNTS[speedData.rank] || 300;
      const countReq = Math.max(0, reqCount - speedData.count);
      nextText = `Next: ${nextJob.name}\n条件: WPM ${wpmReq}↑ または 同ランクあと${countReq}回`;
    } else {
      const srs = loadSrsJob();
      if(srs.rank < 14){
        nextText = "Next: GOD MASTER\n(Need SRS Rank 14)";
      } else {
        nextText = "GOD MASTER Unlocked";
      }
      if(!speedData.secretUnlocked){
        nextText += `\n(隠し: WPM ${SECRET_WPM}↑ あと${Math.max(0, SECRET_REQUIRED - speedData.secretCount)}回)`;
      }
    }
  }
  imgEl.src = jobImg;
  nameEl.textContent = jobName;
  if(nextEl) nextEl.innerText = nextText;
}

function showRankUp(job){
  // どの音を鳴らすか判定
  let targetAudio = sfxRankUp; // デフォルト
  let jobName = '';
  let jobImg = '';

  // jobが画像パスだけで渡ってくる場合に備えて、名前を逆引き
  const resolveNameByImg = (img) => {
    try{
      const all = ([]).concat((typeof SPEED_JOBS!=='undefined'?SPEED_JOBS:[]), (typeof SRS_JOBS!=='undefined'?SRS_JOBS:[]));
      const hit = all.find(j => j && j.img === img);
      return hit ? hit.name : '';
    }catch(e){
      return '';
    }
  };

  if (typeof job === 'string') {
    jobImg = job;

    // 隠しジョブ
    if (job === 'speed_X_destroyer_creator.png') {
      jobName = 'すべてを破壊し、創造するモノ';
      targetAudio = sfxSecret;
    } else {
      jobName = resolveNameByImg(job) || '新たなジョブ';
      targetAudio = sfxRankUp;
    }
  } else if (job && job.name && job.img) {
    jobName = job.name;
    jobImg  = job.img;

    if (job.img === 'speed_X_destroyer_creator.png') {
      targetAudio = sfxSecret;
    }
  } else {
    jobName = '新たなジョブ';
  }

  // 再生処理
  if (targetAudio) {
    try{
      targetAudio.pause();
      targetAudio.currentTime = 0;
      targetAudio.volume = bgmMuted ? 0 : Math.min(1, Math.max(0, bgmVol));
      targetAudio.play().catch(e => console.log('Audio play failed', e));
    }catch(e){
      console.log('Audio play error', e);
    }
  }

  const safeName = jobName || '新たなジョブ';
  const text = `Congratulations! あなたは<span class="text-white">${safeName}</span>にRank Up しました！`;
  showRankOverlay(text, jobImg);
}


function showRankOverlay(fullText, img){
  const overlay = document.createElement('div');
  // Tailwind CDNはJS内の動的classを拾えないことがあるので、ここはstyleで固定
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.zIndex = '999999';
  overlay.style.display = 'flex';
  overlay.style.flexDirection = 'column';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'rgba(0,0,0,0.72)';
  overlay.style.textAlign = 'center';
  overlay.style.padding = '16px';

  const msg = document.createElement('div');
  msg.innerHTML = fullText;
  msg.style.fontSize = '2rem';
  msg.style.fontWeight = '800';
  msg.style.color = '#fbbf24';
  msg.style.textShadow = '0 2px 14px rgba(0,0,0,0.75)';
  msg.style.marginBottom = '18px';
  msg.style.lineHeight = '1.15';
  msg.style.maxWidth = '92vw';

  overlay.appendChild(msg);

  const src = (img || '').trim();
  if(src){
    const imgEl = document.createElement('img');
    imgEl.src = encodeURI(src);
    imgEl.alt = '';
    imgEl.style.width = '256px';
    imgEl.style.height = '256px';
    imgEl.style.objectFit = 'contain';
    // 既存のアニメ( .anim-pop )があるのでそれを流用
    imgEl.className = 'anim-pop';
    overlay.appendChild(imgEl);
  }

  document.body.appendChild(overlay);

  const remove = () => { try{ overlay.remove(); }catch(e){} };
  overlay.addEventListener('click', remove, { once:true });
  overlay.addEventListener('touchstart', remove, { once:true });
  setTimeout(remove, 5000);
}

/* =========================================================
   SRS JOB SYSTEM (Vocabulary Mastery)
========================================================= */

const SRS_MAX_RANK = 14;
const SRS_THRESHOLDS = [0, 50, 110, 180, 260, 360, 480, 620, 780, 960, 1160, 1380, 1630, 1910, 2210];

const SRS_JOBS = [
  { rank:0, name:"村人", img:"srs_0_villager.png" },
  { rank:1, name:"ことばの旅人", img:"srs_1_traveler.png" },
  { rank:2, name:"書記", img:"srs_2_scribe.png" },
  { rank:3, name:"司書見習い", img:"srs_3_librarian_apprentice.png" },
  { rank:4, name:"司書", img:"srs_4_librarian.png" },
  { rank:5, name:"学者", img:"srs_5_scholar.png" },
  { rank:6, name:"賢者見習い", img:"srs_6_sage_apprentice.png" },
  { rank:7, name:"賢者", img:"srs_7_sage.png" },
  { rank:8, name:"大賢者", img:"srs_8_archsage.png" },
  { rank:9, name:"叡智の導師", img:"srs_9_mentor.png" },
  { rank:10, name:"時の賢者", img:"srs_10_time_sage.png" },
  { rank:11, name:"星読みの賢者", img:"srs_11_star_sage.png" },
  { rank:12, name:"古文書の守り手", img:"srs_12_manuscript_keeper.png" },
  { rank:13, name:"伝説の賢者", img:"srs_13_legendary_sage.png" },
  { rank:14, name:"古の大賢者", img:"srs_14_ancient_grand_sage.png" }
];

const STORAGE_KEY_SRS_JOB = "typing_drill_srs_job";

function loadSrsJob(){
  return JSON.parse(localStorage.getItem(STORAGE_KEY_SRS_JOB)) || {
    rank: 0,
    mastered: 0
  };
}

function saveSrsJob(data){
  localStorage.setItem(STORAGE_KEY_SRS_JOB, JSON.stringify(data));
}

function updateSrsRank(masteredCount){
  const data = loadSrsJob();
  data.mastered = masteredCount;

  let newRank = 0;
  for(let i = SRS_THRESHOLDS.length - 1; i >= 0; i--){
    if(masteredCount >= SRS_THRESHOLDS[i]){
      newRank = i;
      break;
    }
  }

  if(newRank > data.rank){
    data.rank = newRank;
    showSrsRankUp(newRank);
  }

  saveSrsJob(data);
  updateSrsJobDisplay();
  checkGodMaster();
}

function showSrsRankUp(rank){
  const job = SRS_JOBS[rank];
  if(!job) return;

  // 変更：準備しておいた変数を使用
  if (sfxRankUp) {
    sfxRankUp.pause();
    sfxRankUp.currentTime = 0;
    sfxRankUp.volume = bgmMuted ? 0 : bgmVol;
    sfxRankUp.play().catch(e => console.log(e));
  }

  const text = `Congratulations! あなたは<span class="text-white">${job.name}</span>にRank Up しました！`;
  showRankOverlay(text, job.img);
}

function updateSrsJobDisplay(){
  const srsData = loadSrsJob();
  const penaltyData = loadPenalty();
  const imgEl = document.getElementById("srs-job-img");
  const nameEl = document.getElementById("srs-job-name");
  const nextEl = document.getElementById("srs-job-next");

  if(!imgEl || !nameEl) return;

  let jobName, jobImg;
  let nextText = "";

  if (penaltyData.state === 'sloth') {
    jobName = "伝説のナマケモノ";
    jobImg = "penalty_sloth.png";
    nextText = `回復条件: あと${10 - (penaltyData.recoveryCount||0)}回練習`;
  } else if (penaltyData.state === 'player') {
    jobName = "根っからの遊び人";
    jobImg = "penalty_player.png";
    nextText = `回復条件: あと${5 - (penaltyData.recoveryCount||0)}回練習`;
  } else {
    const job = SRS_JOBS[srsData.rank] || SRS_JOBS[0];
    jobName = job.name;
    jobImg = job.img;

    if(srsData.rank < 14){
      const nextRank = srsData.rank + 1;
      const nextJob = SRS_JOBS[nextRank];
      const req = SRS_THRESHOLDS[nextRank];
      const left = Math.max(0, req - srsData.mastered);
      nextText = `Next: ${nextJob.name}\n現在の定着数: ${srsData.mastered}語\n(あと ${left} 語)`;
    } else {
      const speed = loadSpeedJob();
      if(speed.rank < 9){
        nextText = "Next: GOD MASTER\n(Need Speed Rank 9)";
      } else {
        nextText = "GOD MASTER Unlocked";
      }
    }
  }

  imgEl.src = jobImg;
  nameEl.textContent = jobName;
  if(nextEl) nextEl.innerText = nextText;
}

/* =========================================================
   GOD MASTER SYSTEM
========================================================= */
const STORAGE_KEY_GODMASTER = "typing_drill_godmaster";

function loadGodMaster(){
  return JSON.parse(localStorage.getItem(STORAGE_KEY_GODMASTER)) || {
    unlocked: false
  };
}

function saveGodMaster(data){
  localStorage.setItem(STORAGE_KEY_GODMASTER, JSON.stringify(data));
}

function checkGodMaster(){
  const speed = loadSpeedJob();
  const srs   = loadSrsJob();
  const god   = loadGodMaster();

  if(god.unlocked) return;

  const speedMax = (speed.rank >= 9);
  const srsMax   = (srs.rank >= 14);

  if(speedMax && srsMax){
    god.unlocked = true;
    saveGodMaster(god);
    showGodMaster();
  }
}

function showGodMaster(){
  // 変更：準備しておいた変数を使用
  if (sfxGod) {
    sfxGod.pause();
    sfxGod.currentTime = 0;
    sfxGod.volume = bgmMuted ? 0 : bgmVol;
    sfxGod.play().catch(e => console.log(e));
  }

  const flash = document.createElement("div");
  flash.className = "pointer-events-none anim-gold-flash";
  flash.style.position='fixed';
  flash.style.inset='0';
  flash.style.zIndex='1000000';
  document.body.appendChild(flash);
  setTimeout(()=>flash.remove(), 2000);

  showRankOverlay("GOD MASTER", "special_godmaster.png");
}

/* =========================================================
   PENALTY SYSTEM (Sloth)
========================================================= */
const STORAGE_KEY_PENALTY = "typing_penalty_state";

function loadPenalty(){
  const raw = localStorage.getItem(STORAGE_KEY_PENALTY);
  if(!raw){
    return { state: "none", lastPlay: Date.now(), recoveryCount: 0, isNew: true };
  }
  return JSON.parse(raw) || {
    state: "none",
    lastPlay: Date.now(),
    recoveryCount: 0
  };
}

function savePenalty(data){
  localStorage.setItem(STORAGE_KEY_PENALTY, JSON.stringify(data));
}

function checkPenaltyOnLoad(){
  const data = loadPenalty();
  
  // 初回練習（データなし）の場合はペナルティ判定せず、現在時刻で初期化して終了
  if(data.isNew){
    delete data.isNew;
    savePenalty(data);
    return;
  }

  const now = Date.now();
  // データ破損対策：lastPlayがnull/0の場合は現在時刻でリセット（いきなりペナルティになるのを防ぐ）
  if(!data.lastPlay){
    data.lastPlay = now;
    savePenalty(data);
    return;
  }

  const diffDays = Math.floor((now - data.lastPlay) / (1000*60*60*24));

  let newState = null;
  if(diffDays >= 3) newState = "sloth";
  else if(diffDays >= 2) newState = "player";

 if(newState){
    // 既にペナルティ中でも、さらに放置したらカウントリセットなどの処理
    let changed = false;
    if(data.state === "none"){
      data.state = newState; changed = true;
    } else if(data.state === "player" && newState === "sloth"){
      data.state = "sloth"; changed = true;
    } else if(data.state === newState && data.recoveryCount > 0){
      // 同じペナルティ状態だが、また放置したのでリハビリやり直し
      data.recoveryCount = 0;
      savePenalty(data);
    }

    if(changed){
      data.recoveryCount = 0;
      savePenalty(data);
      showPenalty(newState);
    }
  }
}

function showPenalty(state){
 const img = (state === "sloth") ? "penalty_sloth.png" : "penalty_player.png";
  
  // 変更：準備しておいた変数を使用
  if (currentSettings.sfxCoin && sfxPenalty) {
    sfxPenalty.pause();
    sfxPenalty.currentTime = 0;
    sfxPenalty.volume = bgmMuted ? 0 : bgmVol;
    sfxPenalty.play().catch(e => console.log(e));
  }
  const jobName = (state === "sloth") ? "伝説のナマケモノ" : "根っからの遊び人";
  const text = `Oh no! あなたは<span class="text-white">${jobName}</span>にRank Downしました！`;
  showRankOverlay(text, img);
}

function clearPenaltyOnPlay(){
  const data = loadPenalty();
   data.lastPlay = Date.now();

  if(data.state === "sloth"){
    data.recoveryCount = (data.recoveryCount || 0) + 1;
    if(data.recoveryCount >= 10){
      data.state = "none";
      data.recoveryCount = 0;
      const speed = loadSpeedJob();
      const job = SPEED_JOBS[speed.rank] || SPEED_JOBS[0];
      showRankOverlay("復帰！", job.img);
    }
  } else if(data.state === "player"){
    data.recoveryCount = (data.recoveryCount || 0) + 1;
    if(data.recoveryCount >= 5){
      data.state = "none";
      data.recoveryCount = 0;
      const speed = loadSpeedJob();
      const job = SPEED_JOBS[speed.rank] || SPEED_JOBS[0];
      showRankOverlay("復帰！", job.img);
    }
  }

  savePenalty(data);
}


/* =========================================================
   init
========================================================= */
function init(){
  loadAll();
updateReadingModeUI();
  initBgm();
  initVoiceUI();
  
  initDataManager();// default
  document.getElementById('sfx-type-toggle').checked = true;
  document.getElementById('sfx-coin-toggle').checked = true;
  document.getElementById('sfx-clear-toggle').checked = true;
  currentSettings.sfxType = true;
  currentSettings.sfxCoin = true;
  currentSettings.sfxClear = true;
  currentSettings.timeLimitMin = parseInt(document.getElementById('time-slider').value,10);

  // 出題順UIの初期化
  try{
    const q = document.getElementById('question-order');
    if(q) q.value = currentSettings.questionOrder || 'random';
  }catch(e){}

  // if data exists, enable
  if(allWords.length>0){
    document.getElementById('total-words-count').textContent = allWords.length;
  }
  setupStartOverlay();
  goToScreen('grade');
}

/* === ここから追加 === */
function showSrsToast(grade){
  const gStr = (grade||'').toLowerCase();
  let bg = '#333';
  if(gStr==='again') bg='#ef4444'; // Red
  else if(gStr==='hard') bg='#eab308'; // Yellow
  else if(gStr==='good') bg='#22c55e'; // Green
  else if(gStr==='easy') bg='#3b82f6'; // Blue

  const ov = document.createElement('div');
  ov.style.position='fixed'; 
  ov.style.left='50%'; 
  ov.style.top='15%'; 
  ov.style.transform='translateX(-50%)';
  ov.style.background=bg; 
  ov.style.color='#fff'; 
  ov.style.padding='6px 20px'; 
  ov.style.borderRadius='9999px';
  ov.style.zIndex = 9999; 
  ov.style.fontFamily='Roboto Mono, sans-serif'; 
  ov.style.fontWeight='bold';
  ov.style.fontSize='16px';
  ov.style.boxShadow='0 4px 10px rgba(0,0,0,0.2)';
  ov.style.pointerEvents='none';
  
  ov.textContent = (grade||'').toUpperCase();

  document.body.appendChild(ov);
  
  // Simple fade out
  ov.animate([{opacity:0, transform:'translate(-50%, 10px)'}, {opacity:1, transform:'translate(-50%, 0)'}], {duration:150, easing:'ease-out'});
  setTimeout(()=>{ 
    const anim = ov.animate([{opacity:1}, {opacity:0}], {duration:200, fill:'forwards'});
    anim.onfinish = ()=>ov.remove();
  }, 600);
}

window.onload = init;
</script>

<!-- SRS Integration -->
<script src="./srs/srs_core.js"></script>
<script>
/* Lightweight integration: exposes `recordAttemptForSRS(text, typed, startTs, missCount, pauseMax, pressedIDK)`
   which runs auto-judging, updates FSRS-like storage, logs the attempt, and schedules short-term repeat.
   Also exposes `window._srs` for debugging. */
(function(){
  try{
    const srs = window._srs = new SRSCore();

    function makeCurrentCardId(text){
      const grade = (window.selectedGrade || document.getElementById('selected-grade-label')?.textContent || '1').toString();
      const section = (window.selectedSection || document.getElementById('selected-section-label')?.textContent || '1').toString();
      const mode = (window.currentMode || 'normal').toString();
      return srs.makeCardId({grade, section, mode, text});
    }

    window.recordAttemptForSRS = function(text, typed, elapsedSec, missCount, pauseMax, pressedIDK, forcedGrade){
      const allowSec = srs.estimateAllowSec(text);
      const res = srs.autoJudge({cardMeta:null, missCount:missCount||0, pauseMax:pauseMax||0, elapsedSec: elapsedSec || 0.01, allowSec, pressedIDK:!!pressedIDK});
      
      if(forcedGrade) {
        res.grade = forcedGrade;
      }

      const cardId = makeCurrentCardId(text);

      // push WPM
      const chars = text.replace(/\s+/g,'').length;
      const words = Math.max(1, chars/5);
      const wpm = words / (elapsedSec/60);
      srs.pushWpm(wpm);

      srs.updateFSRS(cardId, res.grade);
      srs.logAttempt(cardId, {grade:res.grade, missCount, pauseMax, elapsedSec, allowSec, reason:res.reason});
      srs.scheduleRepetition(cardId, res.grade, 0);

      showSrsToast(res.grade, res.reason);
      return res;
    };

    function showSrsToast(grade, reason){
      const gStr = (grade||'').toLowerCase();
      let bg = '#333';
      if(gStr==='again') bg='#ef4444'; // Red
      else if(gStr==='hard') bg='#eab308'; // Yellow
      else if(gStr==='good') bg='#22c55e'; // Green
      else if(gStr==='easy') bg='#3b82f6'; // Blue

      const ov = document.createElement('div');
      ov.style.position='fixed'; 
      ov.style.left='50%'; 
      ov.style.top='15%'; 
      ov.style.transform='translateX(-50%)';
      ov.style.background=bg; 
      ov.style.color='#fff'; 
      ov.style.padding='6px 20px'; 
      ov.style.borderRadius='9999px';
      ov.style.zIndex = 9999; 
      ov.style.fontFamily='Roboto Mono, sans-serif'; 
      ov.style.fontWeight='bold';
      ov.style.fontSize='16px';
      ov.style.boxShadow='0 4px 10px rgba(0,0,0,0.2)';
      ov.style.pointerEvents='none';
      
      ov.textContent = (grade||'').toUpperCase();

      document.body.appendChild(ov);
      
      // Simple fade out
      ov.animate([{opacity:0, transform:'translate(-50%, 10px)'}, {opacity:1, transform:'translate(-50%, 0)'}], {duration:150, easing:'ease-out'});
      setTimeout(()=>{ 
        const anim = ov.animate([{opacity:1}, {opacity:0}], {duration:200, fill:'forwards'});
        anim.onfinish = ()=>ov.remove();
      }, 600);
    }

  }catch(e){ console.error('SRS integration failed', e); }
})();
</script>


<!-- データ管理（選択削除） -->
<div id="data-manager-overlay" class="fixed inset-0 z-[9998] hidden">
  <div class="absolute inset-0 bg-slate-900/70" onclick="closeDataManager()"></div>

  <div class="relative mx-auto mt-6 w-[96%] max-w-5xl bg-white rounded-3xl shadow-2xl border border-slate-200 overflow-hidden">
    <div class="flex items-center justify-between px-4 py-3 border-b border-slate-200 bg-white">
      <div class="font-black text-lg flex items-center gap-2">
        <i class="fas fa-database text-sky-600"></i>
        <span>データ管理</span>
        <span class="text-xs font-bold text-slate-400">（選んで削除）</span>
      </div>

      <div class="flex items-center gap-2">
        <button id="dm-tab-sections" class="px-3 py-1 text-xs font-black rounded-full bg-sky-600 text-white">セクション</button>
        <button id="dm-tab-words" class="px-3 py-1 text-xs font-black rounded-full bg-slate-100 text-slate-600 hover:bg-slate-200">単語</button>
        <button onclick="closeDataManager()" class="px-3 py-1 text-xs font-black rounded-full bg-slate-800 text-white hover:bg-slate-900">
          閉じる
        </button>
      </div>
    </div>

    <div class="p-4 max-h-[72vh] overflow-y-auto">
      <!-- Sections view -->
      <div id="dm-sections-view">
        <div class="mb-3 p-3 rounded-2xl bg-slate-50 border border-slate-200">
          <div class="text-xs text-slate-600 font-bold leading-relaxed">
            ※ version up（更新）がされることがあります。キャッシュが新しくならないと、更新が反映されないことがあります。<br>
            <span class="text-red-600">「Cookie / サイトデータ」まで削除すると、学習データ（履歴・進捗・SRS）は消えます。</span>
            その前に必ずバックアップを保存してください。
          </div>
          <div class="mt-2 flex flex-wrap gap-2 items-center">
            <button id="dm-backup-json" class="px-3 py-2 text-xs font-black rounded-xl bg-emerald-600 text-white hover:bg-emerald-700">
              バックアップ保存（TXT）
            </button>
            <label class="px-3 py-2 text-xs font-black rounded-xl bg-sky-600 text-white hover:bg-sky-700 cursor-pointer">
              復元（バックアップ読込）
              <input id="dm-restore-json" type="file" accept=".txt,.json,application/json,text/plain" class="hidden">
            </label>
            <div class="text-xs text-slate-500 font-bold">
              ※ バックアップはPC/クラウド等の安全な場所に保管してください（端末のデータ削除で一緒に消える場合があります）。
            </div>
          </div>
        </div>

        <div class="flex flex-col md:flex-row md:items-center gap-2 md:gap-3 mb-3">
          <input id="dm-sections-search" type="text" placeholder="検索（セクション名 / Grade）"
                 class="w-full md:w-96 px-3 py-2 rounded-xl border border-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-200 text-sm">
          <div class="flex items-center gap-2">
            <button id="dm-sections-selectall" class="px-3 py-2 text-xs font-black rounded-xl bg-slate-100 hover:bg-slate-200">全選択</button>
            <button id="dm-sections-clear" class="px-3 py-2 text-xs font-black rounded-xl bg-slate-100 hover:bg-slate-200">解除</button>
            <button id="dm-sections-delete" class="px-3 py-2 text-xs font-black rounded-xl bg-red-600 text-white hover:bg-red-700">
              選択したセクションを削除
            </button>
          </div>
        </div>

        <div class="text-xs text-slate-500 font-bold mb-2">
          ※ セクションを削除すると、そのセクションの <span class="text-red-600">学習進捗/成績/履歴/SRS</span> も一緒に整理します。
        </div>

        <div class="overflow-x-auto border border-slate-200 rounded-2xl">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50">
              <tr class="text-left text-slate-600">
                <th class="p-2 w-10"></th>
                <th class="p-2 w-24">Grade</th>
                <th class="p-2">Section</th>
                <th class="p-2 w-24">件数</th>
                <th class="p-2 w-40">操作</th>
              </tr>
            </thead>
            <tbody id="dm-sections-tbody" class="divide-y divide-slate-100"></tbody>
          </table>
        </div>

        <div id="dm-sections-empty" class="hidden mt-4 text-center text-slate-500 font-bold">
          データがありません
        </div>
      </div>

      <!-- Words view -->
      <div id="dm-words-view" class="hidden">
        <div class="flex flex-col gap-2 mb-3">
          <div class="flex flex-col md:flex-row md:items-center gap-2">
            <select id="dm-grade-filter" class="px-3 py-2 rounded-xl border border-slate-200 text-sm">
              <option value="">全Grade</option>
            </select>
            <select id="dm-section-filter" class="px-3 py-2 rounded-xl border border-slate-200 text-sm">
              <option value="">全Section</option>
            </select>
            <input id="dm-words-search" type="text" placeholder="検索（英語 / 日本語）"
                   class="w-full md:flex-1 px-3 py-2 rounded-xl border border-slate-200 focus:outline-none focus:ring-2 focus:ring-sky-200 text-sm">
          </div>

          <div class="flex items-center gap-2">
            <button id="dm-words-selectall" class="px-3 py-2 text-xs font-black rounded-xl bg-slate-100 hover:bg-slate-200">全選択</button>
            <button id="dm-words-clear" class="px-3 py-2 text-xs font-black rounded-xl bg-slate-100 hover:bg-slate-200">解除</button>
            <button id="dm-words-delete" class="px-3 py-2 text-xs font-black rounded-xl bg-red-600 text-white hover:bg-red-700">
              選択した単語を削除
            </button>
            <div class="ml-auto text-xs text-slate-500 font-bold">
              表示上限: <span id="dm-words-cap">500</span>件 / 表示中: <span id="dm-words-shown">0</span>件
            </div>
          </div>

          <div class="text-xs text-slate-500 font-bold">
            ※ 単語を削除すると、そのセクションの <span class="text-red-600">途中経過（進捗）</span> は安全のためリセットします（SRSカードも削除）。
          </div>
        </div>

        <div class="overflow-x-auto border border-slate-200 rounded-2xl">
          <table class="min-w-full text-sm">
            <thead class="bg-slate-50">
              <tr class="text-left text-slate-600">
                <th class="p-2 w-10"></th>
                <th class="p-2 w-20">Grade</th>
                <th class="p-2 w-40">Section</th>
                <th class="p-2">English</th>
                <th class="p-2">日本語</th>
              </tr>
            </thead>
            <tbody id="dm-words-tbody" class="divide-y divide-slate-100"></tbody>
          </table>
        </div>

        <div id="dm-words-empty" class="hidden mt-4 text-center text-slate-500 font-bold">
          条件に一致する単語がありません
        </div>
      </div>
    </div>
  </div>
</div>

<!-- 15min Study Reward Overlay -->
<div id="reward-overlay" class="fixed inset-0 z-[10000] hidden items-center justify-center bg-black/80 cursor-pointer" onclick="hideRewardOverlay()">
  <div class="text-center">
    <img id="reward-gif" src="15min_study.gif" class="max-w-sm md:max-w-md rounded-2xl shadow-2xl border-4 border-yellow-300" alt="Study Reward">
    <p id="reward-msg" class="mt-4 text-white font-bold text-xl drop-shadow">今週の平均学習時間15分達成！おめでとう！Practice makes perfect!</p>
    <p id="reward-close-hint" class="mt-2 text-slate-300 text-sm transition-opacity duration-300">（クリックして閉じる）</p>
  </div>
</div>

<!-- SRS 管理パネル -->
<div id="srs-panel" style="display:none; position:fixed; right:20px; top:80px; width:420px; max-height:70vh; overflow:auto; z-index:99999; background:#fff; border:1px solid #e5e7eb; box-shadow:0 6px 24px rgba(0,0,0,.12); border-radius:12px; padding:12px">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <strong>SRS 管理</strong>
    <div>
      <button onclick="refreshSrsPanel()" style="margin-right:6px" class="px-2 py-1 text-xs bg-sky-50 rounded">Refresh</button>
      <button onclick="closeSrsPanel()" class="px-2 py-1 text-xs bg-gray-100 rounded">Close</button>
    </div>
  </div>
  <div style="font-size:13px;margin-bottom:8px">
    <span>Due now: <span id="srs-due-count-ui">0</span></span>
    <span style="margin-left:12px">Cards total: <span id="srs-total-count-ui">0</span></span>
  </div>
  <div style="margin-bottom:8px">
    <button onclick="exportSrsJson()" class="px-3 py-2 bg-emerald-50 text-emerald-700 rounded text-sm">Export JSON</button>
  </div>
  <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
    <label style="font-size:12px;">期間:
      <select id="srs-log-period-filter" style="margin-left:6px;padding:4px;font-size:12px">
        <option value="1">24時間</option>
        <option value="7">7日</option>
        <option value="30" selected>30日</option>
        <option value="90">90日</option>
        <option value="0">全期間</option>
      </select>
    </label>

    <label style="font-size:12px;">学年:
      <select id="srs-log-grade-filter" style="margin-left:6px;padding:4px;font-size:12px">
        <option value="all" selected>All</option>
      </select>
    </label>

    <button onclick="applySrsLogFilters()" class="px-2 py-1 text-xs bg-sky-50 rounded">Apply</button>
  </div>
  <div>
    <h4 style="margin:6px 0">Due List</h4>
    <ul id="srs-due-list" style="list-style:none;padding:0;margin:0 0 12px 0;max-height:200px;overflow:auto"></ul>
    <h4 style="margin:6px 0">Recent Logs</h4>
    <div id="srs-logs" style="font-size:12px;max-height:220px;overflow:auto;border-top:1px solid #f1f5f9;padding-top:8px"></div>
  </div>
</div>

<script>
function openSrsPanel(){ document.getElementById('srs-panel').style.display='block'; refreshSrsPanel(); }
function closeSrsPanel(){ document.getElementById('srs-panel').style.display='none'; }

function refreshSrsPanel(){
  try{
    const raw = localStorage.getItem('srs_data');
    if(!raw){ document.getElementById('srs-due-count-ui').textContent='0'; document.getElementById('srs-total-count-ui').textContent='0'; document.getElementById('srs-due-list').innerHTML='(no data)'; document.getElementById('srs-logs').textContent=''; return; }
    const obj = JSON.parse(raw);
    const cards = obj.cards || {};
    const coreLogs = obj.logs || [];
    // also include app-level srs log key if present
    let appLogs = [];
    try{ appLogs = JSON.parse(localStorage.getItem(STORAGE_KEY_SRS_LOG) || '[]'); }catch(e){ appLogs = []; }
    const logs = [].concat(coreLogs || [], appLogs || []);
    const now = Date.now();
    const due = [];
    Object.keys(cards).forEach(id=>{
      const c = cards[id];
      if(c && c.due && c.due <= now) due.push({id, card:c});
    });
    document.getElementById('srs-due-count-ui').textContent = due.length;
    document.getElementById('srs-total-count-ui').textContent = Object.keys(cards).length;

    const dueListEl = document.getElementById('srs-due-list'); dueListEl.innerHTML='';
    if(due.length===0) dueListEl.innerHTML = '<li style="color:#666">No due cards</li>';
    due.slice(0,200).forEach(d=>{
      const li = document.createElement('li'); li.style.padding='6px 4px'; li.style.borderBottom='1px solid #f3f4f6';
      li.textContent = `${d.id}  (due: ${new Date(d.card.due).toLocaleString()})`;
      dueListEl.appendChild(li);
    });

    // populate grade filter options
    try{
      const gradeSel = document.getElementById('srs-log-grade-filter');
      if(gradeSel){
        const grades = new Set();
        logs.forEach(l=>{ if(l && l.grade!=null) grades.add(String(l.grade));
          else if(l && l.cardId){ const parts = String(l.cardId).split('|'); if(parts[0]) grades.add(parts[0]); }
        });
        const prev = gradeSel.value || 'all';
        gradeSel.innerHTML = '<option value="all">All</option>';
        Array.from(grades).sort((a,b)=>{ if(a==='custom') return 1; if(b==='custom') return -1; return (isNaN(a)||isNaN(b))? a.localeCompare(b): a-b; }).forEach(g=>{
          const opt = document.createElement('option'); opt.value = g; opt.textContent = (g==='custom')? 'Custom' : `Grade ${g}`; gradeSel.appendChild(opt);
        });
        gradeSel.value = Array.from(gradeSel.options).some(o=>o.value===prev)? prev : 'all';
      }
    }catch(e){}

    // Apply filters (period / grade)
    const periodDays = parseInt(document.getElementById('srs-log-period-filter')?.value || '30', 10);
    const gradeFilter = document.getElementById('srs-log-grade-filter')?.value || 'all';
    const logsEl = document.getElementById('srs-logs'); logsEl.innerHTML='';
    const cutoff = periodDays>0 ? (Date.now() - periodDays*24*60*60*1000) : 0;
    const filtered = logs.filter(l=>{
      if(!l || !l.ts) return false;
      if(cutoff && l.ts < cutoff) return false;
      if(gradeFilter && gradeFilter!=='all'){
        if(l.grade!=null){ if(String(l.grade)!==String(gradeFilter)) return false; }
        else if(l.cardId){ const parts = String(l.cardId).split('|'); if(parts[0] !== String(gradeFilter)) return false; }
      }
      return true;
    });

    if(filtered.length===0) logsEl.innerHTML = '<div style="color:#666">No logs in this range</div>';
    filtered.slice(-500).reverse().forEach(l=>{
      const row = document.createElement('div'); row.style.padding='6px 4px'; row.style.borderBottom='1px dashed #f1f5f9'; row.style.display='flex'; row.style.justifyContent='space-between'; row.style.alignItems='center';
      const time = new Date(l.ts).toLocaleString();
      const idOrSec = l.cardId || l.sectionKey || l.mode || '';
      const res = l.grade || l.result || '';
      const reason = l.reason || l.category || '';
      const left = document.createElement('div'); left.style.flex='1'; left.textContent = `${time} | ${idOrSec} | ${res} | ${reason}`;
      const btnWrap = document.createElement('div'); btnWrap.style.marginLeft='8px';
      const openBtn = document.createElement('button'); openBtn.textContent='カードを開く'; openBtn.className='px-2 py-1 text-xs bg-sky-50 rounded';
      openBtn.onclick = ()=>{
        try{ openCardFromLog(l); }catch(e){ alert('カードを開けませんでした'); console.error(e); }
      };
      btnWrap.appendChild(openBtn);
      row.appendChild(left);
      row.appendChild(btnWrap);
      logsEl.appendChild(row);
    });
  }catch(e){ console.error(e); }
}

function applySrsLogFilters(){ refreshSrsPanel(); }

function exportSrsJson(){
  const raw = localStorage.getItem('srs_data') || '{}';
  const blob = new Blob([raw], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'srs_data_export.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

// Parse card id strings used by different log sources
function parseCardIdString(idStr){
  if(!idStr) return null;
  // try '||' format
  if(idStr.includes('||')){
    const parts = idStr.split('||');
    if(parts.length>=4) return {grade:parts[0], section:parts[1], mode:parts[2], en:parts.slice(3).join('||')};
  }
  // try '|' format
  if(idStr.includes('|')){
    const parts = idStr.split('|');
    if(parts.length>=4) return {grade:parts[0], section:parts[1], mode:parts[2], en:parts.slice(3).join('|')};
  }
  return null;
}

function openCardFromLog(logEntry){
  // logEntry may have cardId, or grade/sectionKey/mode and possibly no en
  let info = null;
  if(logEntry.cardId) info = parseCardIdString(logEntry.cardId);
  if(!info){
    // try app-style fields
    if(logEntry.grade!=null && logEntry.sectionKey && logEntry.mode){
      info = { grade: String(logEntry.grade), section: String(logEntry.sectionKey), mode: String(logEntry.mode), en: null };
    }
  }
    if(!info) return alert('このログからはカード情報を取得できません');
  
    const g = info.grade;
    const sec = info.section;
  }
  </script>
  
  

<script>
  // === Mobile portrait: collapsible top controls ===
  (function(){
    const body = document.body;
    const overlay = document.getElementById('ctrl-overlay');
    const toggleBtn = document.getElementById('ctrl-toggle-btn');
    const closeBtn = document.getElementById('ctrl-close-btn');

    function isMobilePortrait(){
      try{
        const coarse = window.matchMedia('(pointer: coarse)').matches;
        const portrait = window.matchMedia('(orientation: portrait)').matches;
        return coarse && portrait;
      }catch(e){
        return false;
      }
    }

    function setCollapsed(){
      body.classList.add('ctrl-collapsed');
      body.classList.remove('ctrl-expanded');
      if(overlay) overlay.classList.add('hidden');
    }
    function setExpanded(){
      body.classList.add('ctrl-expanded');
      body.classList.remove('ctrl-collapsed');
      if(overlay) overlay.classList.remove('hidden');
    }
    function syncMode(){
      if(isMobilePortrait()){
        // default collapsed to avoid blocking taps
        if(!body.classList.contains('ctrl-expanded')) setCollapsed();
      }else{
        // desktop / landscape: ensure normal behavior
        body.classList.remove('ctrl-collapsed','ctrl-expanded');
        if(overlay) overlay.classList.add('hidden');
      }
    }

    // Wire events
    if(toggleBtn) toggleBtn.addEventListener('click', setExpanded);
    if(closeBtn) closeBtn.addEventListener('click', setCollapsed);
    if(overlay) overlay.addEventListener('click', setCollapsed);

    // Re-evaluate on rotate / resize
    window.addEventListener('resize', syncMode);

    // Close panel on any typing attempt so it won't cover practice UI
    window.addEventListener('keydown', () => {
      if(body.classList.contains('ctrl-expanded')) setCollapsed();
    });

    // init after DOM is ready
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', syncMode);
    }else{
      syncMode();
    }
  })();
</script>


</body>
  </html>
